//=====discuz phpcms shopex几种觉的开源系统框架







ttthttp://www.tpcwre.icoc.cc  我的个人网站



//=====discuz phpcms shopex几种觉的开源系统框架
discuz 		论坛系统。
phpcms		内容管理系统
shopex		商城系统


7.18 晚，44集
http://zhidao.baidu.com/question/1302868156325079099.html?quesup2&oldq=1
云淡风清
http://zhidao.baidu.com/question/1817722586083688588.html?quesup2&oldq=1

http://zhidao.baidu.com/question/1638571502300682100.html?quesup2&oldq=1

http://php.net/download-docs.php   PHP手册下载。

关键字：for() 	while()   do_while	   switch() 	case   break    continue   goto   iframe   form   (embed src)    (img src)    (mapuse=#__map)    position     attachment    if()
frameset    (script-change-click)     request   mysql     connect   charset    query   fetch   
assoc   row    nums   rows  
background    font  size   color   <style>    <script language="javascript">   inclued_once  require_inclued     define    const    unset(释放)     isset(检测是否设置)     empty(是否为空)
function    global    array    integer     float     boolean    string     object    null



特殊注意事项：
在浏览器中的<div>的高度最低是18px,如果想要设置更低的话需要，加上overflow:hidden
<meta http-equiv="refresh" content='3'>   意思是三秒钟刷新一次！
<meta http-equiv="refresh" content='3;url=http://www.baidu.com'> 就是三秒后跳转到指定页面 
overflow:hidden;  当内容大于区域时，用些属性，会隐藏所超出区域 的内容
pro in obj   //遍历对象属性
label--让一个属性区域成为一个整体扩大点击范围
<label for="qx"><input type="checkbox" id="qx" onclick="sall(this)"/>

<?php sleep(3); ?>	//睡眠3秒钟后再执行后面的内容





//-----选项卡上标题的图标

在CSS中设置 :  cursor:pointer     指定元素上鼠标变成小手形状，


一，frameset  窗口框架

二: iframe浮动窗口：

三：form 表单：

四: 多媒体声音及视频：

五：图像映射和脚本提示.

六：CSS--虑镜和伪类：

七：选择器类型及父子选择器：

八：块元素和行内元素-概念。

九：行内元素和块元素可以相互转换；

十：CSS之间可以相互引用：

十一：标准流和非标准流.

十二：盒子模型：

十三：浮动。

十四：浮动定位。

十五：区块层叠顺序设置；

十六：关于PHP以及bs和cs的介绍

十七：apache的命令行和相关的配置

十八：apache-虚拟主机
	二十一： 一个IP绑定多个域名。

十九：PHP开发环境的搭建。
      MYSQL安装Error:0问题
	---mysql相关命令：
	

二十：Discuz论坛

二十一：数据类型介绍：

二十二，switch 特例  IF和WTITCH的应用区别

二十三： while与 do while

二十四： 用循环语句打印出 三角形，金字塔，和空心凌形。

二十五： PHP版计算器及表单信息传送另一页面和request接收

二十六： 猜拳游戏及script change转换图片功能
----script函数-isNaN 检测是否为一个数值----

二十七 循环相关语句-break-continue-goto以及-常量

二十八: 函数
	1,函数的调用；
	2，require()和require_once()的区别和细节
	3,include（）和include_once() 的区别
	4，include 和require的区别 (同_once)
	5，函数的深入：
		1，函数的参数列表可以是多个。
		2，参数列表可以是多个，并且数据类型可以是任意的类型。
		array,integer,float,boolean,string,object,null,资源类型；
		3，函数的命名跟自定义变量一样，首字母只能使用_,A-Z,a-z.
		4, 一个自定义函数中的变量是局部的，函数外不生效，
		5，使用global全局变量的时候，可使用在函数外的变量，
		6，函数不区分大小写。function Abc() 等同于 function abc()
		7,unset()释放一个变量：
	6，在PHP函数中， 我们可以给某些参数，赋一个默认的值。
	7, php引用（地址）传递，可以使用 &变量名.




二十九：php页面函数相互调用的知识点

三十：二进制与位运算 & | ^ ~ >> <<：

三十一： 数组：

----什么是数组：
-----数组的创建：
1，创建数组：
2.创建数组的第二种方法
3.第三种方式创建数组下标，是从0开始编号也可以自己指定。
------注意事项：
1：创建数组未指定下标，PHP会以最大的那个下标值加 1 作为该元素的下标
2:如果我们给某个元素的下标一样，则会覆盖原来的值。
3: 当以false 和true 做为下标时，那么 false 相当于0, true相当于1.
4：当以 null 做为下标时，那么访问时 null 等同于 " " 
5：当下标带有小数部分时，默认是取整数部分，如12.4 等同于 12;
6: 显示数组的方式：echo ,print_r(),var_dump()
7: 访问数组的时候，不要越界。
8, 一维数组的引用：
9, 一维数组的使用陷井：
10, php的数组可以动态增长。
11: php的数组相关的函数说明count,is_array,explode。
12: php数组遍历的四个方法：for(), while(), do_while(), foreach()
13: unset销毁元素。
14： 数组运算符$a + == != <> !== $b：
15：如何关闭notice级别的提示。
16: 指定小数点后的位数-round(1.95583,-2)指定精度。


三十二：排序法-冒泡，选择，插入，快速排序法：


=====script相关
	-----script this.src 点击图片变换图片内容
		猜拳游戏及script change转换图片功能
	----script函数-isNaN 检测是否为一个数值----


=====查找：
	-----顺序查找：
	-----二分查找法（必须掌握）


======多维数组-二维数组
	-----二维数组的基本语法：


=====作业讲解：
	------游戏机
	------跳水比赛


=====常量：
	-----常量的定义与使用：
	-----const与define的区别


=====面向对象编程：
	-----成员属性的说明：
	-----分析对象在内存中存在的形式：
	-----成员方法的讲解：


====构造方法====
	----构造方法的两个版本
	――this的理解
	----构造方法注意事项：
	-----构造方法案例

=====析构方法 __destruct
====静态变量
	----使用全局变量
	----使用静态变量。
	----如何定义静态变量
	----如何访问静态变量



====魔术方法（函数）与魔术常量====

	----魔术方法（函数）
	----魔术常量:
	----	__get、__set
	----	__call
	----	__clone
	----	__toString
	----	__sleep、__wakeup
	----	__construct、__destruct
	----	__autoload
	----	__isset、__unset
	----	__set_state
	----	__invoke(PHP 5.3.0以上版本有效)
	----	__callStatic(PHP 5.3.0以上版本有效)

	=====用面向对象的方式做计算器项目====


=====使用PHP技术对XML文件进行操作=====
	-----三种XML操作技术;
	-----DOM说明：
	-----DOM命令及查找案例：

=====DOM技术-添加节点内容实例=====

=====xpath====

=====simplexml=====
	-----simplexml与xpath结合：
	-----1， 直接装载xml文件
	------simpleXML也可以和xpath结合，功能强大
	-----<<<xxx xxx  与大型字符串
	-----simple装载DOM对象。

=====http协议=====
	-----预定义全局变量：
	-----页面请求方式有：
	-----http响应
	-----状态码的说明：
	-----通过http响应，控制浏览器间隔一定时间去跳转
	-----禁止页面缓存
	-----设置文件下载：



=====php数据库编程=====
	-----php操作mysql数据库的三种方式
	-----mysql扩展库和mysql数据库的区别
	-----数据有符号和无符号的区别；
	-----字符串char 和varchar的区别
	-----mysql环境的搭建
	-----数据库（cmd）操作命令：
	-----用md5加密数据库中的密码；
	-----解决数据库与网页乱码问题（Data too long）
	-----mysql取出查询结果的四种方法
	-----数据类型的种类
	-----总结实例
     例子----把数据库中的数据以列表的形式显示出来
	-----exit()调试使用函数;
	-----往mysql数据库插入中文字串的方法
	-----mysqli 的释放内存和关闭连接



=====使用php的mysqli扩展库操作mysql数据库
	-----mysqli操作数据库（对象与过程的区别）
	-----mysqli 批量执行sml语句
	-----mysqli批量执行dml语句



=====mysqli事务类型处理=====
	-----mysqli 事务控制 acid
	-----事务处理-账号转账案例
	-----事务处理-节点备份与恢复



=====mysqli stmt 预处理技术 
	-----mysql工作原理及预处理技术
	-----mysqli预处理技术prepare  添加实例
	-----mysqli预处理技术-prepare  ---查询实例
	-----预编译可以自动防止sql（结构化查询语句）注入攻击
	-----防攻击的解决方案
    实例-----用表格的方式显示数据表的信息和内容









=====超全局变量=====
        -----全局变量:
	-----超全局变量(9种)：
	-----$_GET 实际使用
	-----解决GET在传送中文时出现错误的方法
	-----如何判断是否接收到数据（值）
	----- 在apache的conf.ini中不要启用register_globals
	-----超全局量--POST和GET以及它们的区别：
	-----超全局变量--$_REQUEST




=====IDE集成开发工具 zend studio =====
 	-----zend studio设置编码格式：
	-----zend studio快捷键设置
	-----断点：
	-----编写雇员管理系统
	-----原型开发：
	-----雇员关系系统开发文档
	-----网站的开发经过的三个阶段



=====cookie 和cession=====
	-----coolie的初步介绍
	-----cookie 信息的创建，获取，更新，删除，
	-----显示上次登陆时间（不严谨）
	-----解决时差问题的两种方案
	-----php出现Cannot modify header information问题的解决方法
	-----cookie 或header出现information错误的解决方法

=====Session===
	-----cookie 和 session 在php.ini中的设置：
	-----session 数据可以存放的位置
	-----session设置实例:
	-----获取 Session 数据
	-----更新 Session 数据
	-----删除 session 数据	-----通过 session 保存购物车简单案例
	-----获取session 的id号
	-----Session和Cookie的主要区别及自动启动session：
	-----用户禁用cookie后解决session文件共享的三种方法：
	=====session的验证码技术
	-----验证码实例代码
	-----cookie 和session的区别
	-----设置用户自定义session会话存储函数
=====文件编程=====
	-----文件操作相关函数
	-----操作文件的六种方式
	-----第一种获取文件信息的方法
	-----第二种获取文件信息的方法-直接获取指定信息
	-----第一种读取文件内容的方法 fread()
	-----第二种读取文件内容的方法
	-----第三种读取文件方法。分批读取
	-----将有序内容的ini文件直接转化成数组
	-----第一种写入方式 fwrite()
	-----第二种写入方式 file_put_contents()
	=====文件的拷贝
		-----不带中文路径的文件复制
		-----带中文路径的文件复制
	-----创建一个文件夹 mkdir()
	-----同时创建多层级文件 mkdir($dir,0777,true)
	-----删除文件夹 rmdir()
	-----创建一个文件并写入内容 
	-----删除一个文件  unlink()

=====文件的上传
	-----文件上传大小的限制
	-----文件上传类型的限制
	-----防止用户图片覆盖问题及上传文件同名问题


=====PHP 报表开发=====
	-----php绘图坐标系统
	-----php绘图技术
	-----启用图像库
	-----PHP绘图实例
	-----PHP绘图圆柱形三块分布图


=====图表开发库 jpgraph
	-----graph解决乱码函数
	-----奥巴马与布什竟选择接数据库案例
	-----以带干扰的图片方式做验证码
	-----script this.src 点击图片变换图片内容

=====PHP网上支付=====
	-----网上支付目前有两种支付方式：
	-----目前国内比较好的中间公司
	-----易宝支付协议介绍：
	-----易宝网上支付系统案例




======javascript=====
	-----javascript有alert,document.write两种写入方式
	-----script可以在任何地方嵌入，但不可在<>内和style中
	-----href,form,onclick 触发式脚本
	-----js外连文件也可以互通的，也可以相互调用
	-----关于 + ---关于 %
	-----关于布尔值与其它值的关系！
	-----关于 || 的一个特例
	-----关于三目运算的形式
	-----关于script的for循环与break 跳出循标签！
	-----script显示表格，隔行换色，鼠标指行变色
	-----javaScript中的函数
	-----函数回调简单案例
	-----script 函数默认参数的设置
	-----arguments 显示函数参数的值
	-----利用arguments 计算参数值的和 
	-----javascript 时间 Date()

=====javaScript 系统函数=====
	-----用escape方法将字符串内容转成另一种编码。
	-----用unescape方法将编码后的内容再转回到字符串。
	-----parseLint 将浮点数转成整数（舍去小数部分）
	-----isNaN 检验变量是否为一个数字
	-----eval把代码当成字符串来解析。
	-----parseInt 把字符串转成整数
   	-----parseFloat 把字符串转成浮点数
	-----isFinite 指明提供的数字是否是有限的

=====JavaScript对象
	-----script创建对象的方法一；
	-----创建对象的方法二
	-----script创建对象的方法三；
	-----for(变量 in 对象)遍历对象中的元素
	-----调用document系统自定义对象
	-----with() 简化对象的操作
	-----script 显示日期及设置



=====script内置系统函数
	-----简单程序方法的创建demo=new Function('x','y','return x/y');
	-----script数学函数随机数，上下取整，四舍五入
	-----函数replace替换字符 /^\S*$/   代表非空格

=====script的array函数
	-----第四种创建对象的方法 json
	-----声明数组的方式一
	-----向数组传参，并调用其长度和内容
	-----数组的声明方法二
	-----数组长度的声明方式
	-----数组的排序
	-----数组的出入栈，出入队
	-----更换文档背景颜色
	-----网页版贪吃蛇（部分）


===== DOM =====
	-----innerText 与 innerHTML
	-----innerText与textContent的兼容选择
	-----<textarea>在对象取值时要用value
	-----在DOM对象中设置style样式的几种方法
	-----offset 获取不未知元素信息（如区域宽高度）
	----用pro in 方法显示对象中所有的元素
	-----复选框的全选与取消的实现一
	-----复选框的全选与取消的实现二
	-----通过名字取出表单项的值
	-----script实现在同一区域中显示不同的内容
	-----通过数组转成对象的七种方式

	-----父节点，同胞节点，子节点的运用实例	
	-----创建节点并添加元素和内容
	-----给文档流输入节点内容
	-----文档流输入指定到子节点的输入<br>



=====script事件处理
	-----点击事件的第一种方法
	-----点击事件的第二种方法
	-----点击事件的第三种方法
	------一个事件源添加多个事件
	-----事件函数中带有return 的注意要点
	-----oncontextmenu禁止右键
	-----页面禁止右键，并弹出提示
	-----onload当页面加载完成后触发事件
	-----unload页面关闭时触发事件
	-----unload 在页面关闭前触发
	-----beforeunload关闭页面时提示-确定或取消

		
		=====事件对象=====
	-----事件对象，随对象改变显示其内容
	-----事件对象，改变所点击对象的内容
	-----通过事件对象让输入的内容全部为大写
	-----获取键盘事件按键的值（字母和数字键）
	----通过键盘事件关闭浏览器
	-----获取键盘事件按键的值（包括功能键）
	-----setInterval 定时执行功能实现动画效果(数字累加变换)
	-----setInterval 定时执行功能实现计数（带开始停止功能）
	-----网页动画人物移动

-----事件event 		window.event
	-----clientX,Y 获取鼠标在网页可执行区范围内的坐标！
	-----screenX,Y 获取鼠标在屏幕范围的坐标
	-----window.status=str; 把坐标显示在状态栏中
	-----window.document.title=str; 把坐标显示在title上
	-----兼容IE和火狐的坐标显示
	-----网页中图片随鼠标移动
	-----鼠标按下拖动区域或移动
	-----用按键创建一个可移动的区域
	-----window.event.returnValue=false返回事件函数中的值
	-----cancelBubble取消以后事件来解决层级事件的重复发生

------BOM 浏览器对象
	-----confirm确定或取消事件的发生行为
	-----漂浮广告区块的实现
	-----document.body.clientWidth | Height 获取窗口执行区的宽度和高度
	-----one.offsetHeight | Width  	获对象取区块的高度和宽度
	-----setTimeout 单次定时器

	-----父窗体弹出子窗体并控制其内容
	-----子窗体控制父窗体元素
	-----subwin.close()关闭父窗口同时关闭子窗口
	-----跑马灯，状态栏信息来回跑效果
	-------算法：自增再再自减，产生来回动的效果
	-----window.resizeBy(5,5); //每100毫秒窗口的宽和高都增长5pxp
	-----window.close(); 	//窗口5秒后自动关闭
	-----页面分帧
	-----用script 设置分帧显示背景色
	-----window.parent.parent.frames[0].document.bgColor 父窗口的父窗口的背景色
	-----window.top 最顶层的父窗口


	-----html跳转方式 meta http-equiv	
	-----script的几种跳转方式 
	-----location="bounds.html"; 重点记住使用的跳转方法！
	-----location.reload(); script刷新方式，适用做实时时间显示。
	-----history.back()返回上一步
	-----history.go(-1或-2)返回上二步

	-----screen获取屏幕的高度等信息	
	-----window.clipboardData.setData 剪贴板

=====表单对象=====
	-----onsubmit在form标签中验证表单
	-----focus()获取焦点的应用
	-----onsubmit在form标签中验证表单
	-----focus()获取焦点的应用
	-----/^\S+$/ 非空连贯 的应用
	-----用一个变量统计错误信息一并显示
	-----onbulu 失去焦点触发事件的应用(要结合onsubmit)

-----利用表单提交注册信息实例
	//-----获取下一个指定名的同胞节点的方法  gspan(cobj)
	//-----通过表单名获取对象  var username=document.getElementsByName("username")[0];
	//-----当对象获得焦点时触发事件  username.onfocus=function()
	//-----获得焦点触发事件  obj.onfocus=function()
	//-----页面加载完成后调用  onload=regis  或onload=function()
	//-----设置一个方法返回值的变量，来控制onsubmit是否触发
	//-----判断事件的触发行为是submit还是onblur
	-----通过select选项变换图片<br>
	-----onchange() 改变触发事件<br>
	-----selectedIndex 可设置或返回下拉列表中被选选项的索引号<br>
	-----options[] 返回select 元素中所有 option 的一个数组。<br><br><br><br>
	-----省份城市多重选择自动变换实例
	-----selected 属性为select 多选时的首选项

	-----offsetWidth  获取对象的宽度
	-----offsetHeight 获取对象的高度
	-----offsetTop 当前对象框体与父框体的顶部距离 
	-----one.offsetTop+one.parentNode.offsetTop 可累加
	-----计算当前对象到HTML的TOP距离的函数
	----- scrollTop,scrollLeft 滚动距离
	-----用scroll属性定位网页中的图片让其不随页面滚动而变化
	-----position:fixed 使图片固定在页面中 
	-----利用scroll 做字幕在区域中的无缝滚动
	-----overflow:hidden;    隐藏超出区域的内容













	//mysql_fetch_row()  用[0]数字的索引方式显示内容
	//mysql_fetch_assoc() 用'string'字符串的关联方式显示
	//mysql_num_rows()   其表示取得结果集中行的数目 



PHP连接数据库：
<?php
	$link = mysql_connect('localhost','root','abcd')or die('连接数据库失败');   //连接数据库，（）中指定路径，账户，密码。
	mysql_select_db('threephp')or die("选择数据库失败"); 	 //选择数据库，（）中指定哪一个库的库名。
	mysql_set_charset('utf-8');			    //设置使用编码是什么。
					//到这里，数据库就连接成功了。
	$sql = "select id,name,age,sex from user where id = 10"; //查一条时用 $row形式，
	$res = mysql_query($sql);                           //这条语句就是把数据库内容$sql发送了。
	//var_dump($res);	//查看发送是否成功，打开网页显示：resource(3) of type (mysql result)  表示成功。
	//$row = mysql_fetch_assoc($res);
	//var_dump($row);
	while(list($id,$name,$age,$sex) = mysql_fetch_row($res)){  //查多条时用这种while 形式/
		echo "{$id}--{$name}--{$age}--{$sex}--<br/>";
	}

?>
	



<?php
	$link = mysql_connect('localhost','root','abcd');
	mysql_select_db('shoujiguishu');
	mysql_set_charset('utf8');
	$jsps = $_POST['text'];
	$num = substr($jsps,0,7);
	$sql = "select * from shouji where num = ($num)";
	$res = mysql_query($sql);
	if($res&&mysql_num_rows($res)){
		$card = mysql_fetch_assoc($res);
		$istrue = 1;
	}else{
		$istrue = 2;
		$eor = "请输入正确的手机号码！";
	}
?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<title>one</title>
		<meta http-equiv="content-type" content="text/html;	charset=utf8" />
		<link type="text/css" rel="stylesheet" href="./xm.css" />
		<style>
				*{
					margin:0px;
					padding:0px;
				}
		</style>
	</head>
	<body>
		<div class="main">
			<div class="top">
				手机号码所在地查询
			</div>
			<div class="search">
				<form action="" method="post">
					<div class="textc">
						<input type="text" class="text" name="text" value="请输入手机号..." pattern="[0-9]{11}"/>
					</div>
					<div class="searc">
						<input type="submit" class="subc" name="sub" value="" />
						<input type="reset"  class="rec" name="re" value="" />
					</div>
				</form>
			</div>
			<div class="result">
				<?php if($istrue==1){ ?>
				<p>您输入的手机号是：<?php echo $jsps ?></p>
				<p>号码所在城市：<?php echo $card['city'] ?> </p>
				<p>号码所在城市区号：<?php echo $card['quhao'] ?></P>
				<p>手机号所属类型：<?php echo $card['type'] ?></p>
				<?php }else{
					echo "请输入一个正确的手机号码";
					}
				?>
				
			</div>
		</div>
	</body>
</html>




-----------------------------------------------------------------------------------------------------
















---mysql相关命令：
进入数据库： mysql -uroot -p  
 
显示库内容：show databases;

进入数据库：  use threephp    	//threephp为数据库的名字

显示库中的表: show tables;  	

看表的内容结构： desc user;

退出： exit; 或  quit;

 // user 为表名，name 和value 要一一对应
插入内容： insert into user(name,age,sex) value('zhangsan',20,'nan');   
插入多条内容：insert into user(name,age,sex) value('zhangsan',20,'nan')，(name,age,sex) value('zhangsan',20,'nan')，，，，依次类推，就是name等字段名，输入一次，后面的值多闪重复写，间隔用逗号隔开。




	update语句更新数据表中已存在的数据
update 表名 set 字段名=表达式[,....][where 条件]
[order by 字段][limit 行数]

//更新示例；
update user set name = 'wangjun';  //这里不加参数where会改变表中所有该名字的内容。
update user set name = 'zhangsan' where id = 1;  //这样就会只改变第一个字段内容了。


 Delete 删除数据：
delete from 表名 [where 条件] [order by字段] [limit 行数]
delete from user where id = 3;                      //user 是表名，where必须有的参数，




//查询相应字段同容；
select name from user;    //只查name;

select name,age from user; //同时查name 和age 两项。

select * from user;        //查询user 表中所有的内容

select id,name,age,sex from user where id = 33;    //查询id为33的具体内容;

select id,name,age,sex from user where id < 10;    //查询id小于10的所有内容；

select id,name,age,sex from user where id between 15 and 25;   // 查询id从15到25之间的内容.

select id,name,age,sex from user where id in (4,6,32,53,57,60);  //同时显示多条不同的内容。

select id,name,age,sex from user where name like '%a%'; //模糊查找，带某个字符段的。
select id,name,age,sex from user where name like '%g'; //模糊查找，以某个字段开头的，
select id,name,age,sex from user where name like 'w%'; //模糊查找，以某个字段结尾的。

select id,name,age,sex from user order by id;  //正序排列显示，可以用name,age,等其它。后面省略了asc 因为是默认的.
select id,name,age,sex from user order by id desc;  //倒序排列显示，，，，其它同上。

select * from user limit 3;  //limit 限制最多输出三行，
select * from user limit 7,3;  //限制 从第七行开始，最多输出三行。

select count(*) from user; //查询user表里有多少条内容。

select sum(age) from user;  //计算总和：计算user表下的 age 年龄的总和是多少。
select avg(age) from user;  //求平均数； 计算user表下的age 年龄的平均值是多少。
select max(age) from user;  //求最大值； 显示user 表中age年龄最大的。
select min(age) from user;  //求最小值； 显示user表中age年龄最小的。



select version();        //查询版本；

select 1+1;              //可以计算；












操作符：
is null 	a is null  	若操作数a为null ,为真
is not null 	a is not null 	若操作数a不为null,为真
between		a between b and c  若a 在b 和c 之间，为真
not betww	a not between b and c  若操作数不在b和c 之间，为真
like		a like b 	SQL模式匹配，若a 匹配b,为真
not like 	a not like b 	SQL模式匹配，若a不匹配b,则为真
in		a in(b1,b2...)  若a等于b1,b2,b3...中的某一个，则为真.


and 或 && 	a and b 或 a && b	逻辑与，若两个操作数同时为真，则为真，
or 或 || 	a or b 或 a || b 	逻辑与，只要有一个操作数为真，则为真。
xor		a xor b 	逻辑异或,若有且仅有一个操作数为真，则为真(或两个值相同时为假,或两值不同时为真)
not 或!  	not a 或!a	逻辑非,若操作数为假，则为真。














<embed src="tada.wav" hidden="false" autostart="false" loop="2" />

<embed src="xdl.mp4" >

<a href="http://www.baidu.com" target_blank>链接地址</a>

<img src="images/tupian.jpg"  width="200" height="100" style="border:2px solid red" alt="这是图片的描述"/>

//背景图片的设置
			body{
				background-color:black;
				background-image:url(./img/tit.png);
				background-repeat:no-repeat;  (repeat-x;repeat-y)
				background-attachment:fixed;  (scrool)
			}
			.di{
				width:70;
				height:25;
				background-image:url(./img/bg.gif);
				background-repeat:no-repeat;
				background-position:0 -218px;
			}


<a href="http://www.baidu.com" target_blank>
	<img src="" />
</a>




			<p></P>中字体设置:
       
<p align=center style="color:blue;font:italic bold 80 宋体"></p>
	//font简写时，至少要有 size 和family 两项，少这两项无法简写！！！
	//在p中的<a>连接，<a>也可以设置style, 但align=center要写在<p>中或在两边加上<center>




<tr></tr>表格中字体设置：
<table width=500 border=1 align=center>
<tr align=center style="color:blue;font:italic bold 50 宋体">
<td style="color:red;font-size:20">ccc</td><td>aaa</td><td>aaa</td><td>bbb</td></tr></table>


可以使用函数unset()释放指定的变量，isset()函数检测变量是否设置，empty()函数检查一个变量是否为空；



数组和几种遍历形式：
<?php
echo "<br/>";//一;foreach索引遍历的显示方式
	$a =array(1,3,5,6,7,8);
	foreach($a as $k=>$v){
		echo $k." => ".$v."\n";	
	}

echo "<br/>";
	$b = array("a"=> 1,"b"=> 2,"c" =>3);
	foreach($b as $k => $v){
		echo $k." => ".$v."\n";
	}	
echo "<br/>"; //二：list+each遍历关联数组 每输出一次变换一次的示例。
	$c = array("aa"=>11,"bb"=>22,"cc"=>33);
	echo '	$c = array("aa"=>11,"bb"=>22,"cc"=>33);'."<br/>";
	list($k,$v)=each($c);
	list($k,$v)=each($c);
	list($k,$v)=each($c);
		echo $k." => ".$v;

echo "<br/>";//三：while+list+each组合遍历关联数组,用a=b的转等的方式显示
 	$d = array("aaa"=>111,"bbb"=>222,"ccc"=>333);
	while(list($k,$v)=each($d)){
		echo $k." => ".$v."\n";
	}

echo "<br/>"; //四：while+list+each组合遍历关联数组，用[0][1]方式和[key][value]方式显示
	$e = array("aaaa"=>1111,"bbbb"=>2222,"cccc"=>3333);
	while($ee=each($e)){
		echo $ee[0]." => ".$ee[1]."<br/>";
	}
?>




	post 和get 的传值示例
	request 用来接收 post 和get 的数据

<?php
	if(isset($_GET['sub'])){ 			 //可以把GET改成POST
	echo "姓名：".$_GET['name']."<br/>";		 //可以把GET改成POST
	echo "年龄：".$_GET['age']."<br/>";		 //可以把GET改成POST
	echo "性别：".$_GET['sex'];			 //可以把GET改成POST
	}
?>
<html>
	<head>
		<title>one</title>
		<meta http-equiv="content-type" content="text/html;	charset=gb2312" />
	<head>
	<body>
		<form action="" method="get">			 //可以把GET改成POST
		姓名	<input type="text" name="name" /><br/>
		年龄	<input type="text" name="age" /><br/>
		性别	<input type="radio" name="sex" value="男">男
			<input type="radio" name="sex" value="女">女<br/>
			<input type="submit" name="sub" value="提交" />
		</form>
	</body>
</html>






字体简易设置的排列顺序：font[<字体风格>|<字体变形>|<字体粗细>|<字体大小>|<行高>|<字体族科>]
p{font:italic bold 12pt/14pt Times.scrif}
说明：p标签中的字体为斜体加粗,字体大小为12点，行高为14点,字体为Times,无效时用scrif.
<p style="font-size:80;color:red;font-style:italic;font-weight:bold;line-height:2;background-color:#ccc;font-family:黑体">aaaaa</P>
	     大小        颜色         风格             粗细              行高            背景色		  字体族科


简写：background:#fff url(bg.g ) no-repeat fixed left top;
等效于：
background-color:#fff;
background-image:url(bg.gif);
background-repeat:no-repeat;
background-attachment:fixed;
background-position:left top;

顺序：background-color | background-image | background-repeat | background-attachment | background-position
margin & padding



一:表格标签属性
二:表单form标签属性：





一:表格标签属性
	table标签属性：
		width : 代表表格的宽度。
		height : 代表表格的高度。
		border : 代表表格的边框
		cellspacing:格与格之间的距离，
		cellpadding;内容与格边缘的距离。
	th,td标签属性：
		width 与 height : 代表宽度与高度。
		colspan : 合并单元列。	
		rowspan : 合并单元行。
		align   : 水平对齐方式，left,right,center,justify.
		valign  : 垂直对齐方式，top,middle,bottom,baseline(基线对齐).
		
	tr标签属性：
		align   : 水平对齐方式，left,right,center,justify.
		valign  : 垂直对齐方式，top,middle,bottom,baseline(基线对齐).

<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		<table border="1" bordercolor=blue width="800" >
			<tr>
				<th>姓名</th><th>张三</th><th>男</th>
			</tr>
			<tr align="center">  //此行内容居中。
				<td colspan="2">姓名</td><td>男</td>   //colspan横向合并2个单元格，
			</tr>
			<tr align="right">    //此行内容右对齐
				<td >姓名</td><td>王五</td><td rowspan="2">男</td>//纵向合并两个单元格
			</tr>
			<tr>     //默认对齐方式是左对齐
				<td>姓名</td><td>麻六</td>
			</tr>
		</table>
	</body>
</html>

----------------------------------------------------------------------------------------------------------


二:表单form标签属性：
	常用属性：
		action-- 浏览者输入的数据被传送到的地方，如一个PHP页面（dofm.php）
		method -- 数据传送的方法
		get-- 此方法传递数据量少，但是传递的信息显示在网址上。
		post-- 此方式传送信息量多，而且不会把传递信息显示在网上。
	input 标签---代表HTML表单的单行输入域
	input标签是单独出现的,<input />
		常用属性：
		type--代表一个输入域的显示方式（分为输入型，选择型，点击型）
		type属性--代表HTML表单，单行输入域（框）的表现方式。
			text--文字输入域（输入型）
			password-- 也是文字输入域，但是输入的文字以密码符号‘*’显示（输入型）
			file-- 可以输入一个文件路径（输入型）
			checkbox-- 复选框，可以选择零个或多个（选择型）
			select:option--多个选项选一个。
			radio-- 单选框，只可以选择一个而且必须选择一个（选择型）
			hidden-- 代表隐藏域，可以传送一些隐藏的信息到服务器
			button-- 按钮（点击型）
			image-- 使用图片来显示按钮，使用src属性指定图像的位置（就像img标签的src属性）(点击型)
			submit-- 提交按钮，表单填写完毕可以提交，把信息传送到服务器，可以使用value属性来显示按钮上的文字（点击型）
			reset-- 重置按钮，可以把表单中的信息清空（点击型）

			label--让一个属性区域成为一个整体扩大点击范围如：
				<label for="ss"><input id="ss" type='checkbox' onclick='sall(this)' />全选</label>

		name--此表单项名称
		value-- 输入域的值
		size-- 输入域的长度
		pattern --文本域限制：如
<input type='text' pattern="[0-9,a-z]{1,9}" />   可以使用0到9,a到z 的字符，可以1到9位数间。   


	例：
		<form action="" method="post">  
			<input type="text" name="name" /><br/>
			<input type="password" name="psd" /><br />
			<input type="radio" name="sex" />男
			<input type="radio" name="sex" />女<br />
			<select name="sel">
				<option value="1">1</option>
				<option value="2">2</option>
				<option value="3">3</option>
				<option value="4">4</option>
			</select><br />
			<input type="checkbox" name="aihao[]" value="book" />看书
			<input type="checkbox" name="aihao[]" value="net" />上网
			<input type="checkbox" name="aihao[]" value="sport" />运动
			<input type="checkbox" name="aihao[]" value="girl" />泡妞<br />
			<td>自我评价</td><br />
			<td>
				<textarea name="jieshao" cols="40" rows="4">
				</textarea>
			</td><br />
			<input type="submit" name="sub" value="提交" />
			<input type="reset" name="reset" value="重置" />
		</form>












html和htm的区别
1.如果一个网站同时拥有index.html和index.htm两个文件时，默认情况下，优先运行.html
2.htm后缀是为了兼容以前的dos 系统8.3的命名规范。


HTML格式：
<html>
	<head>
		<title>我的主页</a>
	</head>
	<body>
		<a href = "www.baidu.com">我的主页内容</a>
	</body>
</html>


有关搜索引擎关注度的：
<meta name="keywords" content="PHP培训|LAMP培训|就业培训">
	//网站的关键字内容，  搜索引擎会对它很关注的。
<meta name="description" content="LAMP兄弟连致力于PHP培训">
	//网站的描述，介绍网站是干什么的，这个也是搜索引擎比较关注的。
<img src="./images/11.jpg" width="300" height="100" alt="这是图片的描述"/>
	//其中的alt 是对图片的描述，它可以增加搜索引擎的关注度。
DIV+CSS模式提高搜索引擎对网页的索引效率。






 		 HTML 文档头部元素<head>
	头head 包含了当前文档的一些信息，例如标题信息，metaw信息等，正常情况下信息是不会显示在HTML文档中的.
	head元素包含的常用标签：
		title标签 -- 代表HTML文档的标题。
		meta标签  -- 用于定义文件信息的名称，内容等信息。
			比如说网站的关键字，描述,定义字符集编码等，想要搜索引擎收录的更好，排名更好，这块是必须要写的.
		link标签  -- 当在文档中声明使用外接资源(如CSS)JF 使用此标签
		style标签 -- 在文档中声明样式时使用此标签
		script标签 -- 在文档中使用javaScript脚本 

equiv 当量
content 内容
description 描述
stylesheet 样式表
rel 关系
margin  边缘；
padding 填充；
background 背景
例：
<head>
	<title>LAMP兄弟连</title>
	<meta http-equiv="Content-Type" content="text/html;	charset=gb2312"/>
		//定义字符集编码的，告诉浏览器本档所使用的编码格式
//字符编码虽设置的和网页的一样，但还是有乱码的解决办法！在将文件另存为时，最下方有一个Encoding选项，不要选择ANSI
因为，NASI在不同的系统中的字符集是不一样的，所以要指定选择，UTF-I或某一种字符集，并将文件保存。就可以解决乱码问题了。
	<meta name="keywords" content="PHP培训|LAMP培训|就业培训"/>
		//网站的关键字内容，  搜索引擎会对它很关注的。
	<meta name="description" content="LAMP兄弟连致力于PHP培训"/>
		//网站的描述，介绍网站是干什么的，这个也是搜索引擎比较关注的。
	//-----选项卡上标题的图标
	<link rel="short icon" type="image/x-icon" href="img/a.ico"/>
	<link type="text/css" rel="stylesheet" href="./css/index.css"/>
		//连接外部的CSS样式，
	<style>
		//这里边可以嵌入样式
		body{
			margin:0px;
			padding:0px;
			background:red;
			color:green;
		}
	</style>
</head>









			格式标签：
<br /> ; 换行标签，完成文字的紧凑显示，可以使用连续多个<br>标签来换行
<p>  : 段落标签，里面可以加入文字，列表，表格等，可以<p></p>或<p /p>使用
<center> : 居中对齐标签，使段落或文字相对于上一层标记居中显示
<ul> : 代表HTML无序列表，里面每一列表项使用<li>标签定义。
<ol> : 代表HTML有序列表，里面每一列表项使用<li>标签定义
<li> : 代表HTML列表项目，每个列表使用一对<li></li>标记。
<hr> ; 水平分割线标签，用于段落与段落之间的分割。
<span>: 小型段落，标记，它不会换行，且当有背景色时，会根据内容调整，不会占据一整行，
	<hr 

<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		11111111111<br/><!--br / 换行标签-->
		2222222222<hr/><!--hr /一水平线标签-->
		<p>33333333</p>
		<p>4444444</p>  <!--p 段落标签-->
		<hr />  <!--独体的,用水平线隔开上下的内容-->
		<ul><!--ul是无序列表项，里面的每一项用<li></li>来完成-->
			<li>555555555</li>
			<li>555555555</li>
			<li>555555555</li>
			<li>555555555</li>
		</ul>
		<hr/>
		<ol><!--ol是有序列表项，里面的每一项用<li></li>来完成-->
			<li>555555555</li>
			<li>555555555</li>
			<li>555555555</li>
			<li>555555555</li>
		</ol>
		<hr/>
			111111111111111
		<center>111111111111111</center>
	</body>
</html>










			文本标签
<hn> : 标题字标签，n 为1-6,定义六级标题，而且会自动换行插入一个空行.
<b>  : 粗体字标签。
<i>  : 斜体字标签。
<u>  ; 下划线字体标签。
<s>  ; 删除线
   //以上是常用的必须记住。
<sub>; 文字下标字体标签。
<sup>; 文字上标字体标签。
<font>；字体标签，可以通过标签的属性指定文字的大小，颜色及字体等信息。
<tt> :打字机文字。
<cite> :用于引证，举例，通常为斜体字。
<em>   :表示强调，通常为斜体字。
<strong>; 表示强调,通常为斜体字。
<small> : 小型字体标签。
<big>   :大型字体标签。
<blink> :字体闪烁，需要浏览器支持！


bold  粗体
italic 斜体
underline 下划线



<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		<center><i>><u><b>1111111111111111111</b></u></i></center>
		<h1>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h1>
		<h2>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h2>
		<h3>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h3>		
		<h4>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h4>
		<h5>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h5>
		<h6>这标题共有六级,它会自动换行，每个网页中只能存在一个h1</h6>
		<hr/>
		
	</body>
</html>


背景色彩和文字色彩：
<body bgcolo=# text=# link=# alink=# vlimk=#>
bgcolor -- 背景色彩；
text -- 非可链接文字的色彩；
link -- 可链接文字的色采；
alink -- 正被点击的可链接文字色彩；
vlink -- 已经点击（访问）过的可链接文字色彩;






			图片的属性
alt: 对图片的描述，可以增加搜索引擎的观注度。
border : 设置图片的边框。


<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		<img src="./images/111.jpg" width="300" />
		<img src="./images/111.jpg" width="300" height="100" alt="图片描述" border="20"/> <!--插入图片并设置图片大小,当只高和宽只改变一个元素时，另一个元素会跟着自动变化，而两个同时设置时才会随着设置而变化,,border 是图片的边框-->
	</body>
</html>





			超链接（外部网址连接）
<a href="网址"></a>

target="_blank"  ： 在新窗口打开；
<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		<a href="http://www.baidu.com" target="_blank">百度连接</a>
	</body>
</html>





			表格标签常见属性：

table：是表格的意思。


table 标签属性；
width -- 代表表格的宽度，
height -- 代表表格的高度。
border --用来设置表格边框尺寸大小。CSS来实现
cellspacing -- 代表表格边框与表格内容填充的距离，也是内容填充之间的距离，CSS来实现。
cellpadding -- 代表内容填充的宽度，CSS来实现。


th -- 标题栏。//  标题一行用th,标题会自动居中，内容就要用td了
<td></td>定义列。
<tr></tr>定义行.   行  row
align="center"  //把这行的内容显示形式为居中。
align="right"  //右对齐，
align 默认的是左对齐；
width 与height 代表宽度与高度。
colspan -- 一行跨越多行
rowspan -- 一列跨越多列
align -- 代表队水平对齐方式--left，左对齐,| center，居中|right右对齐|justify ，两端对齐，CSS来实现
valign -- 代表垂直对齐方式 --top,顶部对齐| middle,中部对剂| bottom，下部对齐|baseline,基线对齐,CSS来实现。


     表格的定义如下
<html>
	<head>
		<title>我的主页</title>
	</head>
	<body>
		<table border="1" width="800">
			<tr>
				<th>姓名</th><th>张三</th><th>男</th>
			</tr>
			<tr align="center">  //此行内容居中。
				<td colspan="2">姓名</td><td>男</td>   //colspan横向合并2个单元格，
			</tr>
			<tr align="right">    //此行内容右对齐
				<td >姓名</td><td>王五</td><td rowspan="2">男</td>//纵向合并两个单元格
			</tr>
			<tr>     //默认对齐方式是左对齐
				<td>姓名</td><td>麻六</td>
			</tr>
		</table>
	</body>
</html>


















			css(层叠样式表)语法：
提示：可经通过简单的更改CSS文件，改变网页的整体表现形式，可以减少我们的工作量，所以它是一个网页设计人员的必修课。
一，CSS 是用于布局和美化网页的，
二，CSS是Cascading Style Sheets的英文缩写，可以直接由浏览器执行（属于浏览器解释型评言）
三，CSS文件是一个文本文件，它包含了一些CSS标记，CSS文件必须使用.CSS为文件后缀名。
四，CSS是大小写不敏感的，CSS与css是一样的。
五，CSS是由W3C的CSS工作组产生和维护的。



1,CSS简介
2，CSS规则的组
3，在HTML文档中放置CSS的几种方式
4，CSS选择器
5，CSS常见样式属性和值，
6，DIV+CSS对页面布局的优势。
7，DIV和span 
8，W3C盒子模型
9，和页面布局有关的CSS属性
10，盒子区块框的定位
11，使用盒子模型的浮动布局
12，DIV+CSS的兼容性问题




				CSS规则的组成
		一，CSS语法；
		二，长度单位
		三，颜色单位

一，CSS基本语法：
	CSS定义分别由：选择符，属性，属性取值组成。		
	格式：selector{property:value}
		>选择符可以是HTML中的标记名称，
		>属性和值之间用冒号分开，多个属性之间用分号分开。	
		>CSS是大小写不敏感的，在CSS语法中推荐使用小写
		如：body{color:red} 设置了页面为红色的文字。
		例：p{text-align:center; color:red; font-family:宋体}





	一：样式规则：设置选择器<p>段落的属性
<html>
	<head>
		<title>我的主页</title>
		<style type="text/css">
			//这里定义了<p>的段落属性。包括颜色，字体，大小！在本页面中所有的P标签都应用了此样式
			p{font-family:黑体;color:blue;font-size:20px;} //属性之间用 ; 隔开
		    // p是选择器	
		</style>
	</head>
	<body>
		<h2>登黄鹤楼</h2>
		<p>白日依山尽</p>
		<p>白日依山尽</p>
		<p>白日依山尽</p>
		<p>白日依山尽</p>	
	</body>
</html>





		二，长度单位
	在CSS样式表中可以使用如下长度单位；
		相对长度单位：
		PX 像素（pixcl）----例 div{font-size:12px;}  这个大小是固定不会变的
		% 百分比        ----例 div{font-size:80%} 这个大小是会随着窗口的变化而改变大小的。

相对长度单位:设置水平线 <hr>在主体中的显示形式
<html>
	<head>
		<title>我的主页</title>
		<style>
			hr{width:50%;}//百分比的形式会随着窗口而改变大小！而hr(width=500px;)是固定了大小，不会随窗口改变
		</style>
	</head>
	<body>
		<hr>
	</body>
</html>










		颜色单位
调节颜色的形式：
一：
#rrggbb 如： #ffcc00
二；
rgb(x,x,x)  如：rgb(255,223,0)
三：
rgb(x%,x%,x%)  如rgb(100%,23%,0)








		在HTML文档中放置CSS的几种方式
		一，内联样式表:
		二，内嵌样式表
		三，外部链接样式表

一，内联样式表:
	直接在p等内容里写入style样式，如下
		<p style=font-size:50px;color:#0f0>11111111111</P>


	CSS的引用，适用就近原则，哪个近就运用哪
	
二：内嵌样式表
	即内部引用,就是在head部设置好一个style属性,主体内的所有p标签属性都应用这个样式。
<html>	
	<head>	
		<title>我的主页</title>
		<style type=text/css>	
			p{font-family:黑体;font-size:30px;color:#f00}
		</style>
	</head>
	<body>
 		<p>2222222222</p> 	
	</body>
</html>
三：外部链接样式表；
	使用外部CSS文件，对于内部引用和内联引用来说外引是高效的，是节省宽带的，是w3c推荐使用的。
	外引需要link标签引用CSS。
例：
同文件夹下另一新文件11.css 
			内容为：p{color:#00f;font-size:100px;}
<html>	
	<head>	
		<title>我的主页</title>
			<link type="text/css" rel="stylesheet" href="./11.css" />
		<style type=text/css>	
		</style>
	</head>
	<body>
 		<p>2222222222</p> 	
	</body>
</html>

多重样式表的叠加：
	如果在同一个选择器上使用几个不同的样式表时，这个属性值将会叠加几个样式表。遇到冲突的地方会以最
后定义的为准；
	注意；依照后定义的优先，所以优先级最高的是内联样式，内联样式表高于导入外部样式表，链入
的外部样式表和内部样式表之间是最后定义的优先级高。











				CSS选择器（选择符）

			一，HTML选择器(使用HTML中的修饰符如：hr tr,p 等等)
			二，类选择符
			三，TD选择符

二：类选择符：
CSS类选择符--匹配文档中元素E的class属性的属性值为classname的元素
	>语法： 标记名.类名{属性：值}或  .类名{属性：值}
	>类选择符名称的定义方式是：点符号+类名  如：
					p.dark-row{  }或 .dark-row{ } p.note{ }或.note{}
	>类选择符的定义需要有，符号(.符号标明是类选择符),但是HTML文档中的标签的class属性名不能出现.符号.				 
		p.dark-now{background:#EAEAEA}---设置p标签中class属性为dark-now
	 	.note{font-size:small}----为note的类可以被用于任何元素

		<p class="dark-row"></p>
		<span class=""dark-row></p>
		<span class="note"></span>
		<div class="note"></div>


类选择符的应用及单行隔行换色！
<html>
	<head>
		<title>我的主页</title>
		<style>
			.aaa{color:#00f}
			.bbb{background:#ccc}
			.ccc{font-size:80px}
		</style>
	</head>
	<boyd>
		<p class="aaa">aaaaaaaaaaaaaaaa</p>
		<p class="bbb">aaaaaaaaaaaaaaaa</p>
		<p class="ccc">aaaaaaaaaaaaaaaa</p>
		<p class="bbb">aaaaaaaaaaaaaaaa</p>
	</boyd>
</html>





三，ID选择符(和类选择相似)
CSS ID选择符--匹配文档中元素E的id属性的属性值为idname的元素。
	>语法： ID名称{属性：值}
	>ID选择符名称的定义方式是，#符号，英文“pound”，后加ID名称 idname
	>ID选择符的定义需要有#号（#号标明这是ID选择符）.但是HTML文档中的标签的id属性名不能出现#号.
	>id属性的特殊之处在于，一个文档中只能有一个元素使用一个ID选择符，（与CLSS正好相反）id属性可以用来单一地标识一个元素.
	
	#main{text-indent3em}		ID名称main前加上一个#号
	<p id="main">文本缩进3em</p>	在html的p标签中指定id属性的mian

<html>
	<head>
		<title>我的主页</title>
		<style>
			#aaa{color:#00f}
			#bbb{background:#ccc}
			#ccc{font-size:80px}
		</style>
	</head>
	<boyd>
		<p id="bbb">aaaaaaaaaaaaaaaa</p>
		<p id="ccc">aaaaaaaaaaaaaaaa</p>
		<p id="aaa">aaaaaaaaaaaaaaaa</p>
		<p id="bbb">aaaaaaaaaaaaaaaa</p>
	</boyd>
</html>
			

			内联，内嵌总结
<html>
	<head>
		<title>我的主页</title>
		<style>
			#abc{color:#00f;font-size:80px;background:#ccc}
			.def{color:#0f0;font-size:40;background:#bbb}
			p{color:red;font-size:30;background:#ddd}
		</style>
	</head>
	<boyd>
		<p id="abc">111111111111</p>
		<p class="def">111111111111</p>
		<p style="color:blue;font-size:60;background:#ccc">111111111111</p>
		<p>111111111111</p>
	</boyd>
</html>








			常见的样式属性和值：
一：字体与颜色：
二：背景属性：
三：文本属性：
四：边框属性；
五：区块属性：



一，字体与颜色：
字体简易设置的排列顺序：font[<字体风格>|<字体变形>|<字体粗细>|<字体大小>|<行高>|<字体族科>]

	CSS中的样式属性比较多，经常使用的属性可以分为这么几类，字体，文本，背景，位置，边框，以及其它一些样式
属性，每个类中的属性都可以单独使用，如果同一类中多个属性在一起使用，还可将它们合为一行解决。
	如：font[<字体风格>|<字体变形>|<字体粗细>|<字体大小>|<行高>|<字体族科>]
	例: p{font:italic bold 12pt/14pt Times.scrif}
	说明：p标签中的字体为斜体加粗,字体大小为12点，行高为14点,字体为Times,无效时用scrif.

font___简写属性；作用是把所有针对字体的属性设置在一个声明中。
font-family : 设置字体系列，比如times,serif
font-size : 设置字体的尺寸，可以使用绝对大小，相对大小，长度和百分比。
font-style : 设置字体风格，normal（标准），italic(斜体), oblique（倾斜）
font-weihght; 设置字体的粗细.

<html>
	<head>
		<title>我的主页</title>
		<style>
			.fontset{color:#00f;font-weight:bold;font-style:italic;font-size:30px;font-family:黑体}
			p{font:italic bold 30 黑体;color:red}
		</style>
	</head>
	<boyd>
		<p class="fontset">111111111111</p>
		<p>111111111111</p>
	</boyd>
</html>










背景属性：
CSS中常用的控制背景的属性
background      	简写属性，作用是将背景属性设置在一个声明中；
background-color	设置元素的背景颜色。transparent(透明色)
background-image	把图像设置为背景。none(无)
background-repeat	设置背景图像是否及如何重复 repeat,repeat-x（横）,repeat-y(竖),no-repeat（不重复）
background-attachment	背景图像是否固定或者随着页面的其余部分滚动，scroll滚动，fixed固定
background-position	背景图像的起始位置，横向（left,center,right）纵向（top,center,bottom）,百分比和长度。TT

background-color	规定要使用的背景颜色。	1
background-position	规定背景图像的位置。	1
background-size	规定背景图片的尺寸。	3
background-repeat	规定如何重复背景图像。	1
background-origin	规定背景图片的定位区域。	3
background-clip	规定背景的绘制区域。	3
background-attachment	规定背景图像是否固定或者随着页面的其余部分滚动。	1
background-image	规定要使用的背景图像。	1
inherit	规定应该从父元素继承 background 属性的设置。


<html>
	<head>
		<title>我的主页</title>
		<style>
			p{font:italic bold 100 黑体;color:red}
			body{
				background-color:black;
				background-image:url(./img/tit.png);
				background-repeat:no-repeat;
				background-attachment:fixed
			}
		</style>
	</head>
	<body>
		<p class="fontset">111111111111</p>				<p>1</p><br/><hr><p>1</p><br/><hr><p>1</p><br/><hr><p>1</p><br/>
	</body>
</html>


background-position	背景图像的起始位置，横向（left,center,right）纵向（top,center,bottom）,百分比和长度。TT
<html>
	<head>
		<title>我的主页</title>
		<style>
			p{font:italic bold 50 黑体;color:red}
			.di{
				width:70;
				height:25;
				background-image:url(./img/bg.gif);
				background-repeat:no-repeat;
				background-position:0 -218px;
			}	
			.di2{
				width:70;
				height:25;
				background:url(./img/bg.gif) no-repeat 0 -218;

			}		
		</style>
	</head>
	<boyd>
		<div class="di">1</div>
		<div class="di2">2</div>
	</boyd>
</html>














					文本属性
CSS文本属性主要包括文字修饰，文字排列，文字缩进，行高，以及文字大小写等。

text-decoration :向文本添加修饰。underline(下划线),overline(上划线),line-through（删除线）,blink(闪烁)默认使用无

thext-align : 对齐元素中的文本。letf,right,center,或justify

text-indent : 缩进元素中文本的首行，可以为一个长度或百分比

line-height ; 设置行高。

color : 设置文本颜色。

<html>
	<head>
		<title>我的主页</title>
		<style>
			.test{
				font-size:50;			
				background:#ccc;		
				line-height:5;			
				color:yellow;			
				text-indent:10%;		
				text-decoration:underline;	
				text-decoration:overline;	
				text-decoration:line-through; 
				text-align:right;            
			}
		</style>
	</head>
	<boyd>
		<div class="test">AAAAAAAAAA</dir>		
	</boyd>
</html>















                          边框属性：
一，每个内容或元素外面都可以有一个边框。
二，边框分上框（TOP），下边框（bottom）,左边框(left)，右边框(right)。
三，每种边框有颜色（color），样式(style),宽度（width）三种属性。
四，如果上下左右的边框表现不一样，可以分别定义上下左右的边框。如果一样可以统一使用border属性定义。

border : 简写属性，用于把针对四个边框属性设置在一个声明中。
border-style : 用于设置元素所有边框的样式，或者单独地为各边设置边框样式。
border-width : 简写属性，用于为元素的所有边框设置宽度，或者单独地为各边边框设置宽度。
border-color : 简写属性，设置元素的所有边框中可见部分的颜色，或为4个边分别设置颜色。
border-bottom : 简写属性，用于把下边框的所有属性设置到一个声明中。
border-left : 简写属性，用于把左边框的所有属性设置到一个声明中。
border-right : 简写属性，用于把右边框的所有属性设置到一个声明中。
border-top : 简写属性，用于把上边框的所有属性设置到一个声明中。
border-bottom-color ; 设置元素的下边框的颜色。
border-bottom-style : 设置元素的下边框的样式。
border-bottom-width : 设置元素的下边框的宽度。
border-left-color : 设置元素的左边框的颜色。
border-left-style : 设置元素的左边框的样式。
border-left-width : 设置元素的左边框的宽度。
border-right-color :设置元素的右边框的颜色。
border-right-style :设置元素的右边框的样式。
border-right-width:设置元素的右边框的宽度。
border-top-color :设置元素的上边框的颜色。
border-top-style :设置元素的上边框的样式。
border-top-width :设置元素的上边框的宽度。

border-style的取值；
none: 无样式  ， hidden:除了同表格的边框发生冲突的时候,其它同none
dotted :点划线 , dashed:虚线 , solid:实线 , double:双线 , grooove:槽状
ridge:脊状 ， groove:相反 , inset:凹陷 , outset：凸出 ，  


<html>
	<head>
		<title>我的主页</title>
		<style>
			.test{
				font-size:50;			
				background:#ccc;		
				line-height:5;			
				color:yellow;			
				text-indent:10%;		
				text-decoration:underline;	
				text-decoration:overline;	
				text-decoration:line-through; 
				text-align:right;    
				border-right-style:solid;
				border-color:blue;
				border-width:10px;        
			}
			.ik{
				font-size:50;
				line-height:3;
				color:yellow;
				background:#ccc;
				text-indent:10%;
				text-align:center;
				text-decoration:line-through;
				border-style:solid;
				border-color:blue;
				border-width:10;
				border-top-style:inset;
				border-top-width:50;
				border-top-style:outset;
				border-top-style:ridge;
				border-top-style:groove;
				border-top-style:double;
				border-top-style:dashed;
				border-top-style:dotted;
				border-top-style:hidden;
			}
		</style>
	</head>
	<boyd>
		<div class="ik">AAAAAAAAAA</dir>		
	</boyd>
</html>















				DIV+CSS对页面布局的优势：
	采用DIV+CSS模式的网站具有以下优势：
		》表现和内容相分离，
		》代码简洁，提高页面浏览速度。
		》易于维护和改版。
		》提高搜索引擎对网页的索引效率。








			“无意义” 的HTML元素（标签）DIV和span
		div属于独立元素，自己占用一行，，，，
		span属于行中的元素的一部分，可以和其它内容和平相处，，，它不独占一行。
	一，HTML只是赋予内容的手段，大部分HTML标签都有其意义（例如，标签p创建段落，h1标签创建标题等等）的。然而div和span标签
似乎没有任何内容上的意义，听起来就像一个泡沫做成的锤子一样无用。但实际上，与CSS结合起来后，它们被用的十分广泛。你所需要
记住的是span和div是”无意义“的标签。它们的存在纯粹是应用样式，所以当样式表失败时这就没有任何的作用。
	
	二。它们被用来组合成一大块的HTML代码并赋予一定的信息，大部分用类属性class和标识属性id与元素联系起来。span和div的不
同之处在于span是内联的，用在一小块的内联HTML中。而div(division)元素是块级的（简单地说，它等同于其前后有断行）,用于组合一
大块的代码，为HTML文档内大块的内容提供结构和背景的元素，可以包含段落，标题，表格甚至其它部分，这使div便于建立不同集成的类。

	三，div的起始标签和结束标签之间的所有内容都是用来构成这个块的，其中所包含元素的特性由div标签的属性一类控制，或是通过使用样式表格式化这个块来进行控制。















			声明盒子模型的CSS属性

margin: xx xx xx xx;
如果提供全部四个数值，将按上下左右顺序作用于四边，如果说只提供一个，将用于全部的四边，如果提供两个，第一个用于
上和下，第二个用于左和右，如果提供三个，第一个用于上，第二个用于左右，第三个用于下。

margin   : 是定义区块外边界与上级元素距离的属性，用1到4个值来设置元素的边界，每个值都是长度，百分比或者auto,百分比
	   值参考上级元素的宽度，允许使用负边界值。还可以使用margin-top/margin-right/margin-bottom/margin-left.

padding  : 用于设置区域的内边距属性，是边框和元素内容之间的间隔距离。可以使用：padding-top/padding-bottom/
	   paddin-right/ padding-left

border  : 边框属性用于设置一个元素边框风格，边框颜色，可以一起设置四边的边框，也可对上边框，下边框，左边框，右边框
	  进行单独设置。

width   : 层的宽度，可以为一个长度或“auto”值，不允许使用负值。

height  : 层的高度，可以为一个长度或“auto”值，不允许使用负值。


盒子模型：

<html>
	<head>
		<title>我的主页</title>
		<style>
			.box1{
				width:200px;
				height:200px;
				background:#ccc;
				border:5px solid blue;
				margin-top:80px;
				margin-left:30px;
				padding-top:10px;
				padding-left:20px;
			}
		</style>
	</hede>
	<body>
		
		<div class="box1">
			AAAAAAAAAAAA
		</div>

	</body>
</html>















				和页面布局有关的CSS属性

top  :  层距离顶点纵坐标的距离

left : 层距离顶点横坐标的距离

text-align : 横向排列，可以使用left(左对齐),right (右对齐)和center居中。

line-height : 指定行高，内容都是在行的中间，所以可以使用这个属性设置内容垂直居中，这个属性接受一个控制文本基线之间
	    的间隔值，可以是数字，表示字体大小乘以该数所得，也可以使用百分比。


padding : 用于设置区块的内边距属性，是边框和元素内容之间的间隔距离，与margin属性相反，但使用的是相同属性值。是上补
	  白padding-top,下补白padding-bottom,左补白paddig-left,右补白padding-right.属性的缩写

float  :  设置区块漂浮属性，允许网页制作者将文本环绕在一个元素的周围，可以使用左漂浮left值，右漂浮right值.

clear  :  清除属性指定一个元素是否允许有元素漂浮在它的旁边。值left移动元素到在其左边的漂浮的元素的下面，同样的值	
	  right移动至其右边的漂浮的元素下面。其他的还有缺省的none值，和移动元素到其两边的漂浮的元素的下面的both值。



display:-webkit-box;
-webkit-box-pack:center;  设置盒子中内容的左右位置  start 左 end 右
-webkit-box-align:center; 设置例子中内容的上下位置  start 上 end 下



			


				









				DIV+CSS的兼容性问题；
		1，不同浏览器解释盒子模型的差异。
		2，设置浏览器去遵循W3C标准。

在文档顶部加写两句代码可以解决90%的问题。
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


先初始化一下，外边距和内边距，然后再设置相应的内外边距。这样的处理效果会更好！
<style>
	*{
		margin:0;
		padding:0;
	}
</style>


			
<html>
	<head>
		<title>我的主页</title>
		<style>
			.box1{
				float:left;
				width:400px;
				height:300px;
				background:#ccc;
				border:5px solid blue;
				margin-top:30px;
				margin-left:30px;
				padding-top:10px;
				padding-left:20px;
			}
			.box2{
				clear:left;
				float:left;
				width:400px;
				height:200px;
				background:#ccc;
				border:5px solid blue;
				margin-top:30px;
				margin-left:30px;
				padding-top:10px;
				padding-left:20px;
			}
			.box3{
				float:left;	
				width:400px;
				height:200px;
				background:#ccc;
				border:5px solid blue;
				margin-top:30px;
				margin-left:30px;
				padding-top:10px;
				padding-left:20px;
			}
		</style>
	</hede>
	<body>

		<div class="box1">aaaaaaaa</div>
		<div class="box2">cccccccc</div>
		<div class="box3">bbbbbbbb</div>

	</body>
</html>



































PHP的输出方式有：echo      var_dump 








			PHP变量的声明：
	
	$a=100;  		
	$b="string";
	$c=true;    	//声明一个变量c,赋予布尔值true;
	$d=99.99;
	$key=$a;
	$a=$b=$c=$d="value"; //同时声明多个变量，并赋予相同的值。
可以使用函数unset()释放指定的变量，isset()函数检测变量是否设置，empty()函数检查一个变量是否为空；

		$a =111;
		$b = 'bbb';
		$c = '_123';
		unset($a);  //释放变量$a  释放后再检查就是false了
		echo "<br/>";
		echo $a;
		echo "<br/>";
		echo $b;
		echo "<br/>";
		echo $c;
		echo "<br/>";
		$f= "";
		echo isset($c); //echo检查变量是否设置时不用引号，但以0和1为显示结果。
		echo "<br/>";
		var_dump(isset($c));//用var_dump 检查时是以true ,false为显示结果。
		echo "<br/>";
		var_dump(empty($f));








单引号和双引号的区别： 引引号不解析变量，，双引号会解析变量。

示例：
$beer='Heineken';
echo "$beer's taste is great";    //输出： heineken's taste is great    会把变量$beer解析

echo "He drank some $deers";  	  //输出： He drank some	没有$beers这个变量

echo "He drank some $(beer)s";    //输出： He drank some Heinekes  


echo "He drank some {$beer}s";	  //使用{}包含起来，就可以将变量分离出来。最后这两种都可以
























					变量的命名
	变量名与PHP中其它的标签一样遵循相同的规则。一个有效的变量名由字母下划线开头，后面跟上任意数量的
字母，数字，或者下划线。	
	变量的名称是对大小写敏感的。
	
	但内置结构和关键字以及用户自定义的类名和函数名都是不区分大小写的
		如：echo,while,function等.
	
	echo "this is a test";
	Echo "this is a test";
		上面两行输出的是一样的。

	$name="tarzan";
	$Name="skygao";
		上面两个是不同的变量；







	echo $name.$Name; //输出： tarzenskygao    点“.”是把字符串相连的意思！
		$d = 'abc';
		$d2 = 'efg';
		$d3 = $d.$d2.'ddd';
		echo $d3;     //结果是: abcefgddd 就是把三个字符串连接起来

		$e = 'abc';
		$e .= 'fgk';  //这里相当于$e和fgk相连接，结果就是 abcfgk.
		echo $e; 









				比较运算符；
	===	全等于；两边值相等且类型相等返回true,否则返回false
	<>或！	不等于，两边值不等时返回true,否则返回false
	!== 	非全等于：两边值与类型都相同时返回false,否则true

			$a = 1;
			$b = '1';
			if($a==$b){	  // ==时结果是相等，因为值相同。
				echo "等";
			}else{
				echo "不等";  //  ===时结果是不等，因为类型不同
			}













			逻辑运算符：
and 或 &&   逻辑与:当两边操作数都为true时，返回true,否则返回false

or 或  ||   逻辑或: 当两边操作数都为false时，返回false,否则返回true

not 或!     逻辑非: 当操作数为true时返回false,否则返回true

xor    	    逻辑异或；当两边操作数只有一个为true时，返回true ,否则返回false.

























			PHP数据类型介绍；
数据类型：
PHP把持八种原始类型。
	》四种标题类型；
		布尔型：boolean
		整形 ：interger
		浮点型: float （浮点数，也作double）
		字符串：String
	》两种复合类型；
		数组： Array
		对象： object
	》最后是两种特殊类型；
		资源：Resource
		NULL
	



















                              数组介绍Array
	PHP中可以使用多种方式构建一个数组，在这里我们只用array()语言结构来新建一个array.
它接受一定数量用逗号分隔的Key => value 参数对。

	语法结构:
	array([key=>] value,.......)
	//key可以是integer或者string类型
	//value可以是任何值。

	<?php
		$arr = array(
			"foo" => "bar", 12 => true);
	?>

echo $arr;  //这样输出是不行的，它只会输出 Array.
echo "<br/>";
var_dump($arr);//array(3) { ["name"]=> string(4) "张三" ["sex"]=> string(2) "男" ["age"]=> int(18) }
















			PHP数组

<?php			
			//一：逐个并自定义下标
	$name[8]="zhnag";
	$name[1]="wang";
	$name[]="li";
	$name[]="zhao";
	$name1[5]="10";
			//二；逐个不定义下标
	$name1[]="12";
	$name1[]="13";
	$name1[]="14";

	var_dump ($name);
	echo "<br/>";
	var_dump ($name1);
			//三；以array形式自定义下标
	$name2 = Array(1=>11,2=>"33",3=>"ai",4=>"kf");
	echo "<br/>";
	var_dump($name2);
	echo "<br/>";
			//四，以array形式不定义下标
	$name3=array(11,"34",33,'34');
	var_dump($name3);
?>












--------------------------------------------------------------------------------------

一，frameset  窗口框架

<frameset cols ="30%, *">      //把一个窗口分成两部分，前部分占30%的宽度，其余给后部分。
<frame src = "b.html" scrolling="no"  noresize  frameborder="0" />
	     b-另一个网页  scrolling 滚动条  noresize 调整子窗口
<frame src ="c.html" />
</frameset>


	//当点击左侧的超链接时，改变右边窗口的内容：
//(a.html)
<frameset cols="30%",* ">
<frame name="frame1" src="b.html" noresize frameborder="0" />
<frame name="frame2" src="c.html" frameborder="0" />
</frameset>

//(b.html)
<body bgcolor="pink">
//target 表示我们点击后，目标指向谁！
<a href="zjl.html" target="frame2">周杰伦</a><br/>
<a href="qq.html" target="frame2">齐秦</a><br/>
</body>




frameset该页面中不能有其它任何元素，如body体数字，字符等！

tartget 有五个属性： 1,_blank:新窗口   1, _self：窗口	3,_parent: 父窗口	4, _top:整个浏览器窗口	
5, =“框架名称”  如上面的frame2例子


框架分割：
all.html
<frameset rows=" 20% , * ">  //上下分割
	<frame src="top.html" scrolling="no">
	<frameset cols=" 20% , * ">
		<frame src="left.html" noresize frameboder="0" >
		<rrame src="right.html" name="myframe" frameborder="0">
	</frameset>
</frameset>


left.html
<body>
<ul>
	<li><a href="zjl.html" target="myframe">周杰伦</a></li>

	<li><a href="qq.html" target="myframe">齐秦</a></li>
</ul>
</body>







---------------------------------------------------------------------------------------

二: iframe浮动窗口：


<body>
	<a href="http://www.hao123.com" target="iframe">好123</a><br/>
	<iframe name="iframe" src="http://www.baidu.com" width=300 height=300 ></iframe>

	<iframe src="http://www.hao123.com" width=300 height=300 ></iframe>
	<iframe src="http://www.taobao.com" width=300 height=300 ></iframe> 
	
</body>









------------------------------------------------------------------------------------------


三：form 表单：


                     HTML 的form标签
网站怎样与用户进行交互？答案：使用HTML表单(form)
表单是可以把浏览者输入的数据传送到服务器端的程序（比如ASP，PHP）的HTML元素，服务器端程序可以处理表单传过来的数据，从而进行一些动作，比如，bbs,blog的登陆系统，购物车系统等。

form标签---代表HTML表单
	form标签是成对出现的，以<form>开始，以</form>结束。
常用属性：
	action-- 浏览者输入的数据被传送到的地方，如一个PHP页面（dofm.php）
	method -- 数据传送的方法
		get-- 此方法传递数据量少，但是传递的信息显示在网址上。
		post-- 此方式传送信息量多，而且不会把传递信息显示在网上。

	enctype---表示将数据发送到服务器时浏览器使用的编码类型。
		application/x-www-form-urlencoded---窗体数据被编码为名称/值对，这是标准的编码格式，默认的
	
		multipart/form-data---窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分.
	如： <form enctype="multipart/for-data" method=post cation=??>


			HTML input 标签
input 标签---代表HTML表单的单行输入域
	input标签是单独出现的,<input />
	属性：
	type--代表一个输入域的显示方式（分为输入型，选择型，点击型）
	name--此表单项名称
	value-- 输入域的值
	size-- 输入域的长度
		//长用的为上面四个
	maxlength--输入域最多可以输入文字的长度。
	checked -- 如果是选择型的输入域，代表以经被选择，值为checked
	readonly-- 输入域可以选择，但是无法修改，值为readonly
	disabled -- 输入域无法获得焦点，无法选择，以灰色显示，在表单中不起任何作用，如disabled="desabled"
	accesskey-- 表单的快捷键访问方式，如值为h即按Alt+h快捷键。
	tabindex-- 输入域的tab键遍历顺序。
	src -- 当使用图片来表示按钮时，代表图片的位置（URI）
	alt -- 用来替换提交按钮图片（当在input的src属性定义的图片无法显示时）提示信息。


type属性--代表HTML表单，单行输入域（框）的表现方式。
type属性聚值：
	text--文字输入域（输入型）
	password-- 也是文字输入域，但是输入的文字以密码符号‘*’显示（输入型）
	file-- 可以输入一个文件路径（输入型）
	checkbox-- 复选框，可以选择零个或多个（选择型）
	select:option--多个选项选一个。
	radio-- 单选框，只可以选择一个而且必须选择一个（选择型）
	hidden-- 代表隐藏域，可以传送一些隐藏的信息到服务器
	button-- 按钮（点击型）
	image-- 使用图片来显示按钮，使用src属性指定图像的位置（就像img标签的src属性）(点击型)
	submit-- 提交按钮，表单填写完毕可以提交，把信息传送到服务器，可以使用value属性来显示按钮上的文字（点击型）
	reset-- 重置按钮，可以把表单中的信息清空.可以使用value属性来显示按钮上的文字（点击型）



			HTML的textarea标签 (评论或自我介绍那种)
textarea标签--代表HTML表单多行输入域
	此标签是成对出现的，即以<textarea>开始，以</textarea>结束
属性：
	cols--多行输入域的列数。
	rows--多行输入域的行数.
	name--此表单项名称
	accesskev--表单的快捷键访问方式
	disabled --无法获得焦点，无法选择，灰色显示，表单无效。
	readonly--输入域可以选择，但是无法修改	
	tabindex--输入域，使用“tab”键的遍历顺序
	style="overflow-y:hidden" 	隐藏文本框的滚动条
	style="overflow-x:hidden"
	


      			HTML的select标签
select标签-- 选择列表标签
	select标签是成对出现的，以<select>开始，以</select>结束
	此标签中的每对 <option></option>标签代表一个选择项。
属性：
	name-- 表单项名称。
	size-- 选择域的高度
        multiple-- 可以有多个选择
	disabled-- 以灰色显示，在表单中不起任何作用。
	tabindex-- 使用“tab”键的遍历顺序。

option标签--代表选择列表的一个选择项
	option标签是成对出现的,以<option>开始，以</option>结束。
属性：

  	value-- 说明选项的值。
 	selected-- 此选项以经被选择
	disabled -- 输入框无法获得焦点，以灰色显示，在表单中表示禁用。
	tabindex -- 使用”tab“键的遍历顺序。
	label-- 说明选项。把选项区域化
		<label for="qx"><input type="checkbox" id="qx" onclick="sall(this)"/>
<body>
	<form name="myform" action="" method="post">     
		用户名：<input type="text" name="username" /><br/>
		密　码：<input type="password" name="psd" /><br/>
		出生日期：<input type="text" name="year" size="5" />年
				<select name="month" size="3" multiple>  //size 同时显示3个，multiple-可以多选
					<option>1</option>
					<option>2</option>
					<option>3</option>
					<option>4</option>
					<option>5</option>
					<option>6</option>
					<option>7</option>
					<option>8</option>
					<option>9</option>
					<option>10</option>
					<option>11</option>
					<option>12</option>
				</select>月
				<input type="text" name="day" />日 <br/>
		性　别：<input type="radio" name="sex" value="man" />男
				<input type="radio" name="sex" value="woman" />女<br/>
		爱　好：<input type="checkbox" name="ah[]" value='sport' />运动
				<input type="checkbox" name="ah[]" value='voice' />唱歌
				<input type="checkbox" name="ah[]" value='book' />看书
				<input type="checkbox" name="ah[]" value='play' />游玩<br/>
				
		上传文件：<input type="file" name="file" value=‘选择文件'/><br/>
				<input type="hidden" name="capsulation" /><br/>   //hidden 是一个隐藏域！
		自我介绍：<br/>
				<textarea name="textarea" cols=40 rows=5>
				</textarea><br/>
				<input type="reset" name="re" value="重置"/> 
				<input type="submit" name="sub" value="提交"/>
			
				
	</form>
</body>








----------------------------------------------------------------------------






四: 多媒体声音及视频：

  embed <body>体内插入视频;

	<body>
		<embed src="01.wmv" />
	</body>
	


插入视频剪辑：--在浏览器尚未完全读入AVI文件时，先在AVI播放区域显示该图像。
//loop是循环两次，start 是当鼠标放在该图像上的时候
<img src="url.gif" dynsrc="url.avi" loop="2" start="mouseover" />


插入背景音乐或音乐播放器
<body>
<object width=500 height=400 data="url.mp3" />
<embed src="slrj.mp3" hidden="true" autostart="true" loop="true" />
//hidden 表示隐藏(true,false)， autostart (true,false)表示自动播放  loop 表示循环(-1和整数，或true和false)
</body>









---------------------------------------------------------------------------



五：图像映射和脚本提示.


<html>
	<head>
		<title>图像映射和脚本提示</title>
		<script language="javascript">
		
			function show(){
				alert('点击了矩形区域');
			}
		
		</script>
	</head>
	<body>
		<img src="zy2.jpg" usemap="#one">
		<map name="one">
			<area shape="rect" onclick="show();" href="#" coords="0,0,300,300" />
		</map>
	</body>
</html>









------------------------------------------------------------------------------------




六：CSS--虑镜和伪类：



<style>
	a:link img{
		filter:gray;    //设置伪类，图片的滤镜：把图片都设置成灰色。
	}
	a:hover img{
		filter:"";	//设置伪类，图片的滤镜：当鼠标悬停在图片链接上时，显示原色；
	}
</style>

<body>
	<a href="#"><img src="../img/img/11.jpg" /></a>
	<a href="#"><img src="../img/img/22.jpg" /></a>
</body>





-------------------------------------------------------------------------------



七：选择器类型及父子选择器：

选择器是CSS中非常重要的概念，它有四种形式。
	1，类选择器，又叫做class选择器。
		如：.one{}	<div class="one"></div>
	2，id选择器，
		如：#one{}	<div id="one"></div>
	3，html元素选择器.
		如：p{}  hr{}   body{}  	<body></body>
	4,通配符选择器。 
		如：*{margin:0; padding:0;}    
			注：margin:后如果写一个值，代表上右下左（顺时针）,如果写两个值，代表，上下和左右,如果写三个			值，代表上，左右和下。
简单的说，选择器就是在CSS中创建，而在网页页面（html,jsp,php,as.net)中使用。

选择器的优先级别为：ID选择器>类选择器>HTML元素选择器>通配符选择器。


		父子选择器：
1，父子选择器可以有多级（但是在实际开发中不要过三层）.
2, 父子选择器有严格的层级关系。
3，父子选择器不局限于什么类型选择器，它可以多类型组合。
	例如：.s1 #id span     #id span span      div #id .s2


<style>
	#id1{
		color:blue;
		font:normal normal 20px normal;
	}
	#id1 span{
		color:red;
		font:italic bold 30px normal;
	}
	#id1 span span{
		color:#ccc;
		font:normal normal 50px normal;
	}
	#id1 span span a{
		color:#923984;
		font:normal normal 20px normal;
		text-decoration:none;
		
	}
</style>

<body>
	<p id="id1">这是一个<span>非常<span>重<a href="#">插入一个超链接</a></span>要</span>的新闻</p>
</body>
	
1，父子选择器也可是是其它类型组合在一起，如 .one span #two p a {}
2，一个标签（元素）可以同时有ID选择器和类选择器。	
	例：<span class="s1" id="nwes">新闻</span>   
		 //当类选择器影响多个元素时，想要单独改变其中某一个
			元素，就要利用ID选择器的优先级别来改变元素内容了！
3，一个标签（元素）最多只能有一个ID选择器，但同时可以有多个类选择器！
	例:<span class="cls1 cls2">新闻</span>
		//当一个标签（元素）同时拥有多个类选择器的时候。在CSS或style中位置
		靠后的优先级别高。

4,当多个类选择器中有相同的部分时，可以把相同的部分抽取出来，独立写一份！这样可减少冗余！
	例：	
		.one{
			width:500px;
			height:400px;
			background-color:blue;
		}

		.two{
			width:500px;
			height:400px;
			background-color:red;
		}
		.three{
			width:500px;
			height:400px;
			background-color:green;
		}
	可以写成这样：
		.one{
			background-color:blue;
		}

		.two{
			background-color:red;
		}
		.three{
			background-color:green;
		}
		.one, .two, .three{
			width:500px;
			height:400px;
		}




	一个标签可以同时拥有多个选择器：如：<div class="one two"></div>


选择器与超链接设置案例：


<html>

	<style type="text/css">
		.one{
			color:silver;
			
			font:italic normal 30px normal;
			text-decoration:underline;
			text-decoration:overline;
			text-decoration:line-through;			
		}
		#two{
			color:black;
			font:normal bold 30px/60px 黑体;
			text-decoration:overline;
			
		}
		body{
			color:red;
			font:italic bold 30px/50px 黑体;
			
		}
		a{
			color:black;
			text-decoration:none;  /*超链接的状态-黑色，无下划线*/
		}
		a:hover{
			color:red;
			text-decoration:underline;  /*鼠标放上去的状态-红色，有下划线*/
			font-size:40px;
		}
		a:visited {                         /*链接被点击后的颜色*/
			color: #00FF00;
		}
		p.x1{
			color:red;
			
		}
		p.o2{
			color:blue;
			font-size:40px;
		}
		
		
		#two span{
			color:red;<!--aaaaaa-->
		}
		#two span span{
			color:blue;
			font-size:40px;
		}
		#two span span a{
			color:green;
			font-size:20px;
		}
		
	</style>
	<body>
		<div class="one">AAAAAAAAAA</div>
		<div id="two">BBBBBBBBBBBBBB</div>
		<span>CCCCCCCCCCCCCCC</span><br>
		<a href="http://www.baidu.com" target="_">连接到百度</a><br>
		<a href="#">连接到百度</a><br>
		<a href="#">连接到百度</a><br>
		<a href="#">连接到百度</a><br>




		这里有时因为浏览器的内核不支持原因，而导致效果不能显现！
		<p class="x1">AAAAAAAAAAA</p>

		<p class="o2">BBBBBBBBBBB</p>

		<p id="two">这是一个<span>父子<span>选<a href="#">插入一个链接</a>择</span>器</span>的案例</p>

	</body>
</html>


作业练习：网页所有的超链接，要求这样的格式：
1，默认样式是红色，24PX，华方新魏字体没有下划线。
2，当鼠标移动到超链接时，自动出现下划线，字体大小变成40PX，字体变成宋体，green色
3,点击后，超链接变成灰色。

梁山英雄排行榜   （大字，黄色）
宋江  	（斜体 红色）
卢员外   (粗体 黑色)
吴用	 (斜体 下划线)
豹子头	 (黑色)
大刀关胜 (黑色)
(背景色都是灰色)











-------------------------------------------------------------------------------------



八：块元素和行内元素-概念。


行内元素(inline element),双叫内联元素；
	内联元素只能容纳文本或者其他内联元素，常见内联元素<span> <a> <input>
块元素(block element)
	块元素一般都从新行开，可以容纳文本，其它内联元素和其它块元素。即使内容不能占满一行，块元素也要把整行占满，	
		常见块元素<div> <p>

1,行内元素它只占内容的宽度，不会占据整行，而且不会自动换行：
2,块元素它不管自己的内容有多少，会占据整行，而且会换行显示。
3,一些css属性对行内元素不生效，比如 margin,left,right,width,height,建议尽可能使用块元素定位。




九：行内元素和块元素可以相互转换；

使用：
Display inline 表示使用行内元素方式显示；
Display block 表示使用块元素方式显示。
.s1{
	display:block;  //使用s1类选择器的元素，将按照块元素来显示。
}
.s2{
	display:inline; //使用s2类选择器的元素，将按照行内元素来显示。
}




十：CSS之间可以相互引用：

@import url('url.css')




十一：标准流和非标准流.

流，html元素在网页中显示的顺序。
标准流：在html文件中，写在前面的元素在前面显示，写在后面的html元素在后面显示。
非标准流：在html文件中，当某个元素脱离了标准流，那么它就处于非标准流了。











十二：盒子模型：

CSS盒子模型
CSS.CSSY文件：
.box1{
	float:left;
	width:450;
	height:500;
	border:1px blue solid;
	margin-top:10;
	margin-left:15;
	margin-bottom:10;
}
.box2{
	float:left;
	width:218;
	height:244;
	border:1px blue solid;
	margin-top:3;
	margin-left:3;	
}

HTML文件：
<html>
	<head>
		<title>one</title>
		<meta http-equiv="content-type" content="text/html;	charset=gb2312" />
		<link type="text/css" rel="stylesheet" href="./css.css" />
	<head>
	<body>
		<?php
			for($i=1;$i<5;$i++){
				echo "<div class=box1>";
					for($j=1;$j<5;$j++){
						echo "<div class=box2>";
							for($l=1;$l<5;$l++){
							
								echo "<div class=box3></div>";
								}
						echo "</div>";
					}
				echo "</div>";
			}
		?>
	</body>
</html>




--------------------------------------------------------------------




十三：浮动。

浮动“float”分为左浮动“left”和右浮动“right”还有清除浮动“clear” 
如：
	float:left;
	float:right;
	clear:left;
	clear:right;
	clear:both;

	如果使用浮动属性：则行内元素也会成为块元素，和display:block的区别是一个可以浮动，一个不可以浮动。

使用盒子模型的浮动布局
	虽然使用绝对定位可以实现页面布局，但由于调整某个区块框时其它区块的位置并不会跟随着改变，所以并不是布局的首先方式，而使用浮动的区块可以向左或向右移动，直到它的外边缘碰到包含它区块的边框或另一个浮动框的边框为止。并且由于浮动框不在文档的普通流中，所以普通文档的普通流中的区块框表现得就像浮动框不存在一样。



				行框和清理
	在进行页面布局时，经常需要设置多个区块并列在一行中排列。最常见的方式就是使用float属性，再通过left或right值移动区块框向左或向右浮动。但当前面并列的多个区块度不足包含框的100%时，就会在行框中留出一定的宽度，而下面的某个浮动的区块框又恰好满足这个宽度，则很可能会向上提，和上一行并列的区块框在同一行排列。而这并不是我们想要的结果，所以可以使用clear属性解决这一问题，该属性的值可以是left,right,both或none,它表示框的哪些边不应该挨着浮动框。




















--------------------------------------------------------------




十四：浮动定位。

position: static |  absolute | fixed | relative  
static:静态定位-是默认的正常定位，left,top对它不生效。
absolute: 绝对定位-是在同样也脱标的父元素中改变自身位置的定位，如果没有父元素或父元素属于标准流时	，则对页面的左上角定位。它移动后的空间会被其它区块占用。 类似于被浮动了！
fixed:固定定位-就是只针对页面(不是body)的左上角来定位。这没有父区块。或唯一父区块就是页面。
	它移动后的位置也会被占用，也类似于浮动。即使不移动加上此属性，位置也会被占用。出现重叠。
relative: 相对定位-是针对自己原位做的定位改变，它脱离标准流后的空间，不能被占用，依然要保留。
		相对定位会随着父区块的改变而改变，最终父区块为body.


<html>
	<head>
		<title>定位</title>
		<link type="text/css" rel="stylesheet" href="position.css" />
		<style>
			border:1px blue solid;
			}

			.box1{
				width:150px;
				height:100px;
				margin-left:300px;
			}
				.div1{
					float:left;
					width:30px;
					height:30px;
					background:#ccc;	
				}
				#spe{
					position:relative;
					top:40px;
					left:40px;
				}
			.ge{
				width:990px;
				height:1px;
				float:left;
			}
			.box2{

				width:150px;
				height:100px;
			}
				#spe2{
					position:absolute;
					top:50px;
					left:50px;
				}
			.box3{
				width:200px;
				height:200px;
				border:1px blue solid;
			}

				#spe3{
					position:fixed;
					top:300px;
					left:300px;
				}
		</style>
	</head>
	<body>
relative-相对定位；脱离标准流，原空间保留，以原坐标做为计算基点。
		<div class="box1">
			<div class="div1">aaa</div>
			<div id="spe" class="div1">bbb</div>
			<div class="div1">ccc</div>
			<div class="div1">ddd</div>
		</div>
		<hr><br>
absolute-绝对定位：是对同样脱标的父元素定位，如果没有父元素就对BODY左上角来定位。
		<div class="ge"></div>
		<div class="div1">ccc</div>
		<div class="div1">ddd</div>
		<div class="div1">aaa</div>
		<div id="spe" class="box2">
			<div id="spe2" class="div1">bbb</div>
		</div>
		<div id="spe3" class="box3">这是一个fixed定位，它就是针对body的左上角的纯绝对定位！</div>
		

	</body>
</html>










十五：区块层叠顺序设置；
z-index: 用于设置对象"div"显示时候，层叠的属性，z-index的值越小，则越在下层显示。


<html>
	<head>
		<title>z-index的浮动上下层叠的优先级设置</title>
	</head>
	<style>
		.all{
			width:100%;
			height:200px;
			background:#eee;
			position:relative;
		}
		.one, .two, .three{
			width:150px;
			height:150px;
			float:left;
			
		}
		.one{
			background:red;
			position:absolute;
			top:25px;
			left:80px;
			z-index:3;
		}
		.two{
			background:yellow;
			position:absolute;
			top:20px;
			left:210px;
			z-index:2;
		}
		.three{
			background:blue;
			position:absolute;
			right:20px;
			top:30px;
			z-index:1;
		}

	</style>
	<body>
		<div class="all">
			<div class="one"></div>
			<div class="two"></div>
			<div class="three"></div>
		</div>
	</body>
</htmal>



异常现象记录：
在float和align同时存在的时候align的属性值无效，上面的代码要想让table居中显示在
        页面上需要把style中的float: none; 去掉！











十六：关于PHP以及bs和cs的介绍
 	1，PHP是persola home page
	2,目前是zend公司负责维护和商业化，
	3，PHP是嵌入到HTML代码
	4,PHP脚本是运行在服务器端的.
	5,soap(简单对象协议)
	6,php开发工具 (ide 集成开发环境)
		记事本
		editplus
		vim
		zendstudio
		easyeclipse



bs和cs的介绍

bs 中的b - browser 浏览器的意思  S-服务器
cs 中的c - client  客户端的意思  s-服务器

b/s的优势：
	1，开发成本低，
	2，管理维护简单。
	3，产品升级便利。
	4，对用户的培训费用低。
	5，用户使用方便，出现故障的概率小。
b/s的不足：
	1，安全性不足。
	2，客户端不能随心变化，受浏览器的限制。



十七：apache的命令行和相关的配置
	httpd -k start 
	httpd -k shutdown
	httpd -k restart


1，一台机器可以有1-65535号端口

2,netstat -an 来查看机器有哪些端口在监听。

3,netstat -anb  扫描并列出正在监听的端口和所对应的相关程序和服务
		可以通过资源管理器关闭相应程序来关闭端口
4，一个端口只能被一个程序监听。

5，端口的类别：
	有名端口： 1-1024 以经被分配。
	其它端口： 可以根据需要不同设置。



apache如何配置端口；
1，apache的配置文件是 apache目录下的conf文件夹中,名为httpd.conf的文件。
	修改端口就是把 httpd.conf文件中的 Listen 80 改成如 : listen (端口号)
		注意修改后一定要重新启动apache

2，apache 可以同时监听多个端口：
	Listen 80 
	Listen 81 
	Listen 82 



apache 各目录文件的意义：

bin -- : 该目录下存放apache的常用命令，比如httpd
cgi-bin -- : 该目录存放linux下的常用命令 .sh
conf -- ；存放配置文件 如 httpd.conf
error -- : 存放错误记录.
htdocs -- : 存放我们的站点文件（默认情况下）如果有多个站点，可以通过文件夹来分类。
icons -- : 存放图标。
logs -- : 记录apache的相关日志。
manual -- : 手册。
modules -- : apache 模块。









apache 配置虚拟目录：

如果，我的apache是安装在C盘，但是出现C盘空间不足，而D盘有更多空间，能不能把D盘的一个文件夹
下的网页html.php当做网站管理。可以的，如下！！！
配置虚拟目录在apache的conf目录下httpd.conf的<IfModule dir_module>节点后添加如下代码：如下：
	
一，首先在httpd.conf文件中找到下面三行代码。
<IfModule dir_module>
	DirectoryIndex index.html
</IfModule>
二，在上面三行代码后面加入如下代码。
<IfModule dir_module>
	//下面一行是web应用的默认访问页面，类似欢迎页面。web应用名称，可以自行指定。
		它的意思是浏览器默认会找寻index.html.如果没有就找，index.htm如果没有就找index.php
		依此类推，你可以加入,xxx.htm,或xxx.html等。
	DirectoryIndex index.html index.htm index.php   
	Alias /myblog "D:/myblog"				
	<Directory "d:/myblog">				
	Order allow，deny
	Allow from all
	</Directory>
</IfModule>


三，注销httpd.conf文件中的 <DocumentRoot "D:/AppServ/www">在前头加#就是注销。这行代码是默认指定的路径。  

（如果注销了，就只能访问你所设置的文件夹，如果不注销，可以访问全部！）





文件权限设置：

<Directory d:/myblog">	// 表示对d:/myblog这个指定的文件权限设置			
	Order allow.deny // allow表示，先许可所有的IP访问，deny表示又拒绝所有。
	Allow from all  //许可所有IP
</Directory>
示例：

order deny,allow      //这一行规定了访问权限的规则。有拒绝，有允许。
allow from 218.20.253.2 //这一行规定了，ip:218.20.253.2 是被允许访问的。
deny from 218.20	//这一行规定了，以ip;218.20开头的IP地址都被拒绝访问。
综上可以看出，先是拒绝了218.20IP段的访问权，然后又允许了218.20.253.2的访问权，结果只有218.20.253.2的这个IP是有访问权的，

又例如；
order allow,deny      //先允许，后拒绝
allow from 218.20.253.2 //这一行规定了，ip:218.20.253.2 是被允许访问的。
deny from 218.20	//这一行规定了，以ip;218.20开头的IP地址都被拒绝访问。
这里可以看出是先允许了218.20.253.2,然后又拒绝了218.20的IP段。 所以这个例子中任何IP都没有访问权。








十八：apache-虚拟主机

配置虚拟主机的步骤如下；
	1，启用 httpd-vhosts.conf
	在httpd.conf文件中找到下面节点
#Virtual hosts
#Include conf/extra/httpd-vhosts.conf               //启用的话就把前面的#号去掉  #号相当于注释

	2,在httpd-vhost.conf文件中做配置:
打开conf/extra/httpd-vhost.conf文件并进行相关配置，

设置虚拟主机有两种方法。

一：在文件节点中找到下面这段代码。复制，进行改动设置。
<VirtualHost *:80>
    ServerAdmin webmaster@dummy-host2.x
    DocumentRoot "C:/Apache2.2/docs/dummy-host2.x"
    ServerName dummy-host2.x
    ErrorLog "logs/dummy-host2.x-error.log"
    CustomLog "logs/dummy-host2.x-access.log" common
</VirtualHost>


二:自行设置相应数据；
<VirtualHost 127.0.0.1:80>       //这个主机被访问时。会被指向下面的"d:/myblog"
	DocumentRoot "d:/myblog"
	#这里配置欢迎首页面
	DirectoryIndex index.html index.htm index.php
	<Directory />
	Options FollowSymLinks
	#不允许别人修改我们的页面
	AllowOverride None
	#设置访问权限
	Order allow,deny
	Allow from all
	</Directory>
</VirtualHost>













十九：PHP开发环境的搭建。

在windows 搭建:
windows + apache(iis)  + mysql(+myadmin)+ php == wamp

在linux下搭建：
linux + apache + mysql(_myadmin) + php == lamp


1，安装apache
	安装完成后，在浏览器输入：http://localhost 查页面是否安装成功。
2. 安装php  下载地址:www.php.net官网
VC6 就是 legacy Visual Studio 6 compiler.就是使用这个编译器编译的。
VC9 就是 the Visual Studio 2008 compiler.就是用微软的VS编辑器编译的。

如果你是在windows 下使用Apsche + php ，请选择VC6版本
如果你是在windows 下使用IIS + PHP ,请选择 VC 9 版本。

 Thread Safe 线程安全

比如说：A和B两个资源，都要向C里写入，那么谁先定，怎么写？
如果安排顺序，一个先写，另一个后写，那么就是线程安全，不易出错，但是这样效率慢！
如果不按顺序，两个随便写，就会容易出错，但效率高。
官方不建议将Non Thread Safe 应用于生产环境，所以我们选择 Thread Safe

PHP下载完成后，直接解压即可！


		整合apache和PHP （如何连接它们）
		也就是说，怎样才能让apache处理php
	



	重启后在浏览器输入 http://localhost 看是否出现php的环境介绍页面。



	5，安装mysql
	一，下载安装：下载地址：www.mysql.com  
	二，启用mysql功能：
		在php.ini中找到 extension_mysql.dll
				extension=php_mysqli.dll
		并把启用它们，就是把前面用来注释的 ; 分号去掉就可以了。
	安装完成后测试是否安装成功.  
	<?php  
		$link = mysql_connect('localhost','root','abcd')
		if($link){
			echo "连接成功";
		}else{
			echo "连接失败";
		}



 	6,安装一个phpmyadmin
	把文件直接解压到htdocs目录，然后直接访问
	localhost/phpMyAdmin/index.php 即可

安装、重装MySQL时,出现could not start the service mysql error:0的解决办法
当各位在安装、重装时出现could not start the service mysql error:0
原因: 卸载mysql时并没有完全删除相关文件和服务，需要手动清除。

安装到最后一步execute时不能启动服务的解决方法：
首先，在管理工具->服务里面将MySQL的服务给停止(有的是没有安装成功,有这个服务,但是已经停止了的)，win+R―>cmd,打开命令提示符窗口，
输入命令：sc delete mysql(查看服务，此时服务中已没有mysql),将已停的服务删除,卸载MySQL记得选择remove。最后将MySQL安装目录删除，还有数据库的目录也删除。

解决的方法：命令提示符下输入regedit,打开注册表
把注册表
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services
HKEY_LOCAL_MACHINE/SYSTEM/ControlSet001/Services/Eventlog/Applications/MySQL
HKEY_LOCAL_MACHINE/SYSTEM/ControlSet002/Services/Eventlog/Applications/MySQL
HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Applications/MySQL
将相关目录下的键值，如果有相关mysql键值(mysql、mysqladmin)则删掉
注册表中有关MySQL的东西可能删除的不彻底,ctrl+F查找mysql,之后用F3循环查找,将有关MySQL这个软件的全部有关项删除
 
注意(删除项时出错):
无法删除 LEGACY_MYSQL51(自己建数据库时置的用户名): 删除项时出错。解决办法:注册表项里右键增加administrators所有权限
 
之后打开360安全卫士或金山卫士清理一下注册表！

删除MYSQL数据表目录（C:/Documents and Settings/All Users/Application Data/MySQL/MySQL Server 5.1/Data/）(Application Data是隐藏的,要在查看里面将其设置为显示
win7下一般在C:\ProgramData\MySQL目录下,注意ProgramData这个文件夹默认是隐藏的)，

最后重启计算机,重新安装mysql. 运行向导Server Instance Configuration wizard，进行相关设置即可。




进入数据库： 
 
显示库内容：

进入数据库： 

显示库中的表: 	

看表的内容结构： 

插入内容：

更新更改内容：

删除数据

同时查 两项内容。

查询表中所有的内容

查询id为33的具体内容;

查询id小于10的所有内容；

查询id从15到25之间的内容.

同时显示多条不同的内容。

模糊查找，带某个字符段的。

模糊查找，以某个字段开头的，

模糊查找，以某个字段结尾的。

正序排列显示，

倒序排列显示

限制最多输出三行，

限制 从第七行开始，最多输出三行。

查询user表里有多少条内容。

计算总和：

求平均数； 

求最大值； 

求最小值； 




---mysql命令：
进入数据库： mysql -uroot -p  
显示库内容：show databases;
进入数据库：  use threephp    	//threephp为数据库的名字
显示库中的表: show tables;  	
看表的内容结构： desc user;

插入内容： insert into user(name,age,sex) value('zhangsan',20,'nan');  
//更新更改内容：
update user set name = 'wangjun';  //这里不加参数where会改变表中所有该名字的内容。
update user set name = 'zhangsan' where id = 1; 
update user set name='abcdefg',age=999,sex='ggg' where id=94;
 Delete 删除数据：
delete from 表名 [where 条件] [order by字段] [limit 行数]
delete from user where id = 3;                      //user 是表名，where必须有的参数，
//查询相应字段同容；
select name from user;    //只查name;
select name,age from user;			 //同时查name 和age 两项。
select * from user;      			  //查询user 表中所有的内容
select id,name,age,sex from user where id = 33;    //查询id为33的具体内容;
select id,name,age,sex from user where id < 10;    //查询id小于10的所有内容；
select id,name,age,sex from user where id between 15 and 25;   // 查询id从15到25之间的内容.
select id,name,age,sex from user where id in (4,6,32,53,57,60);  //同时显示多条不同的内容。
select id,name,age,sex from user where name like '%a%'; //模糊查找，带某个字符段的。
select id,name,age,sex from user where name like '%g'; //模糊查找，以某个字段开头的，
select id,name,age,sex from user where name like 'w%'; //模糊查找，以某个字段结尾的。
select id,name,age,sex from user order by id;  //正序排列显示，可以用name,age,等其它。后面省略了asc 因为是默认的.
select id,name,age,sex from user order by id desc;  //倒序排列显示，，，，其它同上。
select * from user limit 3;  //limit 限制最多输出三行，
select * from user limit 7,3;  //限制 从第七行开始，最多输出三行。
select count(*) from user; //查询user表里有多少条内容。
select sum(age) from user;  //计算总和：计算user表下的 age 年龄的总和是多少。
select avg(age) from user;  //求平均数； 计算user表下的age 年龄的平均值是多少。
select max(age) from user;  //求最大值； 显示user 表中age年龄最大的。
select min(age) from user;  //求最小值； 显示user表中age年龄最小的。
select version();        //查询版本；
select 1+1;              //可以计算；











二十：Discuz论坛
1，到 www.comsenz.com 下载 discuz
2, 解压到htdocs目录下。
3，把discuz下的upload文件拷贝到discuz文件夹下。然后删除upload文件夹。
4，修改文件 config.inc.php

	[CH]以下变量请根据空间商提供的账号参数修改，如有疑问，请联系服务器提供商

	$dbhost = 'localhost' //数据库服务器
	$dbuser = 'root' 	//数据库用户名            这里的用户名和密码需要改动一下
	$dbpw = 'root'		//数据库密码
	$dbname = 'discuz' 	//数据库名称
	$pconnect = 0 ;		//数据库持久连接 0=关闭，1=打开；



	[CH]论坛安全设置，调整以下设置，可以增强论坛的安全性能和防御性能。
	$adminemail = 'admin@your.com';		//系统管理员Email
	$forumfounders = 'admin';				//  这里要添加一个管理员


5,将index.php暂时先更换为其它名，不要默认打开此面

6, http://localhost/discuz  访问站点


7, 点击install.php 进入安装页面

8，安装完成后，再把index.php名改回来。

9, 如果登陆提示：对不起请将php.ini中的short_open_tag设置为On,否则无法继续安装论坛，。
		就按照提示修改。  
















二十一： 一个IP绑定多个域名。
解决方案一：通过端口区分来解决一个IP绑定多个站点。
	1，备好开发完的网站 d:/myblog
	2, 配置我们的httpd.conf文件,启用httpd-vhost.conf
	3, 配置我们的 httpd-vhost.conf
	4, 在hosts文件中添加 ip 和域名的对应关系
		c:/windows/system32/dirvers/etc/hosts
	5,建议注销 DocumentRoot
	 	#DocumentRoot "C:/,,,,"
	6,测试

添加一个新的域名于该IP绑定。
	
	1，开发新的网站：d:/myblog2
	2,配置我们的httpd-vhosts.conf
	添加新的虚拟主机
	<VirtualHost 127.0.0.1:81>
	DocumentRoot "d:/myblog2"
	DirectoryIndex index.html
	<Directory />
	Options FollowSymLinks
	AllowOverride None
	Order allow,deny
	Allow from all
	</Directory>
	</virtualHost>
3.在httpd.conf文件让apache 监听81端口listen81
4,在hosts文件中在添加新的域名127.0.0.1 wwwshunping3.com
5,测试



解决方法二：通过ServerName端来区分不同的域名.

	!!!注意!!! 这个方法需要开启本页当中的 #NameVirtualHost 功能 找到它，去掉#号.

<VirtualHost *:80>
	DocumentRoot "d:/myblog"
	#这里指定域名；
	ServerName www.shunping1.com              //与端口绑定的唯一区别就在这一句的域名绑定上！
	DirectoryIndex index.html
	<Directory />
	Options FollowSymLinks
	AllowOverride None
	Order allow,deny
	Allow from all
	</Directory>
</virtualHost>

<VirtualHost *:80>
	DocumentRoot "d:/myblog2"
	#这里指定域名；
	ServerName www.shunping2.com
	DirectoryIndex index.html
	<Directory />
	Options FollowSymLinks
	AllowOverride None
	Order allow,deny
	Allow from all
	</Directory>
</virtualHost>







二十一：数据类型介绍：

    PHP的数据类型有三大类
	A:基本数据类型：
		1。整形 integer
		2，浮点型 float double
		3, 布尔型 boolean 
		4, 字符串
	B: 复合数据类型：
		1，数组 array
		2, 对象 object
	C: 特殊数据类型：
		1，null
		2, 资源类型 resource
			如： $link = mysql_connect();   它代表一个连接。


浮点数细节：
	浮点数的字长和平台相关，通常最大值是1.8E308 并具有14位十进制数字的精度（这个限制很重要）
	小数的精度如何起算：从左边开始第一个非0的数开始计算。如：
		$a = 567.1234567    	  显示 567.1234566
		$b = 789.00012345678922	  显示 789.00012345678
		$c = 0.000000000000089077 显示 0.000000000000089077

自增，自减，自乘，取余；
	
	$a=56;
	$b=90;
	
	$a -= 34 ;
	$b %= $a;
	结果：
	$b = 2;   //$b %=$a 90%22==90除22等于4 余2  结果就是2
	$a = 22;



与，或，非，取反，异或：
$a and $b  逻辑与: 有一个值为false 则结果为 false 且当第一个为false时,后面的就短路不执行。
$a ro $b   逻辑或: 有一个值为true  则结果为true 且当第一个为true 时，后面的短路不执行
$a xor $b  逻辑异或: 
!$a 	逻辑非	：
$a && $b  逻辑与：
$a || $b  逻辑或：

逻辑与  or 和逻辑或 and 的优先级比较低  or < = < ||  and < = < &&
 
  	$a = 10 ; $b = 7;
	if($a++>8 || $b++>7){
		echo "ok"; //此处为true  
	}
	echo $a.$b;   	//结果 a=11 ,b=7   因为，上面$a>8成立后，||后面的就短路不执行了！
	

	$a = 10 ;  $b = 7;
	if($a++>10 && $b++>7){  //这里的$a++>10   是先执行$a>10 然后再++  .因为++的优先级是最低的。
		echo 'ok';	//不被执行。因为逻辑与有一个为false 结果就为false,且当第一个为false则第二个						就会短路不再执行了。
	}
	echo $a.$b;  //结果为 a=11,b=7   虽然上述为false,但第一个$a还是要自增的，  后面的因为是逻辑与，就不执行了


	$e = false || true ;   // $e 结果为true;
	$f = false or true ;   // $f 结果o false;
//上例虽然$e和$f都是逻辑或，但是 or 的优先级别比 = 还要低，所以它是先给$f赋值，然后再 of true.






	三元运算法（三目运算法）
<?php
	$a = 90;
	$b = 80:
	$c = $a>$b ? (12-10) : "hello word";
	echo $c ;    //结果为 2 
?>




类型运算符：
	instanceof 用于确定一个PHP变量是否属于某一类class 的实例

class Dog{}
class Cat{}

$cat1 = new Cat;

if($cat1 instanceof Cat){
	echo "$cat1 是一只猫";
}



	细节：++的优先级
	
	$a = 3;
	$b = $a++ *3;
	echo  $b;     //结果等于9  先赋值后自增

	$a = 3;
	$b = ++$a *3;
	echo $b ;	//结果等于12,先自增，后运算。











二十二，switch 特例  IF和WTITCH的应用区别

$a = true;
switch($a){
case false:
	echo "truel1";
	break;
case 2:
	echo "hello2";
	break;
default:
	echo "default";
}


结果显示： case2内容： hello2     因为它会把case的2 当作一个布尔值的true 来看。 所以会显示 hello2


switch 语句也可以匹配“null”
$a = "null";
switch($a){
case null:
	echo "truel1";
	break;
case 2:
	echo "hello2";
	break;
default:
	echo "truel1;
}

$i = 11;
weitch ($i){
 	case 10:
	echo "10";

 	case 1.3:
	echo "11";
	break;

	default:
	echo "hello";

 	case 11:
	echo "12";
	break;
}

   总结：switch 首先按照case顺序进行配置，如果一个都没有匹配到，则执行
default语句的内容，直到遇到braak.则退出switch.



	IF 和 switch语句的应用区别： IF 是对某个范围的判断，而switch是对某一个点的判断。所以我们可以这样去选择它们。
	当我们的分支就是几个点的时候（比如说先反上下左右的方向时）就应该使用switch。如果你的分支是几个区域（范围）的判断，则考虑使用IF。










二十三： while与 do while


<?php
$i = 0 ;
do{
	echo 'aaaaaaaaaa<br>';
	$i++;
}while($i<10);
?>



while 循环是先判断后执行，，  do while 是先执行（至少一句循环体内容）
后判断




二十四： 用循环语句打印出 三角形，金字塔，和空心凌形。

1。直角三角形：
	for($i=1;$i<5;$i++){
		for($j=1;$j<$i;$j++){
			echo "*";
		}
		echo "<br>";
	}
2.金字塔；
 一：自己的做法；
	$n = 10;
	for($i=1;$i<$n;$i++){
		for($k=1;$k<=$n-$i;$k++){
			echo "&nbsp";
		}
		for($j=1;$j<=($i-1)*2+1;$j++){
			echo "*";
		}
		echo "<br>";
	}

3,空凌形
<?php
	$b=15;
	for($i=1;$i<$b;$i++){
		for($k=1;$k<$b-$i+40;$k++){
			echo "&nbsp";
		}
		echo "*";
		for($j=1;$j<$i*2-2;$j++){
			echo "&nbsp";
		}
		if($i!=1){
		echo "*";
		}
		echo "<br>";

	}
	for($i=1;$i<$b;$i++){
		for($k=1;$k<$i+40;$k++){
			echo "&nbsp";
		}
		echo "*";
		for($j=1;$j<($b-$i)*2-2;$j++){
			echo "&nbsp";
		}
		if($b-$i!=1){
		echo "*";
		}

		echo "<br>";
	}
?>

  二：老师的做法；
	$n = 10;
	for($i=1;$i<$n;$i++){
		for($k=1;$k<=$n-$i;$k++){ 	 //打*前，先打空格。
			echo "&nbsp";
		}
		for($j=1;$j<=($i-1)*2+1;$j++){ 	 // 每层*的个数
			if($i==1 || $i==$n){
				echo "*";
			}else{
				if($j==1 || $j==($i-1)*2_1){
					echo "*";
				}else{
					echo "&nbsp";
				}
			}

		}
		echo "<br>";
	}
















二十五： PHP版计算器及表单信息传送另一页面和request接收

request 是用来接收POST和GET的传值信息的。接收时的name 要与发送的name 完全一致！当name值不同的，结果会以null 或 "" 的形式表示。


rithmetic.php

<html>
	<head>
		<title>计算器与request接收</title>
		<meta http-requiv="content-type" content="text/html charset=utf-8" />
	</head>
	<body>
		<form action="request.php" method="post" />
			<table width="400" >
				<tr>
					<td>请输入一个数值</td>
					<td><input type="text" name="num1" /></td>
				</tr>
				<tr>
					<td>再输入一个数值</td>
					<td><input type="text" name="num2"/></td>
				</tr>
				<tr>
					<td>请选择运算符</td>
					<td>
						<select name="operator">
							<option value="+">+</option>
							<option value="-">-</option>
							<option value="*">*</option>
							<option value="/">/</option>
						</select>
					</td>
				</tr>
				<tr>
					<td colspan="2">
						<input type="submit" name="sub" value="计算结果" />
					</td>
				</tr>
			</table>
		</form>
	</body>
</html>


result.php

<?php
	$num1 = $_REQUEST["num1"];
	$num2 = $_REQUEST["num2"];
	$oper = $_REQUEST["operator"];
	switch($oper){
		case "+";
			$res = $num1+$num2;
			break;
		case "-";
			$res = $num1-$num2;
			break;
		case "*";
			$res = $num1*$num2;
			break;
		case "/";
			$res = $num1/$num2;
			break;

	}
	echo "计算结果等于：".$res ;
	
?><br>
<a href="rithmetic.php">返回计算页面</a>










二十六： 猜拳游戏及script change转换图片功能

<html>
	<head>
		<title>猜拳游戏</title>
<script lauguage="javascript">
	function mychange(obj){
		<!--window.alert('变化');//成功会弹出提示框-->
		<!--var val=obj.value;-->
		<!--window.alert(val);  //这两句是把选项的(qt,jd,b)值取到-->
		<!--val() 只会对第一个元素起作用.-->	
	var val=obj.value;
	var m=document.getElementById("g");
		if(val=="qt"){
			m.src="1.png";
		}else if(val=="jd"){
			m.src="2.png";
		}else if(val=="b"){
			m.src="3.png";
		}
	}
</script>		
	</head>
	<body bgcolor="#ccc">
	<select name="you" onchange="mychange(this);">
		<option value="qt">石头</option>
		<option value="jd">剪刀</option>
		<option value="b">布</option>
	</select>
	<img src="4.png" id="g"/>
	</body>
</html>








二十七 循环相关语句-break-continue-goto以及-常量
	基本的概念，表示结束当前的for,while,do while,swithc,流程，可以给一个数字
表示退出到第几层。

$i=0;
//  这里暗藏杀机。当++在前面是是先自增，也就是说$i先增为1,它为真，循环继续，如果是$i++,它就是后自增，这是它本身为0为假，就会直接跳出循环！所以这里要注意自增的前后位置！
while(++$i){   
	switch($i){
	case 5:
		echo "aaaaa<br>";
	break;   //这里break 跳出当前的switch,返回到wihile循环上。
	case 10:
		echo "bbbbbb<br>";
	break 2; //这里的break连跳switch,while两层，直接跳出循环。
	default:
	break;
	}

}
echo '$i='.$i;

结果 ： aaaaaaaa	
	bbbbbbbb
	$i=10;

从上面的案例，我们得到几个结论：
1: break语句，默认跳出1 层。
2：break语句，后面带的数字，不能超过实际可以跳出的循环层数，否则报错！


	---循环相关语句-continue
基本概念：continue 用于结束本次循环剩余代码。从新开始新的一次循环（如果条件为真，就继续执行），countinue后面也可以带数字，表示从第几次循环重新开始。

for($i=0;$i<2;$i++){
	for($j=1;$j<4;$j++){
		if($j==2){
			continue;
		}
	}
	echo '$i='.$i.'$j='.$j."<br>";
}
结果是： 0 1  , 0 3 ,1 1 , 1 3 


for($i=0;$i<2;$i++){
	for($j=1;$j<4;$j++){
		continue 2;
	}
	echo '$i='.$i.'$j='.$j;
}
结果是： 0   1 ,   1  1


	---goto语句：
基本概念：通过goto语句匀们可以将程序跳转到指定的地方去执行。
PHP中的GOTO有一定限制，只能在同一个文件和作用域中跳转，也就是说你无法跳出一个函数或类方法，也无法跳入到另一个函数。常见用法是用来跳出循环或者switch,可以代替多层的break;
	语法； goto 标签；
		标签：
		语句；
goto a;
echo 'aa';
a:
echo 'bb';
结果显示  bb;

for($i=0,$j=50;$i<100;$i++){
	while($j--){
		if($j==17)goto end;
	}
}
echo "i=$i";
end:
echo 'j=17';
结果 : j=17;





=====常量：

常量可以理解成是一种特殊的变量，一旦被定义，就不能再改变或者取消定义。
常量和变量有如下不同；
1,常量前面没有美元符$.
2,常量一旦定义就不能被重新定义或者取消定义。
3,常量在定义的时候，就需要给它赋初值。
4，常量通过define 或者const定义。
5，常量名称一般全部大写，然后用下划线间隔。
6，在程序中我人不希望某个值变化，则考虑用常量。比如圆周率等。
7，常量可以不用理会变量的作用域而在任何地方定义和访问。
8，常量的值是标量(基本数据类型)string,integer,float,boolean.
<?php
	//第一种方法：
	define("TAX_RATE",0.08);
	echo TAX_RATE;
	结果： 0.08

	//第二种方法；只适用于php5.3版本以后，以前的会报错
	const TAX_RATE2=0.1;
	echo "--".TAX_RATE2;
	结果：0.1
?>



-----常量的定义与使用：

<?php
	define ('AAA','23489jelkwjer');
	echo "类外define定义的全局常量：AAA-".AAA."<BR>";
	echo "它只能在类外定义，属于全局常量！<hr>";
class One{
	const BBB="222";
	//const它只能在类中定义，属于成员常量！但它可以同时被类的内部和外部调用。
	public $a;
	public function __construct($aaa){
		$this->a=$aaa;
		echo $this->a;
		echo "<hr>".self::BBB."类中定义的常量，在本类中的调用！<hr>";
	}	
}
echo "类中const定义的常量".One::BBB."<br>";
echo "<hr>";
$a=new One(AAA);
?>






-----const与define的区别

| 浏览：130 |更新：2013-08-27 18:18
【问】在php中定义常量时,const与define的区别? 

【答】使用const使得代码简单易读，const本身就是一个语言结构，而define是一个函数。另外const在编译时要比define快很多。

(1).const用于类成员变量的定义，一经定义，不可修改。define不可用于类成员变量的定义，可用于全局常量。

(2).const可在类中使用，define不能。

(3).const不能在条件语句中定义常量。

例如： 

if (...){ 

  const FOO = 'BAR';  // 无效的invalid 

}  

if (...) { 

  define('FOO', 'BAR'); // 有效的valid 

}

(4).const采用一个普通的常量名称，define可以采用表达式作为名称。 

 const  FOO = 'BAR';  

 for ($i = 0; $i < 32; ++$i) { 

  define('BIT_' . $i, 1 << $i); 

}

(5).const只能接受静态的标量，而define可以采用任何表达式。

例如： 

const BIT_5 = 1 << 5;  // 无效的invalid  

define('BIT_5', 1 << 5); // 有效的valid

(6).const定义的常量时大小写敏感的，而define可通过第三个参数（为true表示大小写不敏感）来指定大小写是否敏感。

例如：

define('FOO', 'BAR', true);  

echo FOO; // BAR 

echo foo; // BAR





二十八: 函数
函数是为完成某一功能的程序指令（语句）的集合。称为函数.
在PHP中，函数分为：自定义函数，系统函数。
函数与JAVA的封闭很相像。把某些固定常用的功能封闭到一个集合里，然后可以随时多方面来调用。

例：
funcs.php()   //我们定义了一个函数
<?php
	//我们一个计算，+,-,*,/ 的代码集合->函数。
	//1.function是一个关键字。
	//2.jiSuan是一个函数名(由程序员取名)
	//3.$num1,$num2,$oper 是函数的参数列表（形参）
	function jiSuan($num1,$num2,$oper){
		//$res 用来存放的此函数的计算结果
		$res=0;
		switch($oper){
		case "+";
			$res = $num1 + $num2;
		break;
		case "-";
			$res = $num1 - $num2;
		break;
		case "*";
			$res = $num1 * $num2;
		break;
		case "/";
			$res = $num1 / $num2;
		break;
		default:
			echo "运算符号有误";
		}
		return $res;  //表示返回一个结果
	}


funcc01.php // 该文件使用到了我们定义的函数。
<html>
  <head>
	<meta http..../>
  </head>
  <?php
	//引入你需要的PHP文件
	require "funcs.php";
	//完成一个这样的需求。1，输入两个数，再输入一运算符，得到结果。

	$num1=34;
	$num2=90;
	$oper="*";
	//以后，要计算结果，则可能直接调用函数如下，	
	$res=jiSan($num1,$num2,$oper);
	echo "计算结果是=".$res;	

  ?>
</html>





讨论函数之，和其运行原理
  自定义函数的基本语法结构：

function 函数名(参数列表){
	函数体;(完成某一个功能的指令集合，这个必要)
	return语句;(return语句主要是用来返回一个结果的。这个可有可无)
}







二十九：php页面函数相互调用的知识点；
目前我们有这样一个需求
1,	a.php 页面要b.php 定义的函数，我们可以使用如下指令；
	require  , require_once , include , include_once

	形式： require 的用法。
<?php
	require ("要引入的文件名");
或
	$filePath="abc.php";
	require $filePath;
或
	require "要引入的文件名";

?>


	1,函数的调用；

实例；

b.php   	//被调用的页面
<?php
	function abc(){ 
		echo "这是b.php的页面";
	}
?> 

a.php
<?php
//第一种方式：直接调用；
	//这里调用了b.php 页面
	require "b.php";    
	//这里是调用了b.php 页面的函数 abc();
	abc();

//第一种方式：通过变量引入；
	$fileName = "b.php";   
	abc();

//第三种方式； 和第一种差不多，只是加个括号；
 	require ("b.php");
	abc():
?>


	PHP执行时，一旦遇到函数的调用，就会开辟一个新栈来执行该函数的代码，执行完毕后，
返回继续执行后续代码。 如果函数中还包含有其它函数，则依此类推，再开辟新栈，，，





	2，require()和require_once()的区别和细节
require()不判断是否重复，随着页面执行，require_once()判断是否重复，然后再执行，如重复的话就不执行。
   一般放在PHP页面的最前面。PHP在执行前，就会读入require所引入的文件，一旦出现错误，则退出程序。

   这两个区别为，前者遇到即包含文件，后者会判断是否以经包含过了，如果包含过了，则不再包含文件，
一可以节省资源，二可以避免重复定义的错误。例如：

<?php
	require 'c.php';
	//先判断，再引入，如果发现c.php已经引入，则不再引入.
	require_once 'c.php';
	
?>


	3,include（）和include_once() 的区别

	include "文件名或路径";
	include ('文件名或路径');
	$file = "文件名或路径";
	
	区别
include()不判断是否重复，就执行，include_once()判断是否重复，然后再执行，如重复的话就不执行。

	这两个区别为，前者遇到即包含文件夹，后者会判断是否以经包含过了，如果包含过了，则
不再包含文件，一可以节省资源，二可以避免重复定义的错误。



	4，include 和require的区别 (同_once)
	相同点：都是可以引入别的页面。
	不同点：include如果出现了错误，会继续执行，require出现错误，则会终止程序。	
		require在页面执行时就会被引入，而include是在执行时才会被引入。


	

	小结：做项目的时候，基本上使用的是：require.once
	注意： require_once等应该放在PHP的最前面。或放在被调用的函数前面。




	5，函数的深入：
1，函数的参数列表可以是多个。
2，参数列表可以是多个，并且数据类型可以是任意的类型。
	array,integer,float,boolean,string,object,null,资源类型；
3，函数的命名跟自定义变量一样，首字母只能使用_,A-Z,a-z.
4, 一个自定义函数中的变量是局部的，函数外不生效，
	function abc(){
		$a=45;
		echo $a;
	}
	abc();
	echo 'aa' = $a;
	结果：会报一个错误，没有$a这个变量。 // 因为两个$a在不同的栈里！
5，使用global全局变量的时候，可使用在函数外的变量，
<?php
	$a =12;
	function abc(){
		global $a;
		$a += 45;
	}
	abc();
	echo $a;
?>
	结果等于57。  这个例子就是把全局变量引入到函数中了。
6，函数不区分大小写。function Abc() 等同于 function abc()





	7,unset()释放一个变量：
	如果在函数中，我们不希望使用某个变量，或是希望彻底的不再使用某个变量，则
可以使用 unset(变量名) ,将该变量彻底删除。
<?php
	$a = 34;
	function abc($a){
		unset($a);
		$a = 28;
		echo $a;
	}
	abc($a);
	echo "<hr>";  //结果是 28;
	echo $a;	//结果是 34; 
?>





：
	6，在PHP函数中， 我们可以给某些参数，赋一个默认的值。
function abc($b,$a=2,$c=12){ //这里可以设置三个参数，
	$res=$a+$b;	//计算时可以只计算两个，
	return $res;
}
$e=70;
echo abc($e);
echo abc($e,90);
$f=70;
echo abc($e,$f);







	7,php引用（地址）传递，可以使用 &变量名.
如下。
$a=213;
function abc(&$b){
	$b=314;
}
abc($a);
echo $a;

	总结：如果abc($b) 最后结果 $a是213;但abc(&$b)中加了&,那么abc()虽然开辟了新的栈
但是，却依然延用了$a的老地址，然后在abc($b) 中，又对$b 赋值了314, 所以就等于是把$a 地址
的值改变成为了314.所以abc(&$b)后的 echo $a;的结果是 314.









三十：二进制与位运算 & | ^ ~ >> <<：
二进制：
	所谓二进制就是逢二进一 (0和1) ,因为使用二进制只有 0 和 1 两个数，简单，易于电子
方式实现，同时，通过 0 和 1 组合可以表示任意一个数。
二进制有三个重要的概念；
	1，原码：用二进制来表示一个数，这个码就是原码。
如00000000 00000000 00000000 00000101 = 1*2的零次方 + 0*2的一次方 + 1*2的二次方 = 1+0+4=5
	
	2, 负数的反码 = 它的原码符号位不变，其它位取反 (0变1，1变0)  如例。
-1
-1的原码 10000000 00000000 00000000 00000001 
-1的反码 11111111 11111111 11111111 11111110
-1的补码 11111111 11111111 11111111 11111111

补码返回原码时，再按照顺序倒回去
11111111 1111111 11111111 1111111 -1的被码
11111111 1111111 11111111 1111110  减1后成为反码
10000000 0000000 00000000 0000001  再取反后成为原码

	3,在计算机运算的时候，都是以补码的方式来运算的。



二进制基本概念：
1，二进制的最高位是符号位： 0表示正数，1表示负数。
2，正数的原码，反码，补码都一样。
3，负数的反码=它的原码符号位不变，其它位取反（0变1，1变0）
4, 负数的补码= 它的反码+1
5，0的反码，补码都是0.
6, php没有无符号数，换言之，PHP 中的数都是有符号的。
7， 在计算机运算的时候，都是以补码的方式来运算的。

 
位运算的基本概念：
	PHP中有四个位运算：分别是“按位与 & ,按位或 | . 按位异或 ^ ,按位取反 ~ ；
按位与 & : 两位全为1，结果为1 .
按位或 | : 两位有一个为1 ,结果为 1.
按位异或 ^ : 两位一个为0 ,一个为 1 ，结果为 1. 两个不同时结果为1,相同进结果为0;
按位取反 ~ : 0 变 1, 1 变 0
	    比如：~2 = -3   2&3=2  2|3=3  2^3=1;
php中有移位运算符：
>>   << 算术右移和算术左移，运算规则：
算术右移：低位溢出，符号位不变，并用符号位补溢出的高位。
自述左移：符号位不变，低位补0。


位运算一览表；

例子		名称			结果

$a & $b     And(按位与)		将把$a和$b中都为1的位设为1。
$a | $b     Or (按位或) 	将把$a或者$b中为1的位设为1。
$a ^ $b     Xor(按位异或)	将把$a和$b中不同的位设为1。
~$a	    Not(按位非)		将$a中为0的位设为1，反之亦然。
$a<<$b 	   Shift left(左移)	将$a中的位向左移动 $b 次(每一次移动都表示"乘以 2 ")。
$a>>$b 	   Shift left(右移) 	将$a中的位向右移动 $b 次（每一次移动都表示"除以 2 ").


实例：

5 & 7;
00000000 00000000 00000000 00000101  5原码，反码，补码；
00000000 00000000 00000000 00000111  7原，反，补。
00000000 00000000 00000000 00000101  结果等于 5;
-3 & 9;
10000000 00000000 00000000 00000011   -3原
11111111 11111111 11111111 11111100   -3反
11111111 11111111 11111111 11111101   -3补
00000000 00000000 00000000 00001001   9原，反，补
00000000 00000000 00000000 00001001   结果等于9,这里是正数就不用再取反和减1了。只有负值才需要

3 | 5;
00000000 00000000 00000000 00000011  	3原，反，补
00000000 00000000 00000000 00000101	5原，反, 补
00000000 00000000 00000000 00000111     结果:7 
-8 | 2;
10000000 00000000 00000000 00001000  	-8原
11111111 11111111 11111111 11110111	-8反
11111111 11111111 11111111 11111000	-8补
00000000 00000000 00000000 00000010   	2原，反，补
11111111 11111111 11111111 11111010	补码运算结果
11111111 11111111 11111111 11111001	减1转成反码
10000000 00000000 00000000 00000110	取反转成原码,结果等于-6



00000000 00000000 00000000 00000000
11111111 11111111 11111111 11111111
4 ^ 9;
00000000 00000000 00000000 00000100  4原，反，补
00000000 00000000 00000000 00001001  9原，反，补
00000000 00000000 00000000 00001101  结果：13

-8 ^ 4;
10000000 00000000 00000000 00001000   	-8 原
11111111 11111111 11111111 11110111	-8 反
11111111 11111111 11111111 11111000 	-8 补
00000000 00000000 00000000 00000100 	4原，反，补
11111111 11111111 11111111 11111100	补结果
11111111 11111111 11111111 11111011 	减1转成反码
10000000 00000000 00000000 00000100	取反转成原码 结果：-4;


~8;
00000000 00000000 00000000 00001000     8 原，反，补
11111111 11111111 11111111 11110111	取反
11111111 11111111 11111111 11110110     -1:正数取返需要减1 ，负数取反需加1。
10000000 00000000 00000000 00001001     结果等于9;

~-3;
10000000 00000000 00000000 00000011 	-3 原
11111111 11111111 11111111 11111100 	-3 反码
11111111 11111111 11111111 11111101     +1:正数取返需要减1 ，负数取反需加1。
00000000 00000000 00000000 00000010	结果等于2


8>>3;
00000000 00000000 00000000 00001000     8原反补
10000000 00000000 00000000 00000001     结果1


-9>>2;
10000000 00000000 00000000 00001001      -9原
11111111 11111111 11111111 11110110	 -9反
11111111 11111111 11111111 11110111      -9补
11111111 11111111 11111111 11111101      右移2位
11111111 11111111 11111111 11111100      减1 转成反码
10000000 00000000 00000000 00000011	 结果等于-3


3<<3;
00000000 00000000 00000000 00000011	3原，反，补
00000000 00000000 00000000 00011000      结果：24

-5<<4;
10000000 00000000 00000000 00000101 	-5原
11111111 11111111 11111111 11111010     -5反
11111111 11111111 11111111 11111011     -5补
11111111 11111111 11111111 10110000     补结果
11111111 11111111 11111111 10101111     减1转反
10000000 00000000 00000000 01010000     结果80












三十一： 数组：

提出一个问题？
	一个养鸡场有6只鸡，它们的体重分别是 3kg,5kg,1kg,3.4kg,50kg,请问这六只鸡的体重量是多少？
请你用现在掌握的技术编一个程序，

	现在我们使用现有的技术来解决问题。
array01.php
	$hen1=3;
	$hen2=5;
	$hen3=1;
	$hen4=3.4;
	$hen5=2;
	$hen6=50;

----什么是数组：
	可以用于存放多个数据的数据类型，我们称为数组
使用数组来完成案例；

	$hens[0]=3;
	$hens[1]=5;
	$hens[2]=1;
	$hens[3]=3.4;
	$hens[4]=2;
	$hens[5]=50;
	$hens[6]=20;

$allWeight=0;
//遍历整个数组
//有时为了知道某个数组共有多少个元素，可以使用系统函数 count

	echo "共有".count($hens)."只鸡<br>";
	for($i=0;$i<count($hens);$i++){
		echo "第".($i+1)."只鸡体重=".$hens[$i]."<br/>";
		$allWeight += $hens[$i];
	}
	echo '<br>总体重是='.$allWeight.'平均体重='.$allweight/count($hens);
小结：该案例重点说明数组基本使用。



      

-----数组的创建：

	1，创建数组：
$arr[0]=123;
$arr[1]=90;
$arr[2]=8;

几个概念：
[0] 这个我们称为下标，或者称为关键字。
$arr[0] 这个称为数组的一个元素

$arr[0]=123; 123 表示该$arr[0]元素对应的值。
$arr  这个是该数组的名称。

在PHP数组中，元素存放的值可以是任意数据类型是。
举例说明：

$arr[0]=123;
$arr[1]="hello";
$arr[2]=45.6;
$arr[3]=true;
$arr[4]=null; //即使放入了一个null,也要占一个空间。

echo "数组大小".count($arr);

//遍历一下

	for($i=0;$i<count($i);$i++{
		echo "<br>".$arr[$i];
	}


	2.创建数组的第二种方法
基本语法：
$数组名=array(N个值);

举例说明：

 	$arr=array(1,98,"hello","true","null");
	//遍历一把
	for($i=0;$i<count($arr);$i++){
		echo "<br/>".$arr[$i];
	}

	3.第三种方式创建数组下标，是从0开始编号也可以自己指定。
	
基本语法；
$arr['logo']="北京";
$arr['hsp]=123;
.....
或者
$arr=array("logo"=>"北京","hsp"=>123,4=>678);
案例演示
	$arr[0]=123;
	$arr[1]=90;
	//遍历
	for($i=0;$i<count($arr);$i++){
		echo '<br>'.$arr[$i];
	}


	//这个foreach 适用范围更广
	foreach($arr as $key => $val){
		echo $key."=>".$val."<br>";
	}





------注意事项：

1：创建数组未指定下标，PHP会以最大的那个下标值加 1 作为该元素的下标（关键字）.
	$arr=array(5=>"logo",567,90);
	//要访问“logo”这个值。
	echo $arr[5];
	//要访问 567 这个值；
	echo $arr[6];

2:如果我们给某个元素的下标一样，则会覆盖原来的值。 

	$arr=array(5=>"logo",567,90);
	$arr[5]="yes";//替换某个元素值
	echo $arr[5]; //这时的结果就不是"logo"了，而是"yes".
	echo $arr[6]; // 这个还是不变的。



3: 当以false 和true 做为下标时，那么 false 相当于0, true相当于1.
	如：
	$arr[true]="hello";
	echo $arr[0];  //就会显示“hello”
	$arr[false]="word";
	echo $arr[1];  //就会显示"word";

4：当以 null 做为下标时，那么访问时 null 等同于 " "   
	如：
	$arr[null]="北京";
	echo $arr[null]；
	echo $arr[" "];    它们两个的显示结果都是“北京”。
	echo $arr[];    //但是这样的访问是错误的，下标处不能为空内容。
5：当下标带有小数部分时，默认是取整数部分，如12.4 等同于 12;
	如：
	$arr[12.4]="hhhh";
	echo $arr[12.4];
	echo $arr[12];   //它们的结果都是，hhhh;
    当整数部分相同，小数不同时，后声明的变量值将覆盖前面的；
	如：
	$arr[12.4]="hhhh";
	$arr[12.5]="aaa";

	echo $arr[12.4]; //结果会显示12.5 的aaa.  12.4的hhhh以被覆盖。

6: 显示数组的方式：echo ,print_r(),var_dump()
	echo 只显示指定下标相关的值。
	如：
	echo $arr[0];

	print_r() 同时显示下标与相应的值。
	如：
	print_r($arr);
	Array([1]=>hello [0]=>world []=>北京 [123]=>hhh)

	var_dump() 显示更细致的内容信息
	如：
	var_dump($arr);
array(4) {[1]=>string(5)"hello [0]=>string(5)"world" [""]=>string(6)"北京" [123]=>string(3)"hhh"}



7: 访问数组的时候，不要越界。
	如：
	$arr=array(1,2,43);
		echo $arr[3] ; //数组越界，无法访问到，将提示，notice.




8, 一维数组的引用：
基本语法：
$数组名[键值]；
如果你写的键值不存在，会提示 Notice: Undefined offset



9, 一维数组的使用陷井：

$arr[bar]="hello";
echo $arr[bar];
这样使用会让处理器误认为这是一个常量，所以在引用时一定要加引号，如下：
echo $arr["bar"];



10, php的数组可以动态增长。
	如：
	$a=array(2,3);
	$a[3]=56;
	echo $a[3];  //结果：56 ，这里说明PHP的数组是可以动态增长的，且不一定要按照顺序。
	


11: php的数组相关的函数说明count,is_array,explode。
	1，count($arr) :可以统计该数组共有多少元素。
	2，is_array($arr) :判断变量名是否为一个数组。 
	3, print_r()和var_dump() 可以同时显示数据类型及内容 
	4, explode("&",$arr);以&符号为标记，拆分字符串,
		如：
		$str="北京&顺平&天津";
		$arr=explode("&",$str);
		print_r($arr);
		结果：Array([0]=>北京 [1]=>顺平 [2]=>天津);
	5, sort 函数 用于排序。

12: php数组遍历的四个方法：for(), while(), do_while(), foreach()
!!!如果使用 for,while,do_while时，要确定该数组的下标是以整数形式且按顺序排列不间断的。
$colors=array('red','blue','green','yellow');
	//for()
	for($i=0;$i<count($colors);$i++){
		echo $color[$i];
	}

	//while()
	$i=0;
	while($i<count($colors)){
		echo $colors[$i];
	}

	//do_while()
	$i=0;
	do{
		echo $colors[$i];
		$i++;
	}while($i<$count($colors))

	//foreach()
	foreach($colors as $v=>$k){
		echo $v."=>".$k;
	}
	

	

	

13: unset销毁元素。
	使用unset函数可以销毁某个元素，也可以销毁某个变量，销毁该元素后，
关键字（下标）不会重新组合。

	$arr[0]=123;
	$arr[1]=156;
	$arr[2]="hello";
	/比如现在我要删除$arr[1] 元素
	echo $arr[1];
	unset($arr[1]);
	echo $arr[1];
	//这时$arr[1]以经为空
	echo print_r($arr);
	//显示:Array([0]=>123 [2]=>hello)




12: php数组遍历的四个方法：for(), while(), do_while(), foreach()
13: unset销毁元素。
14： 数组运算符$a + == != <> !== $b：

$a + $b 联合   把$b 的内容加入到$a中，当$a中有的就不加了，没有的就加进去

$a == $b  相等   如果$a和$b 具有相同的键/值对并且顺序和类型都相同则为true

$a!=$b   不等  如果$a 不等于 $b 则为true

$a<>$b   不等  如果$a 不等于 $b 则为true

$a!==$b   不全等 如果$a不全等于$b则为true

例：

$a = array('a'=>'apple','b'=>'banana');
$b = array('a'=>'pear','b'=>'strawberry','c'=>'cherry');

$c = $a+$b ; //把$b数组的键值加到$a中.
var_dump($c); //结果: 'a'=>'apple','b'=>'banana','c'=>'chery'

$c = $b+$a; 
var_dump($c); //结果：'a'=>'pear','b'=>'banana','c'=>'chery'  它会不变，因为$a有的$b全有，



数组案例：
五个小孩比赛滑轮，他们的滑完100米，分别用了10s,12s,5.7s,9s,14s,请编写一个程序，计算他们的
平均时间。 时间保留小数点后两位。

<body>
	<form action="result.php" method="post">
		<input type="text" name="grade" />	
		<input type="submit" value="开始统计" />
	</form>
</body>

result.php页面：
<?php
	//接收用户提交的学生的成绩
	$grades=$_REQUEST['grade'];
		//echo 'grade='.$grades;	
	$grades=explode(" ",$grade);   //拆分，对成绩进行分割
	$allGrades=0;
	//遍历
	foreach($grades as $k=>$v){
		$allGrades += $v;      //隐藏转换，，这里会把字符串转化成数值。
	}
	echo "平均时间是=".$allGrades/count($grades);		


?>





15：如何关闭notice级别的提示。
	1，在PHP.ini文件中改动error_reporting
	改为：error_reporting = E_ALL & ~E_NOTICE
如果你不能操作php.ini文件，你可以用下面的方法来实现。

	2，在你想禁止notice错误提示的页面中加入下面代码
/* Report all errors except E_NOTICE */
error_reporting(E_all ^ E_NOTICE);

	3，在$_REQUEST['XXX'];或$_POST前面加上一个@ 
		如：
		$grades=@$_REQUEST['XXX'];



16: 指定小数点后的位数-round(1.95583,-2)指定精度。
将数值指定精度 例：
<?php
echo round(3.4);   //3
echo round(3.5);   //4
echo round(3.6);   //4
echo round(3.6,0);   //4
echo round(1.95583, -2);   //1.96
echo round(1241757, -3);   //1242000
echo round(5.045, 2);   //5.05
echo round(5.055, 2);   //5.06
?>










三十二：排序法-冒泡，选择，插入，快速排序法：
排序的介绍：  排序是将一组数据，依指定的顺序进行排列的过程，
排序的分类：
	1，内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。
		内排又分：交换式排序法，选择式排序法，和插入式排序法。
	
	2，外部排序法： 当数据量过大，无法全部加载到内存中，需要借助外部存储进行排序；

		外排分：合并排序法和直接合并排序法。
	排序(Sorting) 是数据处理中一种很重要的运算，同时也是很常用的运算，一般数据处理工作
25%的时间都在进行排序，简单地说，排序就是把一组记录（元素）按照某个域的值的递增（即由小到大）
或递减（即由大到小）的次序重新排列的过程。
		

	这里我们介绍一些常用的排序方法，排序是一个程序员基本功，所谓排序就是对一组数据，按
照某个顺序排列的过程。
	
	
	排序分两大类：
一：内部排序：
	1，交换式排序法：
		A;冒泡排序法：
			

	快速排序法：
	选择排序法：
	插入排序法：

二：外部排序：
因数据重大，必须借助外边文件来完成。



冒泡排序法及函数封装：

<?php
-----冒泡排序法；
function bubble($arr){
	$temp=0;
	for($i=0;$i<count($arr)-1;$i++){
		for($j=0;$j<count($arr)-1-$i;$j++){
			if($arr[$j]<$arr[$j+1]){
				$temp = $arr[$j+1];
				$arr[$j+1]=$arr[$j];
				$arr[$j]=$temp;
			}
		}
		//冒泡的优化，当数组是有排列时，可以加入以下代码进行优化。
		if(!$flag){
			//以经是有序
			break;
		}
		$flag=false;
	}

}



//冒泡的优化，当数组是有排列时，可以加入以下代码进行优化。

	if(!$flag){
		//以经是有序
		break;
	}
	$flag=false;


	$abc=array(32,4,838,22,-35,89,43,0,345,2,5,7,88);
	//调用冒泡函数进行排序，，&符号重点，没有&将无法实现调用函数来完成对$abc的排序。
	bubble(&$abc);
	foreach($abc as $k=>$v){
		echo $v."<br>";
	}
	
?>
 ----从上面的案例我们可以看出，数组的默认传递是值，不是地址；




	选择排序法：
	
function selectSort(&$arr){
	$temp=0;
	
	for($i=0;$i<count($arr)-1;$i++){
		$minVal=$arr[$i];    	//假设$i是最小值，或是设定一个基值。
		$minKey=$i;	    	//记录最小数的下标,或记录基值的下标.

		for($j=$i+1;$j<count($arr);$j++){
			if($minVal>$arr[$j]){
				$minVal=$arr[$j];
				$minKey=$j;
			}
		}
		$temp=$arr[$i];
		$arr[$i]=$arr[$minKey];
		$arr[$minKey]=$temp;
	}	
}





	插入排序法：


<?php
function insertSort(&$arr){
	for($i=1;$i<count($arr);$i++){
		$val=$arr[$i];
		$key=$i-1;

		while($key>=0&&$val<$arr[$key]){
			$arr[$key+1] = $arr[$key];
			$key--;
		}
		$arr[$key+1] = $val;
	}
}


$abc=array(82,3,25,87,35,72,9,337,45,62);
insertSort($abc);
print_r($abc);
?>
	









	快速排序法：


<?php
function quickSort($left,$right,&$array){
	$l=$left;
	$r=$right;
	$pivot = $array[($left+$right)/2];
	$temp=0;

	while($l<$r){
		while($array[$l]<$pivot) $l++;
		while($array[$r]>$pivot) $r--;
		
		if($l>=$r) break;
	
		$temp=$array[$l];
		$array[$l]=$array[$r];
		$array[$r]=$temp;

		if($array[$l]==$pivot) --$r;
		if($array[$r]==$pivot) ++$l;


	}
	if($l==$r){
		$l++;
		$r--;
	}

	if($left<$r) quickSort($left,$r,$array);
	if($right>$l) quickSort($l,$right,$array);
}


	$aaa=array(1,3,88,2,55,42,983,98,873,27);
	quickSort(0,count($aaa)-1,$aaa);
	print_r($aaa);
?>











=====查找：

-----顺序查找：
	对某个数组，按照顺序，一个一个比较，然后找到你要的数据：
案例：
	要求从一个数组 中查找 一个数，如果查找到则输出该数的下标，如果
找不到则输出，查无此数！

<?php
	$arr=array(46,900,0,-1,-1);

function search(&$arr,$findVal){
	$flag=false;	
	for($i=0;$i<count($arr);$i++){
		if($findVal==$arr[$i]){
			echo "找到了，下标为：$i";
			$flag=true;
			break; //这里如果只想找一个就加break,想找更多就不加break.
		}
	}
	if(!$flag){
		echo "查询不到";
	}
}
search(&$arr,0);

?>




	---二分查找法（必须掌握）
	所谓二分查找，它有一个重要的前提，该项数组本身以经是一个有序数组，如果该数组不是有序的，则必须先排序再查找。


<?php
	$arr=array(1,2,3,4,5,6,7,8,9);
function search(&$arr,$v,$l,$r){
	//当$r>$l说明没有数
	if($l>$r){
		echo "查无此数";
		return;
	}
	//找到中间这个数
	$m=round(($r+$l)/2);
	//查找数如果大于中间数，则向后找，
		
	if($v>$arr[$m]){
		search($arr,$v,$m+1,$r);
	}
	//查找数如果小于中间数，则向前找，
	else if($v<$arr[$m]){
		search($arr,$v,$l,$m-1);
	}
	else{
		echo "找到这个数，下标是$m";
	}
}

search($arr,83,0,count($arr));

?>








======多维数组-二维数组

-----二维数组的基本语法：

$arr=array(array(1,2,3),array(5,6,7));

$arr[0] = array(1,2);

快速入门案例：

请用二维数组，输出如下图形：

0 0 0 0 0 0 
0 0 1 0 0 0
0 2 0 0 3 0
0 0 0 0 0 0

//定义一个二维数组

$arr=array(
	array(0,0,0,0,0,0),
	array(0,0,1,0,0,0),
	array(0,2,0,0,3,0),
	array(0,0,0,0,0,0),
	);
//遍历二维数组(行)；
	for($i=0;$i<count($arr);$i++){
		for($j=0;$j=count($arr[$i]);$j++){
			echo $arr[$i][$j]."&nbsp";
		}
		echo "<br>";
	}




=====作业



------游戏机


---以知手掌游戏机一台320元，mp3一台260元。
公司举行抽奖大会，公司有18人，一等奖游戏机，二等奖mp3.
购入5台游戏机，13台mp3.
问总价为多少，公司实际平均给每人花费了多少钱。(4980，276。6666)
<?php
	$gamerPrice=320;
	$mp3Price=260;
	$gamerNum=5;
	$mp3Num=13;

	$totalPrice = $gamerPrice * $gamerNum + $mp3Price * $mp3Num;
	$avgPrice = $totalPrice / 18;

?>







------跳水比赛
8个评委打分，运动员的成绩是8个成绩去掉一个最高分，去掉一个最低分，剩下的6个分数的平均分就是最后得分，使用一维数组实现打分功能。
解题：
<?php
	$arr=array(90,23,89,100,2,5,89,44);
	//这里有一个思路，如果只想知道最低分和最高分是多少，则可以排序
	//找出给出最低分的裁判
	//该函数可以返回给出最低分的裁判的下标
function findMin($arr){
	$minFen=$arr[0];
	$minIndex=0;
	for($i=1;$i<count($arr);$i++){
		//下面条件成立，说明$i裁判给出的成绩更低。
		if($minFen>$arr[$i]){
			$minFen=$arr[$i];
			$minIndex=$i;
		}
	}
}
?>














	PHP面向对象编程：
--类和对象的区别和联系：
	1， 类是抽象的，概念的，代表一类事物，比如人类，猫类。	
	2， 对象是具体的，实际的，代表一个具体事物。
	3， 类是对象的模板，对象是类的一个个体实例。


快速体验案例；
<?php
	class Cat{
		public $name;
		public $age;
		public $color;

	//创建一只猫
	$cat1=newCat();
	$cat1->name="小白";
	$cat1->age=3;
	$cat1->color="白色";
	$cat2=newCat();
	$cat2->name="小花";
	$cat2->age=100;
	$cat2->color="花色";
	//如果我们找到一只猫，只要找到$cat1,那么该变量所有相关的属性都通通的找到
	$findCatName="小花";
	if($cat2->name=$findCatName){
		echo $cat2->name."||".$cat2->age."||".$cat2->color;
	}
}
		//定义一个人类
	claa Person{
		public $height;
		public $weight;
		public $age;
		//,,,,,
	}
	$p1=new Person();
	$p1->height=189;
	$p1->weight=100;
	$p1->age=20;



?>



	


====面向对象编程：


-----成员属性的说明：

1，成员属性是从某个事物提取出来的，它可以是，基本数据类型（整数，小数，字符，布尔等）,
	也可以是复合数据类型（数组，对象）

<?php
	class Cat{
		public $name;
		public $age;
	}
	//创建对象：
	$cat1=new Cat;
或
	$cat1=new Cat();
	

?>





2, 怎样访问一个成员属性（其它成员属性是public）
基本语法是:
	$对象名->属性名;

	如果一个文件，专门用于定义类，则命名规范应当这样。
	
		类名.class.php  如: cat.class.php



-----分析对象在内存中存在的形式：

class Person{
	public $name;
	public $age;
}

$a=new Person();
$a->name="小明";
$a->age=18;

$b=$a;
echo $b->name;  //结果：小明
echo $b->age;   //结果：18

从上述实例来看，当把$a的值赋给了$b后，其实，$a与$b在内存中所指向的地址是相同的，所以结果也是相同的！



再次说明：
	$a=78;
	$b=$a;
	$b=&$a;
	$b=$b+8;
	echo $a.$b;   当&$a时，结果会相同，因为引用了地址。然则不同。


如果给一个函数传递一个对象，实际上是传递的一个地址：例：

class Person{
	public $name;
	public $age;	
}
$p1=new Person();
$p1->name="aaa";
$p1->age=33;
//函数接收对象时候，究竟是传入值，还是地址？

function test1($p){
	$p->name="小明";
}
test1($p1);
echo $p1->name;




--如果给函数传递的是基本数据类型（整数，小数，布尔，字符），会传递什么呢？

结论：在默认的情况下是传递的值，如果你希望传入地址就在变量前加上 &  .  如下

function test(&$a){

}

在PHP中如果，给一个函数传递的是数组，则默认情况下是传递值（拷贝了新的数组），
如果希望传入地址，则应当，&$数组：



另外：
$a1=array(1,3,5);
$a2=array(2,4,6);
$a=array($a1,$a2);
var_dump($a);
结果：array(2) { [0]=> array(3) { [0]=> int(1) [1]=> int(3) [2]=> int(5) } [1]=> array(3) { [0]=> int(2) [1]=> int(4) [2]=> int(6) } }



$a=array($a1,$a2);
$a1=array(1,3,5);
$a2=array(2,4,6);
var_dump($a);
结果：array(2) { [0]=> NULL [1]=> NULL }

从以上案例来看，一定要注意上下次序的排列！











-----成员方法的讲解：
函数和成员方法关系：
当我们把一个函数写到某个类中，则该函数可以称为成员方法。

成员方法基本语法：
	访问修饰符    function   函数名(形参列表){
	//函数体；
	//return语句（可有可无）
}








====构造方法====


<?
classPerson{
	public $name;
	public $age;	
}

$p1=new Person();
//再给属性赋值
$p1->name='宋江';
$p1->age=33;

//需求在创建一个“人”的对象时，就初始化name 和 age 的构造方法以。


快速入门案例：

class Person{
	public $name;
	public $age;
	public function __construct(){
		echo "我是构造方法";
	}
}

$p1=new Person();

//结果会显示“我是构造方法以”.这里一旦new的类中有了构造方法，就会被直接调用，
构造方法没有返回值，它是自动被调用的。




----构造方法的两个版本

在php5中一个类可以同时拥有两种形式的构造方法。一种是PHP4版本的，一种是PHP5版本的。
	如：
class Person{
 function __construc(){}   //PHP5版本构造方法
 和  
 function Person(){}	//php4版本构造方法
}

	当两个构造方法同时存在时，优先调用 __construct(). 请大家以后使用 __counstruct
因为老版本的构造方法名必需与类名一致，而新版的__construct 不需要和类名一致！





――this的理解
class Person{
	public $name;
	public $age;
	public function __construct($name,$age){
		//下面的$name和$age认为是一个新的变量。不会影响类中上面的name,age.
		//$name=$name;
		//$age=$age;
		$this->name=$name;
		$this->age=$age;
	}
}
$p1=new Person('张清',39);
echo $p1->name;	    结果：张清
$p2=new Person('宋江',30);
echo $p2->name;     结果：宋江

综上，
1，this所指向的是当前对象！
2，this本质可以理解就是这个对象的地址；
3，哪个对象使用到$this,就是哪个对象的地址；
4，$this不能在类外部使用。






----构造方法注意事项：
	1，一旦定义了一个构造函数，默认的构造函数就被覆盖了，
这时在创建对象的时候就要使用自定义的构造函数了。
	2，一个类只能有一个构造函数（不能重载）.






-----构造方法的八点说明：
1，构造方法和类名相同（PHP4），PHP5版的构造方法驹可以和类同名，也可以是__construct()
2, 构造方法没有返回值。
3，主要作用是完成对新对象的初始化，并不是创建对象本身。
4，在创建新对象后，系统自动的调用该类的构造方法。
5，一个类有且只有一个构造方法，在PHP5后虽然__construct()和 类名() 可以共存，但实际也只能使用一个。
6，如果没有给类自定义构造方法，则该类使用系统默认的构造方法。
7，如果给类自定义了构造方法，则该类的默认构造方法被告覆盖。
8，构造方法的默认访问修饰符是public.



-----构造方法案例
<?php

//一：构造方法的PHP5版
class Person{
	public $name;
	public $age;
	public function __construct($a,$b){
		$this->name=$a;
		$this->age=$b;
		echo "我是构造方法";
	}
}

$a = new Person('aaa',88);
echo $a->name;
echo $a->age;
echo "<br>";
$b = new Person('bbb',22);
echo $b->name;
echo $b->age;
echo "<hr><hr><hr>";


?>
// 构造方法的PHP4版
<?php
class One{
	public $name;
	public $age;
	public function One($aaa,$bbb){
		echo "这是PHP4版的构造方法！";
		$this->name=$aaa;
		$this->age=$bbb;
	}
}

$a=new One('li',83);
echo "<br>";
echo $a->name."<br>";
echo $a->age;

?>





=====析构方法 __destruct====

析构方法(__destruct)的作用主要用于，释放资源（比如释放数据库的链接，图片资源，销毁某个对象）。

快速入门：
<?php
	class Person{
		public $name;
		public $age;
		//构造方法
		public function __construct(){
			$this->name=$name;
			$this->age=$age;
		}
		//写一个析构方法 __是两个下划线
		function __destruct(){
			echo $this->name."销毁资源<br>";
		}
		$p1=new Person('贾宝玉',16);
		$p2=new Person('林黛玉',14);
	
	}
?>

	运行代码我们得出：
1，析构方法会自动调用
2，析构方法主要用于销毁资源
3，析构方法调用顺序是，先创建的对象后被销毁，
4，析构方法什么时候被调用？
	A：当程序（进程结束）退出时。
	B：当一个对象称为垃圾对象的时候，该对象的析构方法也会被调用。
	C：所谓垃圾对象，就是指，没有任何变量再引用它。
	D：一旦一个对象成为垃圾对象，析构方法就会立即调用。


类的析构方法小结：
1，PHP5加入的析构方法 function __destruct()
2, 析构方法没有返回值。
3，主要作用是释放资源的操作，并不是销毁对象本身。
4，在销毁对象前，系统自动调用该类的析构方法。
5，一个类最多只有一个析构方法。










====静态变量====
提出一个问题
说：有一群小孩在玩堆雪人，不时有新的小朋友加入，请问如何知道现在有多少人在玩？
请用面向对象的思想，编写程序解决。

思路：
----使用全局变量
----使用静态变量。

	全局变量案例：
<?php
	//定义，玩游戏的全局变量
	global $global_nums;
	$global_nums=0;     //全局变量要先初始化后赋值，不然报错。
	class Child{
		public $name;
		function __construct($name){
			$this->name=$name;
		}

		public function join_game(){
			global $global_nums;
			$global_nums += 1'
			echo $this->name."加入堆雪人游戏";
		}
	}
	//创建三个小孩
	$child1=new Child('aaa');
	$child1->join_game();
	$child2=new Child('bbb');
	$child2->join_game();
	$child3=new Child('ccc');
	$child3->join_game();
	
	//看看有多少人在玩游戏
	echo "<br>有".$global_nums;
?>



	静态变量案例：
<?php
	class Child{
		public $name;
		//这里定义并初始化一个静态变量 $nums;
		public static $nums=0;
		function __costruct($name){
			$this->name=$name;
		}
		
		public function join_game(){
			//self::$nums 使用静态变量
			self::$nums += 1;
			echo $this->name."加入堆雪人游戏";
		}
		//创建三个小孩

		$child1=new Child('aaa');
		$child1->join_game();
		$child2=new Child('bbb');
		$child2->join_game();
		$child3=new Child('ccc');
		$child3->join_game();
		//看看有多少人玩
		echo "<br>有".Child::$nums;
	}
?>

	静态变量案例2；


<?php
class Person{
	public $name;
	public static $nums;
	public function join($aaa){
		$this->name=$aaa;
		self::$nums +=1;
		echo $this->name.'加入了游戏<br>';
		echo "现在有 ".self::$nums." 人在游戏<br>";
	}
}
$a=new Person();
$a->join('aaa');
$a->join('bbb');
$a->join('ccc');
?>








	静态变量是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

----如何定义静态变量----
	 
		访问修饰符 static 变量名：

----如何访问静态变量----

在类外部: 	类名::$类变量名
在类内部:	self::$变量名 或者 类名::$类变量名
如果在类中访问，有两种方法 (self::$静态变量名,  类名::$静态变量名)
如果在类外访问，有一种方法 ( 类名::$静态变量名	)

public static $nums=0;  //这里定义一个静态变量，并初始化。
self::$ums +=1;  //这里是使用了静态变量。











=====静态方法

需求：当我们操作静态变量的时候，我们可以考虑使用表态方法，比如统计所有学生交的学费。
在我们编程中，我们往往使用静态方法去操作静态变量。

静态方法的特点：
1，静态方法去操作静态变量，
2，静态方法不能操作非静态变量。

这里请注意，普通的成员方法即可以操作非静态变量，也可以操作静态变量。


----什么时候需要用到表态变量？
	案例：定义学生类，统计学生共交多少学费，用类变量（静态变量），属于公共类的属性。

----表态变量与普通变量的区别：
1，加上static称为类变量或静态变量。否则称为实例变量或普通变量。
2，类变量是与类相关的，公共的属性。
3，实例变量属于每个对象个体的属性。
4，类变量可以通过，类名::$类变量名 或 self::$类变量名称  直接访问。

<?php
class Student{
	public static $name;
	public static $price;
	public static $count;
	function __construct($name){
		self::$name = $name;
	}
	public static function counts($price){
		self::$price += $price;
		echo self::$name."上交的学费是 ".$price;
		echo "<br>学生们交的费用总共为：".Student::$price."<br>";
	}
}
$s = new Student('小红');
$s->counts(123);
$s1 = new Student('小丽');
$s1->counts(222);
?>










=====面向对象的三大特征

1，封装 
2，继承
3，多态


====封装====


-----php的三种访问控制：
1，public 表示全局中，可以在本类，外部类，子类，中使用。
2，protected 表示受到保护，可以在本类，子类中使用
3，private 表示私有，只能在本类中使用

这三个控制修饰符号不仅可以修饰，属性，也可以修饰方法。
	1，如果一个方法没有访问修饰符，则默认是public 
	2, 属性，必须指定访问修饰符。不加则默认为私有。	




----封装的访问控制修饰符：
如果要访问protected和private 修饰成员变量，我们也可以用下面的方法以；
	PHP为我们提供了一对方法:
		: __set(), __get()

	__set()对protected 或是private属性，进行赋值操作。
		如：__set($name,$value);

	__get()读取protected或者private属性的值
		如: __get($name)




 ?我们现在就想去访问protected 变量或者private 变量,通常的做法是提供public 函数去访问这些变量。
一般有三种形式：
	一：public function setXxx($val){
	    }
	
	二：public function getXxx(){
	    }

	三：-----用__set方法管理所有属性（魔术方法）见下例
	







<?php
class Person{
	public $name;
	protected $age;
	private $salary;
//获取这个人受保护的薪水信息
	public function getSalary($user,$pass){
		if($user=="abc" && $pass=="123"){
			return $this->$salary;
		}else{
			return "sorry,你无法看";
		}
	}

//修改年龄，对输入信息，进行校验
	public function setAge($age){
		if($age>1 && $age<100){
			$this->age=$age;
		}else{
			echo "年龄范围不对";
		}
	}
//查看年龄
	public function getAge(){
		return $this->age;
	}
$p1 = new Person();
echo $p1->name;
echo $p1->getSalary('abc','123';
}

?>




-----成员方法间的调用要以$this的方式

<?php
class One{
	function test1(){
		echo "这是方法test1<br>这是调用了，，，";
		$this->test2();
	}
	function test2(){
		echo "这是方法test2<br>";
	}
}

$a = new One();
$a->test1();
?>







-----用__set方法管理所有属性（魔术方法）
这两个方法是为在类和他们的父类中没有声明的属性而设计的。
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名。
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性(即没有权限访问的属性)。
总结： 
1. 从一个难以访问的属性读取数据的时候 __get() 方法被调用 
2. 向一个难以访问的属性赋值的时候 __set() 方法被调用 
3. 难以访问包括：（1）私有属性，（2）没有初始化的属性 
4. __isset() __unset() 也类似 

<?php
class One{
	private $n1;
	private $n2;
	function __set($pro_name,$pro_val){
		$this->pro_name=$pro_val;
	}
	function __get($pro_name){
		if(isset($pro_name)){
			return $this->pro_name;
		}else{

			return null;
		}
	}
}
$a = new One();
$a->n1="aaaaaaaa";
echo $a->n1;
$a->n2="bbbbbbbb";
echo "<br>".$a->n2;
?>









=====继承=====
所谓继承就是一个子类，通过 extends 父类，把父类的(public / protected) 属性和方法继承下来，
但不可以继承私有的属性和方法(private)

继承的基本语法是：

class 类名 extends 父类名{
	//加入自己需要的属性和方法
}



----继承的细节：
	1，父类的 public,protected 的属性和方法被继承 private 的属性和方法没有被继承。
	2，一个类只能继承一个父类，（直接继承）,如果你希望继承多个类的属性和方法，则使用多层继承。
	例：
class A{
	public $n1=90;
}
class B extends A{
	public $n2='hello';
}
class C extends B{
		
}
$c = new C():
echo $c->n1;
echo $c->n2;

	3, 当创建子类对象的时候，默认情况下，不会自动调用父类的构造方法。
<?php
class A{
	public function __construct(){
		echo "A __construct()";
	}
}
class B extends A{
	function __construct(){
		echo "B __construct()";
	}
}
$b = new B();
?>

	4,如果我们希望去调查用父类的构造方法，或者其它的方法(public/protected)
可以这样处理：
		1，类名::方法名();
		2, parent::方法名();
如：

<?php
class A{
	public $n1=90;
	public function __construct(){
		echo "A __construct()";
	}
}
class B extends A{
	function __construct(){
		echo "B __construct()";
		//A::__construct(); 	//调用父类的构造方法1
		parent::__construct();  //调用父类的构造方法2
	}
}
$b = new B();
?>













====魔术方法（函数）与魔术常量====

	----魔术方法（函数）

1. __construct() 	实例化对象时被调用；
	当__construct和以类名为函数名的函数同时存在时，__construct将被调用，另一个不被，，

2. __destruct()		
	当删除一个对象或对象操作终止时被调用；

3. __call()
	对象调用某个方法,若方法存在，则直接调用，若方法不存在，则会调用__call函数。

4. __get()
	读取一个对象的属性时，若属性存在，则直接返回属性值；若不存在，刚会调用__get函数。

5. __set()
	设置一个对象的属性时，若属性存在，则直接赋值。若属性不存在，则会调用 __set()函数。

6. __toString()
	打印一个对象的时候被调用。 如echo $ohj;或pring $obj;

7. __clone()
	克隆时被调用。如: $t = new Test();$t1=clone$t;

8. __sleep()
	serialize之前被调用。若对象比较大，想删减一点东西再序列化，可考虑一下此函数。

9. __wakeuo()
	unserialize时被调用，做些对象的初始化工作。

10. __isset()
	检测一个对象的属性是否存在时被调用。 如: isset($c->name);

11. __unset()
	unset一个对象的属性时被调用，如: unset($c->name);

12. __set_state()
	调用var_export时，被调用，用__set_state的返回值做为var_export的返回值.

13. __autoload()
	实例化一个对象时，如果对应的类不存在，则该方法被调用。




	----魔术常量:

1. __LINE__
	返回文件中的当前行号。

2. __FILE__
	返回文件的完整路径和文件名。如果用在包含文件中，则返回包含文件名。自php4.0.2起，__FILE__总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。

3. __FUNCTION__
	返回函数名称（PHP 4.3.0 新加）. 自PHP5起本常量返回该函数被定义时的名字（区分大小写）.在PHP4中该值总是小写字母的。

4. __CLASS__
	返回类的名称（PHP4.3.0新加）.自PHP5起本常量返回该类被定义时的名字（区分大小写）。在PHP4中该值总是小写字母的。


5. __METHOD__
	返回类的方法名(PHP5.0.0新加).返回该方法被定义时的名字（区分大小写）。	

6. __DIR__
	文件所在目录。如果用在被包括文件中，则返回被包括的文件所在目录。它等价于dimame(__FILE__).除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0 中新增）

7. __NAMESPACE__ 
	当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增）


--------------------------------------------------------------

从PHP 5以后的版本，PHP中的类就可以使用魔术方法了。其规定以两个下划线(__)开头的方法都保留为魔术方法，所以建议大家函数名最好不用__开头，除非是为了重载已有的魔术方法。


	----	__get、__set

这两个方法是为在类和他们的父类中没有声明的属性而设计的。
__get( $property ) 当调用一个未定义的属性时，此方法会被触发，传递的参数是被访问的属性名。
__set( $property, $value ) 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性(即没有权限访问的属性)。



	----	__isset、__unset

__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法。
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法。
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性(即没有权限访问的属性)。



	----	__call

__call( $method, $arg_array ) 当调用一个未定义的方法是调用此方法。
这里的未定义的方法包括没有权限访问的方法;如果方法不存在就去父类中找这个方法，如果父类中也不存在就去调用本类的__call()方?法，如果本类中不存在__call()方法就去找父类中的__call()方法。


	----	__autoload

__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。
如果要定义一个全局的自动加载类，则必须用spl_autoload_register()方法将处理类注册到PHP标准库：


复制代码 代码如下:
<?php
class Loader   
 {          
    static function autoload_class($class_name)        {          
    //寻找正确的$class_name类，并引入，没有则抛出异常          
     }         
 }      
/** 
*  设置对象的自动载入        
*  spl_autoload_register ― Register given function as __autoload() implementation       
*/   
spl_autoload_register(array(‘Loader', ‘autoload_class'));   
 $a = new Test();//Test没用require就实例化，实现自动加载，很多框架就用这种方法自动加载类

注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误，所以应该在函数本身做捕获。


	----	__construct、__destruct

__construct 构造方法，当一个对象创建时调用此方法，相对于PHP4使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称。
__destruct 析构方法，PHP将在对象被销毁前(即从内存中清除前)调用这个方法。默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源，析构函数允 许你在使用一个对象之后执行任意代码来清除内存。当PHP决定你的脚本不再与对象相关时,析构函数将被调用。
在一个函数的命名空间内，这会发生在函数return的时候。对于全局变量,这发生于脚本结束的时候。如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset。

	----	__clone

PHP 5中的对象赋值是使用的引用赋值，如果想复制一个对象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法，如果在对象复制需要执行某些初始化操作，可以在__clone方法实现。


	----	__toString

__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时。
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in，此方法必须返回一个字符串。
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效(例如通过printf()，使用%s修饰符)，但 不能用于非字符串环境(如使用%d修饰符)。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。

	----	__sleep、__wakeup

__sleep 串行化的时候用
__wakeup 反串行化的时候调用
serialize() 检查类中是否有魔术名称__sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。
使用__sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。


	----	__set_state

当调用var_export()时，这个静态 方法会被调用(自PHP 5.1.0起有效)。
本方法的唯一参数是一个数组，其中包含按array('property' => value, …)格式排列的类属性。


	----	__invoke(PHP 5.3.0以上版本有效)

当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。


	----__callStatic(PHP 5.3.0以上版本有效)

它的工作方式类似于__call() 魔术方法，__callStatic() 是为了处理静态方法调用。
PHP 确实加强了对 __callStatic() 方法的定义;它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此













====重载=====
	基本概念：函数名一样，通过函数的参数个数或者是参数类型不同，达到调用同一个函数名，但是可以区分不同的函数。


class A{
	public function test1(){
		echo "test1";
	}
	publc function test1($a){
		echo "test1 hello";
	}
}
$a = new A();
$a->test1();
$a->test1(456);

上面的用法是不对的,PHP5中如何通过魔术函数来实现方法重载的效果，如下！


<?php
class A{
	public function test1($p){
		echo "$p是一个数组，接收一个参数<br>";
		var_dump($p);
	}
	public function test2($p){
		echo "<br>$p接收两个参数<br>";
		var_dump($p);
	}
	//当对象调用某个方法，而该项方法不存在时，则系统会自动调用__call
	function __cal($method,$p){
		var_dump($p);		//这里看一下传进来的值是什么。
		if($method=="test"){
			if(count($p)==1){
				$this->test1($p);
			}else if(count($p)==2){
				$this->test2($p);
			}
			
		}

	}
}
$a =new A();
$a->test(1);
$a->test(56,90);


?>

重载的小结：
	1,php5默认情况下不直接支持方法重载。
	2，php5可以用__call魔术方法，模拟一个方法效果的效果。











=====方法的重写/方法的覆盖(override)

1，重写时，子类的方法的名和参数列表要与父类相同。
2，如果子类要调用父类的某个方法时，必须是public或protected级别的，有两种方式：
	A： parent::方法名；
	B： 父类名::方法名(参数);
3, 在实现方法覆盖时，访问修饰符可以不一样，但子类的访问权限必须大于或等于父类的权限。





<?php
	echo "方法的重写<br>";
class Animal{
	function cry(){
		echo "动物的叫声<br>";

	}
}
class Cat extends Animal{
	function cry(){
		echo "小猫喵喵叫<br>";	//这里覆盖了父类的此方法。
		parent::cry();		//调用父类方法一;
	}
}
class Dog{
	function cry(){
		echo "小狗汪汪叫<br>";
		Animal::cry();		//调用父类方法二;
	}
}
$cat = new Cat();
$cat->cry();
$dog = new Dog();
$dog->cry();
?>











=====抽象类=====

为什么设计抽象类这个技术？
	在实际开发中，我们可能有这样一类，是其它类的父类，但是它本身并不需要实例化，主要用途是用于让子类继承，这样可以达到代码复用，同时利于项目设计者，设计类。

	1,基本用法：
		abstract class 类名{
			// 方法（可以是抽象方法，也可以是普通方法）
			// 属性
		}
	2，如果一个类使用abstract 来修饰，则该类就是抽象类，如果一个方法被abstract修饰，则该方法叉是抽象方法.(抽象方法不能有方法体)
	3, 抽象类可以没有抽象方法，同时还可以有实例化的普通方法。
	4, 如果一个类中，只要有抽象方法，则该类必须声明为abstract.
	5, 如果A类继承了一个抽象类B，则要求A类实现从B类继承的所有抽象方法。



abstract class Animal{
	public $name;
	protected $age;
	abstract public function cry();
}
class Cat extends Animal{
	public function cry(){
		echo "猫猫叫，，，";
	}
}
$cat = new Cat();
$cat->cry();












=====接口=====
	1，接口的使用基本语法：
		interface 接口名{
			//属性
			//方法
		}


	2, 接口的方法都不能方法体：
	
	3，如何实现接口
		class 类名 implement 接口名称，接口名2，，，{

		}

接口：它的作用就是声明一些方法，供其它类来实现，接口还体现编程中我们希望的效果，高内聚低耦合的特点。

	4, 什么情况下可以考虑使用接口：
		A；定规范，
		B：定下规范，让其它程序员来实现。比如；

interface StuManageInterface{
	public function addStudent($stu);
	public function delStudent($id);
	public function updStudent($stu);
}
//给张三去实现
class Stu implements StuManageInterface{
	public function addStudent($stu){
		//实现过程
	}
	public function delStudent($id){
		//实现过程
	}
	public function updStudent($stu){
		//实现过程
	}
}

	5, 当多个类，他们之间是平级的关系，且这些类都会去实现某个功能，只是实现的方式不一样，这时就要考虑为这个类定义一个接口。

	6， 接口不能实例化。
	7， 接口中所有的方法，都不能有方法体。
	8， 一个类可以去实现多个接口，每个接口间用豆号隔开  
		如：class 类名 implements 接口1，接口2，，，，{}
	9, 接口中可以有属性，但必需是常量，默认是public 如下：
		interface iUsb{
			const A = 90;
		}
			echo "ok".iUsb::A;
		
	10, 接口中的方法都必须是public的，默认就是public.
	11, 一个接口不能继承其它的类，但是可以继承别的接口。但实现该接口的类要把所有继承的方法都实现。
	12, 一个类在实现接口的时，也可以同时去继承一个类。


<?php
interface  A{
	function aa();	
}
interface B{
	function bb();
}
interface C extends A,B{
	function cc();
}
abstract class F{
	abstract function ff();
}
class D extends F implements C{ //D继承F并实现C
	function aa(){echo "aa";}
	function bb(){echo "bb";}
	function cc(){echo "cc";}
	function ff(){echo "ff";}
}

//$d = new D();
D::aa();
D::bb();
D::cc();
D::ff();
?>




	-----继承和实现接口的比较:
1, 可以认为实现接口是对单一继承的补充。
2，可以在不破坏类层级关系的前提下，对某个类功能扩展。





	-----final 关键字:
1, 如果我们希望某个类不被其它类所继承（因某些因素）,可以使用final.
<?php
	final calss A{}
	class B extendsA{}
	echo "ok";   //结果提示错误，B不能继承A
?>

2, 如果我们希望某个方法，比如计算个人所得税的方法，不能被子类改写，可以使用final来修饰方法。

class A{
	final public function getRate($salary){
		return $salary * 0.08;
	}
}
class B extends A{
	//不能去重写父类的getRate方法
	function getRate($sal){
		return $sal*0.01;
	}
}
$b = new B ();
echo $b->get$ate(100);










	-----常量：const 关键字
1， 常量名一般字母全部大写 如： TAXRATE
2， 在定义常量的同时，必须赋初值 如 const TAXRATE=1.1;
3， const关键字前不能public /protected/private 修饰。
4， 访问常量
	在类外部用	类名::常量名；
	在类内部用	类名::常量名 	或 	self::常量名;
5， 常量的值在定义的时候就初始化，以后就不能修改。
6， 常量可以被子类继承。
7， 一个常量是属于一个类的，而不是某个对象的。

	----const 什么时候用
1， 某些值是固定不变的，比如圆周率3.1415926等。


基本用法：
<?php
	class A{
		const 常量名= 初值;
	}
	interface 接口名{
		const 常量名 = 初值;
	}
?>


常量是public 级别的,调用的方式为
	类名::常量名;
或
	接口名::常量名;
或
	self::常量名；  //意思是调用本类或本接口的常量



案例：
class A{
	//常量在定义的时候，必须给初值
	//const 关键字前面不要带修饰符。

	const RATE = 0.08;

	public function payRate($val){
		//常量不能修改
		// A::RATE=0.01;
		//return $val * A::RATE;	调用常量的一种方式
		return $val * self::Rate;  //调用常量的self方式
	}
	$a = new A();
	echo $a->payRate();
}







---------------------------------------------------------------------------------



=====用面向对象的方式做计算器项目====
----script函数-isNaN 检测是否为一个数值----

	面向对象设计的浅显解析：
		A:由一个前台页面来面向客户操作；
		B:由一个中间控制页面，来接收数据并调用相应的对象方法；
		C:由一个或多个页面以对象的方式封装类和方法，供中间控制页面调用。
		案例如下：

	一：前台页面文件：
<html>
<head>
	<title>计算器</title>
	<script language="javascript">
		function check(){
			var num1val=document.getElementById("num1").value;
			var num2val=document.getElementById("num2").value;
			//alert(num1val+" "+num2val);  获取两个输入框的值。
			//isNaN检测该值是否为数值，不是数值返回true.
			if(isNaN(num1val) || isNaN(num2val) ){	
				alert("请输入正确的数值");
				//如果返回false就不提交了
				return false;
			} 
		}
	</script>
</head>
<body>
	<h1>四则运算器</h1><br>
	<form action="console.php" method="post" onsubmit="return check()">
第一个数值<input type="next" id="num1" name="num1" /><br>
第二个数值<input type="next" id="num2" name="num2" /><br>
选择运算符<select name="oper">
			<option value="+">+</option>
			<option value="-">-</option>
			<option value="*">*</option>
			<option value="/">/</option>
		</select><br>
			<input type="submit" name="sub" value="提交"/>
	</form>
<body>
</html>


		二：接收控制页面

<?php
	$num1 = $_REQUEST['num1'];
	$num2 = $_REQUEST['num2'];
	$oper = $_REQUEST['oper'];
	require_once 'arithmitec.class.php';
	$ari=new Arithmitec();
	echo $ari->cast($num1,$num2,$oper);
?>
<br><a href="desk.php">返回</a>


		三：对象方法封装类页面

<?php
class Arithmitec{
	function cast($num1,$num2,$oper){
		switch($oper){
			case '+':
				return $num1+$num2;
				break;
			case '-';
				return $num1-$num2;
				break;
			case '*';
				return $num1*$num2;
				break;
			case '/';
				return $num1/$num2;
				break;
			default:
				echo "输入错误，请重新输入！";
				break;
		}
	}
}
?>

---------------------------------------------------------------------------------












		=====php中错误和异常处理的机制=====


-----什么是相对路径和绝对路径；
	绝对路径：是从C盘开始出发向下依次找到当前文件如：
		“c:/aaa/bbb/a.jpg” 

	相对路径：是从文件所在当前文件夹出发开始找目标文件，如：
		"../../aaa/bbb/b.mp3"	 “../”代表向上一级文件夹。




-----如果没有错误处理机制怎样？

<?php
	$fp = fopen("aaa.txt","r");  //这里是打开一个文件。
	echo "ok";
?>

	上面代码没有处理错误，应当这样写程序更加键壮。

<?php
	if(!file_exists("aaa.txt")){
		echo "文件不存在！";
	}else{
		echo "文件打开成功";
		//...关闭
		fclose($fp);
	}
?>	


-----PHP处理错误的三种方法：

	1。使用简单的 die 语句
		使用方法如下：
die()的第一种方式：
	if(!file_exists("aaa.txt")){
		die("文件不存在！");
	}else{
		//打开文件操作
		echo "文件找到了<br>";
		$a = fopen("../function.php","r");
	}
	echo "ok";
die()的第二种方式：
	file_exists("aaa.txt") or die("文件不存在・");






	-----PHP自定义错误处理
	w3c手册位置--服务器脚本--PHP--PHP高级--PHP错误处理

在php中对错误有不同的级别区分大体可分为两种，一种是普通警告型，虽会报错但它不阻断程序的运行。
而另一种是致使错误，一旦出现就程序会被立刻中断。

案例入门：

<?php
	//定义一个函数
	function my_error($errno,$errmes){  //这两个变量代表的一个是错误号，一个是错误信息
		echo "<font size='5' color='red'>$errno</font><br>";
		echo "错误信息是：$drrmes";
		exit();
	}
	function my_error2($errno,$errmes){  //这两个变量代表的一个是错误号，一个是错误信息
		echo "<font size='5' color='red'>$errno</font><br>";
		echo "错误信息是：$drrmes";
		exit();
	}
	//改写 set_error_handler处理器
	set_error_handler("my_error",E_WARNING);
	set_error_handler("my_error2",E_NOTICE);
	$fp = fopen("aa.txt","r");
?>








	-----错误触发器
需求：有一段代码，如果接受一个年龄，如果年龄输入>120.我认为就是一个错误。
如：
//传统方法
if($age>120){
	echo "年龄过大";
	exit();
}
或需求：输入一个薪水，如果大于10000,我认为有错误
if($salary>10000){
	echo "薪水多";
	exit();
}


	现在我们可以使用自定义错误触发器来完成。

function error3($errno,$errmes){
	echo "错误号是".$errno;
}

function error4($errno,$errmes){
	echo "出大事了".$errno;
}
//指定E_USER_WARNING错误级别的函数
set_error_handler("error3",E_USER_WARNING);
set_error_handler("error4",E_USER_ERROR);

$age=700;
if($age>120){
	//调用触发器时候同时指定错误级别
	trigger_error("输入年龄过大".E_USER_ERROR);
	exit();
}
echo "ok";



		错误处理器及触发器综合案例

<?php
//$num代表错误代号，$for代表错误信息，$file代表错误文件，
//$line代表错误行数,$con代表发生错误时所用的每个变量和值。
	//以下是定义错误的函数
	function ewarning($num,$for,$file,$line,$con){
		echo "错误代号：".$num;
		echo "<br>错误信息：".$for;
		echo "<br>错误文件名为：".$file;
		echo "<br>错误行数为：".$line;
		echo "<br>错误内容：".$con;
	}
	function enotice($num,$for,$file,$line,$con){
		echo "错误代号：".$num;
		echo "<br>错误信息：".$for;
		echo "<br>错误文件名为：".$file;
		echo "<br>错误行数为：".$line;
		echo "<br>错误内容：".$con;
	}
	function eerror($num,$for,$file,$line,$con){
		echo "错误代号：".$num;
		echo "错误信息：".$for;
		echo "错误文件名为：".$file;
		echo "错误行数为：".$line;
		echo "错误内容：".$con;
		exit();
	}
	//以下是启用自定义错误的函数
	set_error_handler("ewarning",E_USER_WARNING);
	set_error_handler("enotice",E_USER_NOTICE);
	set_error_handler("eerror",E_USER_ERROR);

	//以下是在实际应用中触发了自定义的错误函数
	if(file_exists("one1.txt")){
		echo "文件以打开";
		$a = fopen("one.txt","r");
	}else{
		//错误触发器的应用
		
		trigger_error("warning级警告！，文件未找到！",E_USER_WARNING);
		trigger_error("notice级注意！没有此文件！",E_USER_NOTICE);
		trigger_error("error级文件找不到",E_USER_ERROR);
	}
	echo "<br>试验自定错误及触发器・・！";
?>









	====php错误日志的保存====

基本用法是使用：error_log来实现

function err($errno,$errmes){
	$err_info="错误号是".$errno."--".$errmes;
	echo $err_info;
	//把这个错误信息保存.
	// \r\n表示向文件输入一个回车，一个换行。
	error_log($err_info."\r\n",3,"d:/myerr.txt");


}

	----保存日志时间----
	date_default_timezone_set("Asia/chongqing")
<?PHP
	function en($a,$b){
		$info = "错误代号=".$a."错误信息=".$b;
		echo $info;
		date_default_timezone_set("Asia/Chongqing");
		error_log($info.date("Y-m-d G-i-s")."\r\n",3,"D:/one.txt");
	}
	set_error_handler('en',E_USER_NOTICE);

	if(file_exists('two.php')){
		$f = fopen('two.php');
	}else{
		trigger_error('notice，无此文件！',E_USER_NOTICE);
	}
?>










	=====PHP中的异常处理=====
	php手册：语言参考--异常处理；

class Exception{
	protected	$message = "Unknown exception"; //异常信息
	protected	$code = 0; 			//用户自定义异常代码
	protected	$file;				//发生异常的文件名
	protected	$line;				//发生异常的代码行号
	function __construct($message = null,$code = 0);
	final function getMessage();			//返回异常信息
	final function getCode();			//返回异常代码
	final function getFile();			//返回发生异常的文件名
	final function getLine();			//返回发生异常的代码行号；
	final function getTrace();			//backtrace()数组
	funal function getTraceAsString();		//已格成化成字符串的getTrace()信息。


}	



1,基本语法：
	try{
		可能出现错误或异常的代码
	}catch(Exception e){
		//对异常的处理有两种方式
			1,自己处理。
			2，自己不处理，将其抛出。
	}


思考一个问题？
	怎样可以去有效的控制多条可能出现错误或是异常的代码？
	现在我们看看使用异常处理机制。怎样做！！！


try{
	addUser("aaaa");
	updateUser('bbbb');
}
//catch 捕获  Exception是异常类(php定义好一个类)
catch(Exception $e){
	echo "失败信息".$e->getMessage();
}

function addUser($username){
	if($username=="shunping"){
		//添加成功
	}else{
		//添加error
		//抛出异常
		throw new Exception("添加失败");
	}
}
function updateUser($username){
	if($username=="xiaoming"){
		//正常修改
	}else{
		throw new Exception("修改失败");
	}
}




	----异常使用的注意事项；
1，通过上面的案例，我们看出，使用
	try{代码}catch(Exception $e){处理异常}
这种方式，可以更有效的控制错误，所以在开发中大量的使用。

2，当捕获到一个异常后，try()块里的后续代码就不继续执行了。
3，如果有一个异常发生，但是你没有 catch 捕获，则提示一个Uncatched Exception 或Uncaught Exception
4, 当cacth 一个异常，你可以处理，也可以不处理，再次抛出。如下：
	try{
		a2("hello");
	}catch(Exception $e){
		echo $e->getMessage();
		throw $e;
	}

5, 你可以自定义异常类
	class MyException extends Exception{}

6,使用多个catch 代码块可以捕获不同种类的异常。
	class MyException1 extends Exception{}
	class MyException2 extends Exception{}
	function A(){
		throw new Exception1("a");
	}
	function B(){
		throw new Exception2("b");
	}
	function C(){
		try{
			A();
			B();
		}catch(Exception1 $e1){
			$e1->getMessage();
		}catch(Exception2 $e2){
			$e2->getMessage();
		}
	}


7, ---对于一些老版本的代码，异常捕获机制，并不会抛出异常。

	try{
		$i=8/0;
		$f = fopen("sss.txt");//并没有这个文件
	}catch(Exception $e){
		ehco "ok";
		echo $e->getMessage();
	}
	上面的代码并不会执行“OK”，原因是$i=8/0,并没有抛出异常。所以，能不能catch 到异常，要取决于有没有真的抛出异常！





function checkNum($val){
	if($val>100){
		throw new Exception("err_no1:这个数过大");
	}else{
		echo "输入的值是正常的";
	}
}
try{
	checkNum(300);
}catch(Exception $e){
	echo $e->getMessage()."--".$e->getLine();
}







	-----定义及修改默认顶级异常处理器
	function my_exception(){			//定义一个顶级异常处理器
		echo "我的顶级异常处理器！";
	}
	set_exception_handler("my_exception");		//设置启用自定义处理器
	function aa($a){
		if($a<100){
			echo $a;
		}else{
			throw new Exception("数值太大");
		}
	}
	try{
		aa(200);
	}catch(Exception $e){
		//echo $f->getMessage()."----".$f->getLine();
		throw $e;			//当出现异常再次抛出，把问题交给了顶级异常处理器
	}















	=====XML=====

	-----xml的特性和应用：
1,可以作为程序间通讯的标准(ajax text xml json)
2,可以作为配置文件(php中 用的很多)

	例：
	<?php
		$link = mysql_connect('localhost','root','abcd');
		//php 可以操作 xml
	?>
	配置文件
	<dbinfo>
		<host>11.11.11.11</host>
		<user>shunping</user>
		<type>mysql</type>
		<password>abcd</password>
	</dbinfo>
3.可以做小型数据库。





	-----XML语法:
XML声明放在XML文档的第一行。
XML声明同以下几个部分组成。
	version--文档符合XML1.0规范，我们学习1.0.
	encoding--文档字符编码，
	standalone--文档定义是否独立使用，yes为独立使用,no 为与其它文件有关联，但不影响单独使用!


<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<班级>
	<stu>
		<name>孙悟空</name>
		<sex>男</sex>
		<age>400</age>
	</stu>
	<stu>
		<name>猪八戒</name>
		<sex>男</sex>
		<age>300</age>
	</stu>
</班级>






			-------XML元素1：
A	每个XML文档必须有，且只能有一个根元素。
B	根元素是一个完全包括文档中其他所有元素的元素。
C	根元素的起始标记要放在所有其它元素的起始标记之前。
D	根元素的结束标记要放在所有其它元素的结束标记之后。
E	一个标签中也可以嵌套若干子标签。但所有标签必须合理嵌套，绝对不允许交叉嵌套，
	如：
		<a>welcome to <b>www.aaa.com</a></b>





			----------XML标签的两种形式：
	XML元素指XML文件中出现的标签，一个标签分为开始标签和结束标签，一个标签有如下几种形式。
	如：	
		1，包含标签体：		<a>www.aaa.com</a>
		2，不含标签体的:	<a></a> 简写为：<a/>







			---------XML中的空格和换行会被处理:

	对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。
	如下两例：
		<name> 
			宋江
		</name>
	与
		<name>宋江</name>
	由于在XML中，空格和换行都作为原始内容被处理，所以，在编写XML文件时，要特别注意！




			-------xml标签元素命名规范：
一个XML元素可以包含字母，数字以及其它一些可见字符，但必须遵守下面的一些规范：
	A：区分大小写，例如<A>和<a>是两个不同的标记
	B：不能以数字或“_”（下划线）开头。
	C：不能以XML或xml,Xml等开头。
	D：不能包含空格。
	E：名称中间不能包含冒号（：）。







			-----xml的标签属性

A：属性值用双引号（"）或单引号（'）分隔。
B：一个元素可以有多个属性，它的基本格式为：
	<元素名 属性名="属性值" 属性名="属性值" 属性名="属性值">
c：特定的属性名称在同一个元素标记中只能出现一次。
D：属性值不能包括 <,>,&.
	例：
	<student id="100">
		<name>tom</name>
	</student>


	
		------特殊字符的实体符号
E：如果我们属性值中有 双引号，单引号，可以使用体字符来解决。实体字符后面一定要有分号";"
	< == &lt;
	> == &qt;
	& == &amp;
	' == &apos;
	" == &quot;
	如
	<stu num="a0&apos;0&quot;1">


F：注释的语法 		<!--注释内容-->





		-----XML特殊字符处理 CDATA
XML文件中的某个标签内包含了特殊字符就可以用CDATA来处理.
	CDATA的基本用法：
	<![CDTAT[
		内容，，，
	]]>
如：
	
	<介绍><![CDATA[$%&*(^%)$;KSJ9(*$]]></介绍>
	<头像><![CDATA[*$(@*##@$(@@]]></头像>
面试题：请问如何使用xml文件夹来传递，保存一个图片？
答：使用程序先读入到内存，然后保存到XML文件的<![CDATA[文件内容]]>.





	-----xml中的处理指令PI（process instrution）连接CSS
	处理指令，简称PI。处理指令用来指挥解析引擎如何解析XML文档内容。
	例如，在XML文档中可以使用 xml-stylesheet指令，通知XML解析引擎，应用CSS文件显示XML文档中内容。
		<?xml - stylesheet type="text/css" href="css.css"?>
xml文件也可以使用CSS来修饰，使用pi

<?xml version='1.0' encoding='utf-8'?>
<?xml - stylesheet type="text/css" href="css.css"?>
<all>
	内容
</all>
//这里的CSS用法与HTML中的用法相同。







		=====XML约束概述=====

约束技术有两种，一种是DTD，一种是schema

什么是XML约束：
	在XML技术里，可以编写一个文档来约束一个XML文档的书写规范，这称之为XML约束。
	


		

		-----DTD讲解
DTD的主要用途是约束XML文件，也可去约束html , xhtml,,,,

DTD引入格式：
<!DOCTYPE 根元素名 SYSTEM "DTD文件的路径">


例：
one.dtd页面

<!ELEMENT 班级 (stu+)>
<!ELEMENT stu (name,age)>
<!ELEMENT name (#PCDATA)>
<!ELEMENT age (#PCDATA)>



two.xml

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE 班级 SYSTEM "one.dtd">
<班级>
	<stu>
		<name>aaa</name>
		<age>22</age>
	</stu>
</班级>



three.htaml

<html>
<head>
	<meta http-equiv="content-type" content="text/html;	charset=utf-8"/>
	<script language="javascript">
		<!--
			var xmldoc = new ActiveXObject("Microsoft.XMLDOM");
			xmldoc.validateOnParse = true;
			xmldoc.load("two.xml");
			document.write("错误信息="+xmldoc.parseError.reason+"<br/>");
			document.write("错误的行号="+xmldoc.parseError.line+"<br/>");
		-->
	</script>
</head>
</html>







		=====DTD文档的声明及引用


	-----DTD文档分内部，外部和内外结合结合三种方式：

一：内部DTD文档：
	<!DOCTYPE 根元素 [定义内容]>

二：外部DTD文档：
	<!DOCTYPE 根元素 SYSTEM "DTD文档路径">

三：内外部DTD文档结合:
	<!DOCTYPE 根元素 SYSTEM "DTD文件路径" [定义内容]>


内部DTD案例：

<?xml version='1.0' encoding="utf-8"?>
<!DOCTYPE class [
	<!ELEMENT class (stu+)>
	<!ELEMENT stu (name,age,js)>
	<!ELEMENT name (#PCDATA)>
	<!ELEMENT age (#PCDATA)>
	<!ELEMENT js (#PCDATA)>
]>
<class>
	<stu>
		<name>zxc</name>
		<age>18</age>
		<js>bbb</js>
	</stu>
</class>



	



		-----DTD声明的两种方式：
XML文件使用DOCTYPE声明语句来指明它所遵循的DTD文件，DOCTYPE声明语句有两种形式。

	一：当引用的文件在本地时，采用如下方式：
<!DOCTYPE 文档根结点 SYSTEM "DTD文件的URL">
	例如：<!DOCTYPE 书架 SYSTEM "book.dtd">

	二：当引用的文件是一个公共的文件时，采用如下方式：
<!DOCTYPE 文档根结点 PUBLIC "DTD名称" "DTD文件的URL">
	例如：
	<!DOCTYPE HTML PUBLIC "-//WEC//DTD HTML 4.01 Transitionall//EN"
	"http://www.w3.org/TR/html4/loose.dtd">	






	-----DTD语法及元素：
语法：
	<!ELEMENT NAME CONTENT> 
EMPTY	- 该元素不能包含子元素和文本，但可以有属性-（空元素）
ANY	- 该元素可以包含任何在DTD中定义的元素内容。注意！！！是定义过的，没有定义过的是不行的！
#PCDATA	- 可以包含任何字符数据，但是不能在其中包含任何子元素其它类型（组合）
	
例：

<!ELEMENT 班级 (学生+)>
<!ELEMENT 学生 (名字,年龄,姓别)>
<!ELEMENT 名字 (#PCDATA)>
<!ELEMENT 年龄 (#PCDATA)>
<!ELEMENT 性别 (#PCDATA)>


判断题：
	<!ELEMENT 人 EMPTY>
1:
<家庭>
	<人 名字='皮特' 性别='男' 年龄='6' />
</家庭>	
	这道题是对的!

2.
<家庭>
	<人>皮特</人>
	<人><大人> 皮特的爸爸</大人></人>
</家庭>	









		-----元素修饰符：
() --- 用来给元素分组 	 如：(古龙|金庸|梁羽生)		分成了三组
 | --- 在列出的对象中选择一个.		如:(男|女)	表示男和女必须先一个。 
 + --- 该对象出现至少 1 次或多次  	如:(成员+)	表示成员必须出现，可出现多个.
 * --- 该对象允许出现0到任意次数	如:(爱好*)	爱好可以出现0到任意次
 ? --- 该对象可以出现0到1次		如:(菜鸟?)	可以不出现，如出现最多只能一次.
 , --- 对象必须按指定的顺序出现	  如:(西瓜,苹果,香蕉)	表示必须按照规定的顺序出现。





		-----元素属性列表说明：
基本语法：
<!ATTLIST 元素名称
	属性名 属性类型 属性的特点
	属性名 属性类型 属性的特点
>


属性类型有：
	CDATA		表示属性可以是字符或者是数字
	ID		属性是唯一的，字母开头
	IDREF/IDREFS	id引用 （只能引用以被声明的ID）
	Enumerated	枚举-在几个中选一个，如 男/女 选一个
	ENTITY/ENTITIES	实体

属性的特点：
	#REQUIRED	该属性必须有值
	#IMPLIED	该属性的值可有可无
	#FIXED value 	该属性的值是固定的
	DEFAULT value	如果不给值系统会给一个默认值。



实例：


<学生 住址='香港' 大佬='a002 a003' 国籍="中国" 学号="a001">
	<名字>周星驰</名字>
	,,,,,,,,,,,,,
</学生>


对应的DTD

<!ELEMENT 班级 (学生+，班长)>
	<!ATTLIST 学生
		住址 CDATA #IMPLIED
		学号 ID #REQUIRED
		大佬 IDREFS #REQUIRED
		婚姻状态 (单身|结婚|离婚) #REQUIRED
		国籍 CDATA #FIXED "中国"
	>
<!ELEMENT 学生 (姓名,年龄,介绍)>
<!ELEMENT 姓名 (#PCDATA)>
<!ELEMENT 年龄 (#PCDATA)>
<!ELEMENT 介绍 (#PCDATA)>






		-----实体定义分为引用实体和参数实体，
1,实体定义用于为一段内容创建一个别名，以后在XML文档中就可以使用别名引用这段内容了。像$str="abcd";

2,在DTD定义中，一条<!ENTITY...>语句用于定义一个实体。

3，实体可分为两种类型：引用实体和参数实体。


一：引用实体：就是在DTD中定义了一个引用实体--<!ENTITY 实体名 "内容">--，
	然后在XML中使用引用实体 --&实体名--。
例子：
	在DTD中定义
		<!ELEMENT 班级 (学生+,班长)>
		<!ENTITY info "引用内容">   
	在xml文件中引用   
		<介绍>&info;学习刻苦</介绍> //注意！！！引用后面要有分号.


二：参数实体：在DTD中定义实体-<!ENTITY % 实体名称 "实体内容">-
	在DTD文件中自己使用	-&实体名称-
例子：

<!ELEMENT 班级 (学生+)>
<!ENTITY % stu "名字">
<!ELEMENT 学生 (%stu;,年龄,介绍)>
<!ELEMENT %stu; (#PCDATA)>
<!ELEMENT 年龄 (#PCDATA)>
<!ELEMENT 介绍 (#PCDATA)>








	=====使用PHP技术对XML文件进行操作=====

	-----三种XML操作技术;
1, php dom
2, php 结合 xpath 操作 xml
3, SimpleXml

	----增删改查 术语 C R U D 

C - create 	R - read 	u - update	d - delete

	-----DOM说明：
	dom (document object model) 文档-对象-模型，核心思想是把一个XML文件，看成一个对象 模型，然后通过对象的方式来操作XML文件。



	-----DOM命令及查找案例：
	

DOM.PHP 页面

<html>
<?php
/*
	//解析一个文件的步骤
	

	//1，创建一个DOMDocument对象，表示文档。
	$xmldoc=new DOMDocument();
	//2, 指定加载哪个XML，并解析。
	$xmldoc->load("xml.xml");
	//3, 获取想要的节点。
	$stus = $xmldoc->getElementsByTagName('stu');
	//4, 遍历。
	for($i=0;$i<$stus->length;$i++){
		//取出学生；
		$stu = $stus->item($i);
		//各个信息；
		echo getNodeVal($stu,"name");
	}

	function getNodeVal(&$MyNode,$tagName){
	//这句话，获取到$MyNode节点下面的所有$tagName节点
	//$nodeList=$MyNode->getElementsByTagName($tagName);
	//var_dump($nodeList);
	//取出第一个
	//$node=$nodeList->item(0);
	//var_dump($node);
	//取出值
	//$nodeVal=$node->nodeValue;
	//var_dump($nodeVal);
	return $MyNode->getElementsByTagName($tagName)->item(0)->nodeValue;
	}
*/
	$xmldoc = new DOMDocument();
	$xmldoc->load('xml.xml');
	$n1 = $xmldoc->getElementsByTagName('stu');
	function getVal($n1,$b,$i){
	return $n1->item($i)->getElementsByTagName("$b")->item(0)->nodeValue;
	}
	for($i=0;$i<$n1->length;$i++){	
			echo getVal($n1,'sex',$i)."<br>";
	}
?>
</html>




xml.xml页面：

<?xml version="1.0" encoding="utf-8"?>
<class>
	<stu>
		<name>
			<aaa>
				<bbb>111</bbb>
				<bbb>222</bbb>
				<bbb>333</bbb>
			</aaa>
			<aaa>
				<bbb>444</bbb>
				<bbb>555</bbb>
				<bbb>666</bbb>
			</aaa>
			<aaa>
				<bbb>777</bbb>
				<bbb>888</bbb>
				<bbb>999</bbb>
			</aaa>
		</name>
		<age>18</age>
		<sex>nv</sex>
	</stu>
	<stu>
		<name>
			<aaa>
				<bbb>aaaa</bbb>
				<bbb>bbbb</bbb>
				<bbb>cccc</bbb>
			</aaa>
			<aaa>
				<bbb>dddd</bbb>
				<bbb>eeee</bbb>
				<bbb>ffff</bbb>
			</aaa>
			<aaa>
				<bbb>gggg</bbb>
				<bbb>hhhh</bbb>
				<bbb>iiii</bbb>
			</aaa>
		</name>
		<age>23</age>
		<sex>nv</sex>
	</stu>
	<stu>
		<name>
			<aaa>
				<bbb>jjjj</bbb>
				<bbb>kkkk</bbb>
				<bbb>llll</bbb>
			</aaa>
			<aaa>
				<bbb>mmmm</bbb>
				<bbb>nnnn</bbb>
				<bbb>oooo</bbb>
			</aaa>
			<aaa>
				<bbb>777</bbb>
				<bbb>888</bbb>
				<bbb>999</bbb>
			</aaa>
		</name>
		<age>46</age>
		<sex>nan</sex>
	</stu>
</class>


















		=====DOM技术-添加节点内容实例=====

添加页面：

<?php
	$xmldoc=new DOMDocument(); //创建ODM文档
	$xmldoc->load('aaa.xml');	//读取XML文件
	$root = $xmldoc->getElementsByTagName('class')->item(0); //读取拿到根节点
	$node_stu = $xmldoc->createElement('stu');		//创建一级子节点
	$node_stu_name = $xmldoc->createElement('name');	//创建二级子节点
	$node_stu_name->nodeValue="111111";			//给二级子节点赋值
	$node_stu->appendChild($node_stu_name);			//把二级子节点挂载到一级子节点
	$node_stu_age = $xmldoc->createElement('age');
	$node_stu_age->nodeValue="2222222";
	$node_stu->appendChild($node_stu_age);
	$node_stu_sex = $xmldoc->createElement('sex');
	$node_stu_sex->nodeValue="33333333";
	$node_stu->appendChild($node_stu_sex);
	$root->appendChild($node_stu);				//把一级子节点挂载到要根节点
	$xmldoc->save("a11.xml");	//保存XML文件（如换一新文件名则是创建一个新文件）
?>




被添加的文件

<?xml version='1.0' encoding="utf-8" ?>
<class>
	<stu>
		<name>111</name>
		<age>222</age>
		<sex>333</sex>
	</stu>
</class>














	=====xpath====
使用xpath有什么好处？
PHP DOM技术可以中层取出，但是不能保持层次关系，使用xpath可以更好解决！

例子：

<?php
	$xmldoc = new DOMDocument();
	$xmldoc->load('two.xml');
	$xpath = new DOMXPath($xmldoc);
	
	$p1 = $xpath->query("//*");
	echo $p1->length;
	for($i=0;$i<$p1->length;$i++){
		$p2 =  $p1->item($i);
		echo $p2->tagName."<br>";
	}
?>





/aaa/ddd/bbb	--选择aaa的子元素ddd下的bbb元素。
//bbb 		--选择所有bbb元素
//ddd/bbb 	--选择所有父元素是ddd的bbb元素
/aaa/ccc/ddd/* 		--选择所有路径依附于/aaa/ccc/ddd的元素
/*/*/*/bbb	--选择所有的有3个祖先元素的bbb元素(或所有第四级bbb元素)
//* 		--选择所有元素
/aaa/bbb[1]	--选择aaa的第一个bbb子元素
/aaa/bbb[last()] 	--选择aaa的最后一个bbb子元素
//@id		--选择所有的id属性
//bbb[@id]	--选择有id属性的bbb元素。
//bbb[@name]	--选择有name属性的bbb元素。
//bbb[@*] 	--选择所有有任意属性的bbb元素。
//bbb[not(@*)]		--选择没有属性的bbb元素
//bbb[@id='b1'] 	--选择含有属性id其值为‘b1’的bbb元素
//bbb[@name='bbb']	--选择含有name属性值为'bbb'的bbb元素.
//bbb[normalize-space(@name)='bbb']
	--选择含有属性name且值(在用normalize-space函数去掉前后空格后)为bbb的bbb元素。
//*[count(bbb)=2]	--选择含有2个bbb子元素的元素.
//*[count(*)=2]		--选择含有2个子元素的元素。
//*[count(*)=3]		--选择含有3个子元素的元素。
//*[name()='bbb']	--选择所有名称为bbb的元素（这里等价于//bbb）
//*[starts-with(name(),'b')] 	--选择所有名称以'b'起始的元素。
//*[contains(name(),'C')]	--选择所有名称包含‘C’的元素
//*[string-length(name())=3]	--选择名字长度为3的元素.
//*[string-length(name())<3]	--选择名字长度小于3的元素。
//*[string-length(name())>3]	--选择名字长度大于3的元素。
//ccc | //bbb		--选择所有的ccc和bbb元素。
/aaa/eee | //bbb	--选择aaa下为eee的所有子元素以及所有的bbb元素。
/aaa/eee | //ddd/ccc | /aaa | //bbb	--可以合并的路径数目没有限制。
/child::aaa		--等价于 /aaa
/aaa		--等价于/child::aaa
/aaa/bbb	--等价于/child::aaa/child::bbb
/child::aaa/child::bb	--等价于/aaa/bbb
/child::aaa/bbb		--二者都可以合并

/descendant::*		--选择文档根元素的所有后代，即所有的元素被选择。
/aaa/bbb/descendant::* 	--选择/aaa/bbb的所有后代元素.
//ccc/descendant::*	--选择所有ccc元素下的子元素。
//ccc/descendant::ddd	--选择所有为ccc元素下为ddd的子元素。
//ddd/parent::* 	--选择所有ddd元素的父节点。
/aaa/bbb/ddd/ccc/eee/ancestor::*	--选择一个绝对路径上的所有节点。
//fff/ancestor::*	--选择fff元素的祖先节点。
 	
--following-sibling轴,包含上下文节点之后的所有兄弟节点。
	/aaa/bbb/following-sibling::*
	//ccc/following-sibling::*

--preceding-sibling轴(axis)包含上下文节点之前的所有兄弟节点
	/aaa/xxx/preceding-sibling::*
	//ccc/preceding-sibling::*














	=====simplexml=====
simplexml 可以有三种形式来装载XML文件
	1， 直接装载xml文件。
	2， 装载DOM对象。
	3， 装载一个XML格式的字符串。(装载string该string要求按照XML文件的标准写)
-----simplexml与xpath结合：
	foreach($library->xpath('//title') as $title){
		echo $title;
	}

<?php
	//-----1， 直接装载xml文件
	$lib=simplexml_load_file('books.xml');
	//var_dump($lib);
	//取出书，$books就是一个数组。
	$books = $lib->book;
	//$book = $books[0];
	//取出书名。
	//echo $book->title."".$book->autor."".$book->code;
	for($i=0;$i<count($books);$i++){
		$book = $books[$i];
		//取出属性的值；
		echo $book['house']."---".$book['house2'];
		//取出子元素的值；
		echo $book->title."".$book->autor."".$book->code."<br>";
	}
	
	//------simpleXML也可以和xpath结合，功能强大。
	$titles= $lib->xpath('//title');
	echo "<br>***simplexml和xpath结合****";
	foreach($titles as $val){
		ehco "<br>".$val;
	}
	

	//-----<<<xxx xxx  与大型字符串
	$string = <<<XML 
		<?xml version='1.0'?>
		<document>
			<title>forty what?</title>
			<from>joe</from>
			<to>jane</to>
			<body>
			 I know that's the answer -- but what's the question?
			</body>
		</document>	

	XML;
	$xml = simplexml_load_string($string);
	foreach($xml->xpath("..title") as $title){
		echo '<br>'.$title;
	}
	print_r($xml);



	-----simple装载DOM对象。
程序在建立DOM对象后，调用simplexml_import_dom()函数获取DOM对象：如：
	$dom = new DOMDocument();
	$dom->load("book.xml");
	$simple_import_dom($dom);










	=====http协议=====
1, http协议是建立在 tcp/ip 协议基础上的。
2，我们的web开发数据的传输都是依赖于http协议的.
3, http协议全称是超文本传输协议。



	http协议的 http请求（request）
基本结构：

	请求行:

	消息头:

	消息实体(实体内容);
	
例：

GET /test/hello.html HTTP/1.1  //此为消息头  以GET方式， 想要取的是什么资源， 协议是1.1

Accept: */*	//表示客户端可以接受任何数据

referer:http://localhost:80/test/abc.html  //表示我是从哪里来

Accept-Language: zh-cn	//页面支持的语言

User-Agent:Mozila/4.0(compatible;MSIE8.0;Windows NT5.1;Trident/4.0;.NET
CLR 2.0.50727;NET4.0C;NET4.0E)   //告诉服务器我的浏览器的内核，操作系统。

Accept_Encoding:gzip,deflate	//表示接受什么样的数据压缩格式。

Host:localhost:80	//主机，以及端口，如果不带端口，默认是80

Connection:Keep-Alive	//表示一个长连接，不要立即断掉请求







		-----预定义全局变量：
php manual -- 语言参考 -- 预定义变量 
在服务器端，我们可以通过 $_SERVER 来获取我们需要的信息。

重要的有：
HTTP_HOST
REMOTE_ADDR 访问该页面的IP
DOCUMENT_ROOT 可以获取 apache 的主目录
REQUEST_URI 可以获取 请求的资源名












	-----页面请求方式有：
POST，GET，HEAD，OPTIONS，DELETE，TRACE，PUT，常用的有POST,GET

get post区别：

1，GET提交，请求的数据会跟在URL之后如：
	login.php?name=abc&password=kkk
   POST提交：把提交的数据放轩在HTTP包体中，比如；
	POST /test/reg.php HTTP/1.0
	Host:
	Content-Type:
	content-Length:

	name=abc&password=xyz
因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。

2, 提交数据的大小不一样
	http协议本身并没有限制数据大小，但浏览器对GET和POST请求有限制，GET请求数据量为2K+35。
而POST没有限制。

3，GET请求可以更好的添加到收藏夹。



	-----现在我们实际使用一些HTTP请求，完成一个防盗链的






	-----http响应

	简单定义，一个HTTP响应代表服务器给浏览器回送的数据，同时告诉浏览器应当怎样处理数据。
1，基本结构

	状态行
	消息头信息
			空行
	实体信息

例：

HTTP/1.1 200 OK		//200 OK表示客户端请求成功。
Server Microsoft-IIS/5.0 	//表示告诉浏览器，服务器的情况.
Date Thu, 13 Jul 2000 05:46:53 GMT  //告诉浏览器所请求页面的更新时间，如果相同浏览器就不再更新，
Content-Type:text/html
Cache-control:private





	-----状态码的说明：

   状态码			含义：
100-199   表示成功接收请求，要求客户端继续提交下一次请求才能完成整个处理过程。
200-299	  表示成功接收请求并已完成整个处理过程，常用200.
300-399	  为完成请求，客户需进一步细化请求。例如，请求的资源以经移动一个新地址，常用302，304
400-499	  客户端的请求有错误，常用404
500-599	  服务器端出现错误，常用500。	





	-----302状态码的使用
比如说我们现在希望访问a.php页面，让其自动跳转到b.php
基本用法：
<?php
	header('Location:b.php');
?>




	-----404码使用
404 一般说就是该页面不存在。



	------304码
大意是检查曾经浏览过的文件是否缓存和现资源是否有更新差别，如果没有则直接调用缓存文件，如果有更新则再从网络上下载资源！
















	下面是比较详细的一个HTTP响应：

Location:http://www.baidu.org/index.php    //location相当于重定向
Server:apache		//告诉浏览器我的服务器信息
Content-Encoding:gzip	//内容编码支持gzip压缩算法。
Content-Length:80	//返回数据内容的大小。
Content-Language: zh-cn	//支持的内容语言
Content-Type:text/html; charset=GB2312 	//内容类型，形式和编码类型。
Last-Modified:Tue, 11 Jul 2000 18:23:51 GMT //请求资源的最后（最新）更新时间。
Refresh: 1;url=http:..www.baidu.com	//告诉浏览器，间隔1秒，重定向到百度。
Content-Disposition:attachment,filename=aaa.zip
Transfer-Encoding:chunked
Set-Cookie:SS=Q0=5Lb_nQ;path=/search
Expires: -1		//禁用缓存方法一；
Cache-Control: no-cache	//禁用缓存方法二；
Pragma:no-cache		//禁用缓存方法三；





	-----通过http响应，控制浏览器间隔一定时间去跳转

<?php
	header("Refresh: 3; url=http://localhost/xxx.php");
?>







	-----禁止页面缓存
在默认情况下，浏览器会缓存页面。

通过header禁用缓存案例：

<?php
	header("Expires: -1");
	header("Cache-Control: no_cache");
	header("Pragma: no-cache");
	echo "hello";
?>








	-----设置文件下载：

header("Content-type: application/octet-stream"); //返回的是文件流形式
header("Accept-Ranges: bytes");			//按照字节大小返回
header("Accept-Length: $file_size");		//返回文件大小
header("Content-Disposition: attachment; filename=".$file_name);
	//$file_name 这一句是设置下载提示框对应的文件名称。可以自行设置文件名。



实例一：简单文件下载

<?php
	$file_name= "aa.wmv";   //关联一个要下载的文件
	if(!file_exists($file_name)){	//如果此文件不存在，则显示下面信息，并结束！
		echo "文件不存在！！";
		return ;
	}
	$fp = fopen($file_name,'r');	//打开这个文件
	$file_size=filesize($file_name);	//读取这个文件的大小
	header("Content-Type: application/octet-stream"); //设置下载文件类型
	header("Content-Ranges: bytes");		//设置字节类型（字节）
	header("Content-Length: $file_size");		//设置下载文件的大小
	header("Content-Disposition: attchment; filename=".$file_name); //设置文件名，可指定！
	$buffer=1024;	//设置文件下载时每次读取量的大小。
	while(!feof($fp)){	//如果文件没有读取结束
		$file_data=fread($fp,$buffer);	//当前读取量是多少
		echo "$file_data";	//把当前读取量返回给页面
	}	
	fclose($fp);	//下载完成，关闭文件。
?>



实例二： 

<?php
function fileLoad($file_name,$path){
	$file_name = iconv("utf-8","gb2312",$file_name);
	$file_path = $path.$file_name;
	if(!file_exists($file_path)){
		echo "文件不存在！！！";
		return ;
	}
	$fp = fopen($file_path,'r');
	$file_size = filesize($file_path);
	header("content-type: application/octet-stream");
	header("content-ranges: bytes");
	header("content-length: $file_size");
	header("content-disposition: attachment; filename=".$file_name);
	$buffer = 1;
	$count = 0 ;
	while(!feof($fp) && $count-$file_size<0){
		$file_data=fread($fp,$buffer);
		$count += $buffer;
		echo $file_data;
	}
	fclose($fp);
}
fileLoad('顺平.jpg','c:/down/');
?>
















---------------------------------------------------------------



	=====php数据库编程=====

	-----php操作mysql数据库的三种方式
1, mysql扩展库
2, mysqli扩展库
3, pdo


	-----mysql扩展库和mysql数据库的区别
1, mysql数据库是用于存放数据的.
2, mysql数据库操作有三个层面
	A层：编辑指令发送到数据库管理系统。
	B层：数据库管理系统进行解析，调用数据库中的数据
	C层：找到相应数据后再返回给客户端。
	也就是说以数据库管理系统为中间层，操作界面为右层，数据库为左层。
3，mysql扩展是一堆函数，是PHP设计者提供给程序员用于完成对mysql数据库的各种操作(CRUD).






	-----数据有符号和无符号的区别；

	数据库表中建立数据项时，有符号和无符号的含意就是是否带有负号。带符号的就是正负各占一半，不带符号就会为正。默认应该是有符号，无符号用 unsigned 表示.


	

	-----字符串char 和varchar的区别

 	char 的长度是固定的，如：指定一个char 值长度为12,那么即使它只用了8个，也会占用12个长度的位置

	varchar 的长度是不固定的，如指定一个varchar 的长度为12 ,但只用了8个，其它的4个位置便被回收了。






		-----mysql环境的搭建

1, 启用mysql扩展库
	在php.ini 文件中找到: extension=php_mysql.dll 去掉前面的分号 以启用它。
		通过<?php phpinfo() ?>可以查看当前php都有支持哪些扩展库!

	
		-----数据库（cmd）操作命令：
数据库操作指令分为四种：
	ddl 	数据定义语句
	dml	数据操作语句	如： update  insert   delete
	dql	数据选择语句	如： select
	dtl	数据事务语句	如： rollback   commit,,,
		
1，insert into tab(name,age) select name,age from tab;	数据内容自我复制。



2, 创建一张用户表或库,
	create database words;  //创建一个库

	//创建一个user1表，以及相关内容。  
	create table user1(
	id int primary key auto_increment,
	name varchar(32) not null,
	password varchar(64) not null,
	email varchar(128) not null,
	age tinyint unsigned not null
	)	
	;


3, 删除一个表：
 	drop table xxxx;	//xxx是一个表名，如: user1  
	注：delete 是用来删除数据的  drop 是用来删除表的 




	-----用md5加密数据库中的密码；

4, 插入一组数据 ：
	insert into user1(name,password,email,age) values('wnag',md5('123'),'zs@sohu.com',30);




	-----解决数据库与网页乱码问题（Data too long）

5， show variables like "%char%";
原因，cmd 的操作系统只认GBK的编码，而在文档中的ANSY码有时也是GBK码，所以有时在文档中粘到CMD中的数据可以使用，而直接在CMD中输入的字符却会出错。，，
	解决方法一：要么在文档中以GBK编码先写好代码，然后粘到CMD中。
	解决方法二： set character_set_clinet=gbk;  (可以调用上面的variable like命令查看一下)
		     set character_set_results=gbk;
	    或直接： set names gbk; 即可
	容易出错的地方： 设置好 mysql_set_charset('utf8');  有时忘记设置这里就会出现乱码！
	mysqli 中的编码设置  $mysqli->set_charset('utf8');  





6,  查询当前表所在哪个数据库中    \s    用此命令可查询所在表属于哪一个库
	show tables;  	命令也可能查询当前库； 在其返回的表单头部会显示当前库的名.


7, mysql_query()函数：向mysql数据库发送指令函数。此函数有两个参数如：
	mysql_query($sql,$link) 这里把连接数据库的$link添加进去，就会省去它自动查找是否以有连接或在没有连接时自动建立连接时的麻烦！以后最好是把这个参数带上！
	


8， mysql_affected_rows($link)  查看上一次操作的行数是否受到影响。用来检验上次操作是否成功。如下
	if(mysql_affected_rows($conn)>0){
		echo "操作成功";
	}else{
		echo "没有受到影响的行数";
	}



9, mysql_fetch_field()  取出表头信息   如：
	while($into=mysql_fetch_field($res)){
		echo $into->name;
	}
结果会显示：一个表的表头如： id  name  password age  等

	----$field = $res->fetch_field() 面向对象的方式
	


				

10,  $cols=mysql_num_fields($res);
	echo $rows = $cols;
	显示一个表的内容有多少行和多少列
-----$res->num_rows  对象方式获得行数。
-----$res->field_count 对象方式获得字段的列数


11, mysql_insert_id($link);
	显示上一次添加或操作内容的ID号



12，mysql_field_name($res,$i) 取出结果中指定字段的字段名，（取出表头信息）$i是下标




13, $res = $mysqli->multi_query($sqls); 批量发送sql语句

14-1 $sqls.="xxxx;";	批量语句，语句中的点和分号都不能少。

14, $result = $mysqli->store_result(null); 当批量查询时，此句将逐个取出查询的结果集


15, $mysqli->more_result(null);   查询当前结果的后面是否还存在结果集


16, $mysqli->next_result();	执行下一条结果集。


17，$result->free()；		释放当前资源内存，$result要实因际对象而改变！


18，$mysqli->autocommit(false);	设置自动提交 可选false 和true;


19, $mysqli->commit;	提交


20， $mysqli->close();	关闭连接；


21， $mysqli->rollback;		回滚


22,	"start transaction "		启动事务处理


23,	"savepoint a;"		备份姨个事务节点


24，	"rollback to a;"	恢复(回滚)到A节点


25，	"commit"	提交保存事务操作。


26, 	数据库预处理

	$sql="insert into stmt(id,name,age) values(?,?,?)";  预处理设置


	 $stmt = $mysqli->prepare($sql);	启动预处理


	$id=6;    $name='aaa';   $age=18;
 	$stmt->bind_param('isi',$id,$name,$age);	 设置参数，并绑定参数。i=int, s=string
 	$stmt->execute(); 		执行预处理操作


27,	$_SERVER['REQUEST_METHOD']	检测request 接收数据时是以什么方式(post/get/cookie)
	if($_SERVER['REQUEST_METHOD']=='POST'){		
		//则用post方式接收
	}else if($_SERVER['REQUEST_METHOD']=='GET'){
		//则用GET接收
	}












	-----数学函数 

1, ceil()  进一取整 
	<?php
		$count = 7;
		$size =3;
		echo ceil($count/$size);    //结果等于3   (2,1=3; 2.8=3; 只要有小数就进位1)
	?>


2, floor() 向下取整
<?php
	$b = 3.8;
	echo floor($b)."<br>";
	$a = 9.9;
	$d = floor($a);
	echo $d;
?>


3, dechex() -十进制转换成为十六进制。 比如说把10转成a

<?php
	$code='';
	for($i=0;$i<8;$i++){
		$code.=dechex(rand(1,15));	//1,15 从1到15 
	}
	echo $code;
?>






	-----其它函数

1，explode()   字符串分割函数
<?php
$str = "Hello world. It's a beautiful day.";
print_r (explode(" ",$str));
?>


2，array_rand()  从数组中取出一个或多个单元！
<?php
$input  = array( "Neo" ,  "Morpheus" ,  "Trinity" ,  "Cypher" ,  "Tank" );
$rand_keys  =  array_rand ( $input ,  2 );
echo  $input [ $rand_keys [ 0 ]] .  "\n" ;
echo  $input [ $rand_keys [ 1 ]] .  "\n" ;
?> 




3，file_get_contents()	将整个文件读入一个字符串

4, file_put_contents()    将一个字符串写入文件

5, serialize ― 产生一个可存储的值的表示 
		自己理解：把一个数组转化成一个可以转化成文件的字符串。

6, unserialize ― 从已存储的表示中创建 PHP 的值
		自己理解：把一个转化成字符串的文件，再次转化成一个PHP数组
serialize和un..一个是序列化一个是反序列化，就像加密和解密的关系一样。
干嘛用的呢？举个例子，比如你一个数组或者对象要存在数据库里，应该要怎么存？我不知道其他方法，我知道的是把数组或者对象映射成一个字符串，然后把这个字符串存到数据库里。用的时候从数据库里读取，然后把字符串映射回原数组或对象。serialize和un..就是做这个工作的，具体它们的映射方法建议你看看资料，很简单。ser..把数组映射成字符串，un..把字符串变成数组

	3,4,5 见下例

<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<?php
	$txt = 'e.txt';
	if(!file_exists($txt)){//不存在这个文件
		$array = array();
		for($i=1;$i<=5;$i++){
			$array[]=$i;
		}
	}else{
		$txt_array = file_get_contents($txt);
		$array = unserialize($txt_array);
		if(empty($array)){
		echo "已经全随机掉了，请删掉".$txt."这个文件，重新再来一遍";
		die();
		}
	}
	$rand = array_rand($array);
	echo $array[$rand];//随机出来的内容
	unset ($array[$rand]);//销毁已经蹦出来的元素
	file_put_contents($txt,serialize($array));
?>


7, unset()  释放销毁一个变量
	$a="aaa";
	unset($a);




8，文件操作相关函数

parse_ini_file()	解析一个ini配置文件
str_replace()		子字符串替换
fread()			读取文件（可安全用于二进制文件）
fopen()			打开文件或者 URL
fclose()		关闭文件
feof()			测试文件指针是否到了文件结束的位置
file_exists()		检测文件是否存在
file_get_contents()	 将整个文件读入一个字符串
filectime()		 取得文件的 inode 修改时间
fileatime()		取得文件的上次访问时间 
filemtime()		取得文件的上次修改时间
filesize()		取得文件的大小
fstat()			通过已打开的文件指针取得文件相关信息

以上函数请参考 -----文件操作相关函数实例 




9，strrpos ― 计算指定字符串在目标字符串中最后一次出现的位置
<?php
		 |	   |         |
$foo  =  "0123456789a123456789b123456789c" ;

var_dump ( strrpos ( $foo ,  '7' , - 15 ));   // 从尾部往回倒着数第 5 个位置开始查找, 倒着数的下一个 7 是在第17位上，其结果就是 int(17)

var_dump ( strrpos ( $foo ,  '7' ,  20 ));   // 从第 20 个位置开始查找,那么下一个 7 出现在了第 27 的位置上，其结果就是 int(27)

var_dump ( strrpos ( $foo ,  '7' ,  28 ));  //从第28个位置开始找，但后面没有 7 了。所以结果为 false

?> 




10，substr ― 返回字符串的子串
<?php
$rest  =  substr ( "abcdef" , - 1 );     // 返回 "f"
$rest  =  substr ( "abcdef" , - 2 );     // 返回 "ef"
$rest  =  substr ( "abcdef" , - 3 ,  1 );  // 返回 "d"
?> 



	-----mysql取出查询结果的四种方法
1, mysql_fetch_row	返回索引数组，取出结果的下标以0,1,2,数字的形式显示。
2, mysql_fetch_assoc	返回关联数组，取出结果的下标以，数组本身KEY字串的形式显示。
3, mysql_fetch_array	同时返回索引与关联数组，内存多占用一倍。
4, mysql_fetch_object	以对象的形式返回数据，使用方法为： echo $row->xx 
			因为这时对象把数据当做一个属性.




mysql扩展库操作mysql数据库步骤：
<?php
	$link = mysql_connect('127.0.0.1,'root','abcd');     //1,获取连接
	if(!$link){
		die("连接失败".mysql_error());	//检测连接是否成功，并指出错误的信息
	}	
	mysql_select_db('test');	//2,选择数据库
	//mysql_query('set names utl8');  	//3,设置操作编码
	mysql_set_charset('utf8');  //两种设置编码方式，保证程序按照utf8.
	$sql = "select * from user1"; //4，发送查询指令,这里也可发送其它语句如：insert,delete,等
	$res=mysql_query($sql,$link); //$res 表示结果集，可以理解是一张表，$link 指定连接，可减少浪费。
		//这里的$res 是一个返回的资源型的结果集	.	


		//5，接收返回结果并处理（显示）
		//mysql_fecth_row会依次取出$res结果集的下一行数据，赋值给$roww
		
		//mysql_close($link); //如果在这里把连接断开或置空的话，PHP依然可以进行下面的操作，因
		//$link=null;  //为PHP以把数据取回到内存当中，现在只是对内存数据操作。
	
	while($row=mysql_fetch_row($res)){
		//第一种取法
		echo "<br>$row[0]--$row[1]--$row[2]<br>";
		//第二种取法
		foreach($row as $key=>$val){
			echo "$key==>$val";
		}
		echo "<br>";
	}
	//6,释放资源
	mysql_free_result($res);
	//7,关闭连接，这句话可有可无，因为它会自动关闭，但建议有。
	mysql_close($link);



?>



	-----数据类型的种类
PHP的数据类型分为三大类 
	一：数值型	小数，整数，布尔，字符串，等
	二：复合型	数组，对象
	三：特殊类型	null, 资源型





		-----exit()调试使用函数;
执行它时，后面的代码就不执行了，用在调试的时候，当不希望执行后面代码就用这个函数。





		-----往mysql数据库插入中文字串的方法
当一个变量是中文字串时，不能直接用双引号“”来注释此变量，
得先加一层单引号，再加双引号，然后，再加一层点如： '".$a."'	案例如下：
$ins = mysql_query("inser




		-----mysqli 的释放内存和关闭连接
1, mysqli 面对对象的方式
	//释放内存
	$res->free();
	//关闭连接
	$mysqli->close();

2，mysqli 面向过程的方式
	//6,释放资源
	mysqli_free_result($res);
	//关闭连接
	mysqli_close($mysqli);

3，mysql 的方式
	//6,释放资源
	mysql_free_result($res);
	//7,关闭连接，这句话可有可无，因为它会自动关闭，但建议有。
	mysql_close($link);








	-----总结实例


<?php

class sqlToor{
	private $er="mysql_error";
	public $link;
	function __construct($host,$root,$psw,$db){
		$this->link = mysql_connect($host,$root,$psw)or die($er);

		mysql_select_db($db)or die("$er");
		mysql_set_charset("utf8");
		
	}
	//函数-获取dql操作结果集并显示
	function fetch($res){
		while($row = mysql_fetch_row($res)){
			foreach($row as $k=>$v){
				echo "---$v";
			}
			echo "<br>";
		}
	
	}
	//函数-查询dml操作是否成功
	function affc($link,$res){
		$affc = mysql_affected_rows($this->link);
		if($res){
			if($affc>0){
				echo "操作成功<br>";
			}else{
				echo "没有受到影响的行数！<br>";
			}
		}else{
			echo '操作失败<br>';
		}
	}
}
	$sq=new sqlToor('localhost','root','abcd','threephp');
	//$tab=mysql_query("show tables");
	//fetch($sdb);
	echo "<hr>";
	//fetch($tab);
	
	//添加内容
	//$ins = mysql_query("insert into user1(name,password,email,age) values('刘军',md5('abc'),'wg@163.com',34)");

	//删除内容
	//$del = mysql_query("delete from user1 where id in(15,16,17,18,19,20,21)");


	//更新内容
	//$upd = mysql_query("update user1 set name='那英',email='ny@163.com',age=43 where id = 9");
	//$sq->affc($link,$upd);
	
	//显示表中内容
	//$sel=mysql_query("select * from user1");
	//$sq->fetch($sel);

	//获取表头的方法
	/*
	$rows = mysql_affected_rows($sq->link);
	echo $rows;
	$cols = mysql_num_fields($sel);
	echo $cols;
	for($i=0;$i<$cols;$i++){
		echo mysql_field_name($sel,$i)."---";
	}
	$a = 0;
	while($a<$cols){	
		echo mysql_field_name($sel,$a)."--";
		$a++;
	}
	*/


	/*
	//-----把数据库中的数据以列表的形式显示出来
	$sel=mysql_query("select * from user1");
	$rows = mysql_affected_rows($sq->link);
	$cols = mysql_num_fields($sel);
	
	
	echo "<table border=1><tr>";
		for($i=0;$i<$cols;$i++){
			echo "<th>".mysql_field_name($sel,$i)."</th>";
		}
		echo "</tr>";
		while($row = mysql_fetch_row($sel)){
			echo "<tr>";
				foreach($row as $k=>$v){
					echo "<td>".$v."</td>";
				}
			echo "</tr>";
		}
	echo "</table>";
	*/

	$ins = mysql_query("insert into user1(id,name,password,email,age) values(2,'刘刚',md5('abc'),'lg@163.com',22)");
	$sel=mysql_query("select * from user1");
	$sq->fetch($sel);
	$sq->affc($sq->link,$sq);
	$id = mysql_insert_id($sq->link);
	echo "<br>上次操作的ID号是 $id";


?>









-------------------------------------------------------------------




		=====使用php的mysqli扩展库操作mysql数据库

简单介绍：
	mysqli(mysql improve )mysql扩展库的增强版
	mysql扩展库和mysqli扩展库的比较
1, mysqli 的稳定性和安全性，效率有所提高，
2，mysqli支持面向对象编程，同时mysqli扩展库考虑到老程序员，同时提供面向过程的编程风格。


	mysqli 快速入门
编写一个程序，这个程序从user1表中读取数据，并打印在网页中，使用mysqli完成

1,先使用mysqli面向对象的风格，完成案例
2，配置PHP。INI文件让PHP支持mysqli扩展库: extension=php_mysqli.dll
3, 建库，建表，





	-----mysqli操作数据库（对象与过程的区别）

<?php
	//mysqli用面向过程的方式操作数据库
	$mysqli = mysqli_connect('localhost','root','abcd','words')or die('连接失败');
	mysqli_set_charset($mysqli,'utf8');
	
	//创建一个表
	//$sql = "create table order1(id int primary key auto_increment,name varchar(32) not null,age int(16) not null )";
	
	
	//插入一条数据
	//$sql="insert into order1(name,age) values('小王',18)";
	
	//删除一条数据
	//$sql="delete from order1 where id = 8";
	
	//更新一条数据；
	$sql="update order1 set name='屁的',age=33 where id = 2";
	
	
	$res = mysqli_query($mysqli,$sql);
	$showtable= mysqli_query($mysqli,"show tables");
	while($row=mysqli_fetch_row($showtable)){
		foreach($row as $k=>$v){
			echo "--".$v;
		}
		echo "<br>";
	}
	echo "<hr>";
	$sel =mysqli_query($mysqli,"select * from order1");
	while($row=mysqli_fetch_row($sel)){
		foreach($row as $k=>$v){
			echo "--".$v;
		}
		echo "<br>";
	}
	echo "<hr>";
	
	$id=mysqli_insert_id($mysqli);
	echo "上次操作的ID是: $id";
	



	
/*	//mysqli用面向对象的方式来操作数据库
	$mysqli=new mysqli('localhost','root','abcd','words');
	$mysqli->query("set names utf8");

	//创建一个表	
	//$sql="create table test(id int primary key auto_increment,name varchar(32) not null,age int(32) not null,sex varchar(8) not null)";
	
	//添加一条数据：
	//$sql="insert into test(name,age,sex) values('don1',18,'nv')";
	
	//删除一条数据：
	//$sql="delete from test where id = 4";
	
	//更新一条数据；
	$sql="update test set name='bbbb',age=88,sex='nan' where id=9";
	
	$res = $mysqli->query($sql);

	//查看操作的行数是否受的影响：

	if($res){
		if($mysqli->affected_rows>0){
			echo "操作成功";
		}else{
			echo "没有受到影响的行数";
		}
	}else{
		echo "操作失败！";
	}
	
	//查看表的内容
	echo "<br>";
	$sel=$mysqli->query("select * from test");
	while($row=$sel->fetch_row()){
		foreach($row as $k=>$v){
			echo "--$v";
		}
		echo "<br>";
	}
	$sel->free();
	$mysqli->close();
	*/
?>








	-----mysqli 批量执行sml语句



//关键字（$sqls.="xxxx;";  - 点和等号中不能有空格，后面的两个分号不能少）
//关键字($mysqli->multi_query($sqls)  -- 批量发送及接收返回值)
//关键字($result=$mysqli->store_result() -- 调取结果集,每调一次$result指针就会向后移一位！)



批量执行 dml语句,可以同时操作 删除，添加，更新，但不能同时操作select 语句
基本语法	注意第二条语句的等号前面要加一个点 '.'
	$sqls="sql1,,,;";
	$sqls.="sql1,,,;";
	$sqls.="sql1,,,;";
	mysqli::nulti_query($sqls);

案例；使用mysqli的 mysqli::multi_query()一次性添加三个用户 
<?php
	//header("content-type:text/html;charset=utf-8");
	$mysqli =new mysqli('localhost','root','abcd','test');
	$mysqli->query("set names utf8");

	$sqls = "insert into user1(name,age) values('宋江',20);";
	$sqls.= "insert into user1(name,age) values('吴用',30);";
		//关键字（$sqls.="xxxx;";  - 点和等号中不能有空格，后面的两个分号不能少）
	$sqls.= "insert into user1(name,age) values('林冲',40);";
	$res = $mysqli->multi_query($sqls);
		//关键字($mysqli->multi_query($sqls)  -- 批量发送及接收返回值)
	if($res){
		echo "操作成功";
	}else{
		echo "操作失败";
	}
?>




	-----mysqli批量执行dml语句


<?php
	$mysqli= new mysqli('localhost','root','abcd','dbone');
	$mysqli->query("set names utf8");
	
	$sqls = "select * from tab;";
	$sqls.="select * from tabone;";
	$sqls.="select * from tabtwo;";
	$sqls.="select * from tabthree;";
	$sqls.="show databases;";
	$sqls.="show tables;";
	$sqls.="desc tab;";
	if($res=$mysqli->multi_query($sqls)){
		do{
//关键字($result=$mysqli->store_result() -- 调取结果集,每调一次$result指针就会向后移一位！)
			$result=$mysqli->store_result();
			while($row=$result->fetch_row()){
//关键字($res->fetch_row()  -- 取出当前行的结果集相当一个数组)
				foreach($row as $k=>$v){
					echo "--".$v;
				}
				echo "<br>";
			}
			echo "<br>";
			$result->free();
//关键字($result->free()  -- 释放当前资源的内存)
			if(!$mysqli->more_results()){
//关键字($mysqli->more_results()  -- 查询后面是否还有结果集)
				break;
			}
		}while($mysqli->next_result());
//关键字($mysqli->next_result()  --  操作下一个结果集)
	}else{
		echo "faild....";
	}
?>





	=====mysqli事务类型处理=====

	事务用于保证数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。如网上转账就是典型的要用事务来处理，用以保证数据的一致性。


	-----mysqli 事务控制 acid

原子性-Atomicity : 原子性是指事务是一个不可分割的工作单位，事务中的要么都发生，要么都不发生。比如说一个事务由几名代码完成，要么全部成立，要么有一个失败，就全部失败。

一致性-Consistency:事务必须使数据库从一个一致性状态变换到另外一个一致性状态。

隔离性-Isolation: 事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其它事务的操作数据所干扰，多个并发事务之间要相互隔离。	


持久性-Durability: 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响。





	-----事务处理-账号转账案例
<?php
	$mysqli=new mysqli('localhost','root','abcd','dbone')or die('连接失败');
	$mysqli->query("set names utf8");
//关键字($mysqli->query("set names utf8")  -- mysqli面向对象的形式设置数据库的编码格式)

	//将提交设置为false ,不让其自动提交。
	$mysqli->autocommit(false);			
//关键字($mysqli->autocommit(false)  -- 设置自动提交为非自动)
	$sql1="update accounta set balance = balance-2 where id=1"; 
	$sql2="update account set balance = balance+2 where id=2";
//关键字(balance+2  -- 设置表中 balance 项 增加2)
				
//关键字($mysqli->query($sql) - 发送并获得返回值)
	$res1=$mysqli->query($sql1);	
	$res2=$mysqli->query($sql2);
	if($res1 && $res2){
		echo "操作成功----";
		$mysqli->commit();			
//关键字(commit - 提交)
	}else{
		echo "操作失败,回滚";
		$mysqli->rollback;			
//关键字(rollback - 回滚)
	}
	$mysqli->close();				
//关键字($mysqli->close - 关闭连接)
?>





	-----事务处理-节点备份与恢复
基本流程：
	1，关键字(start transaction - 启动事务处理)
	2，关键字(savepoint a - 备份一个事务节点，以便恢复)
	3，关键字(rollback to a - 恢复到 a 事务节点)
	4，关键字(commit - 提交并保存事务操作)


<?php
	//header("content-type:text/html;charset=utf-8");
	$mysqli= new mysqli('localhost','root','abcd','dbone')or die('连接失败');
	$mysqli->query("set names utf8");

	$sql =$mysqli->query("start transaction");	
//关键字(start transaction - 启动事务处理)
	$sql =$mysqli->query("savepoint a");
//关键字(savepoint a - 备份一个事务节点，以便恢复)
	$sql =$mysqli->query('insert into account(id,balance) values(115,50)');
	$sql=$mysqli->query("rollback to a");
//关键字(rollback to a - 恢复到 a 事务节点)
	$sql=$mysqli->query("commit");
//关键字(commit - 提交并保存事务操作)

	$sql=$mysqli->query("select * from account");
	while($row=$sql->fetch_row()){
		foreach($row as $k=>$v){
			echo "--".$v;
		}
		echo "<br>";
	}
?>









	=====mysqli stmt 预处理技术 



	-----使用预处理语句有什么好处？
1，效率高，执行速度快
2，安全性高，可以防止sql注入


问题的提出？
	现在需要向mysql数据库添加100个用户，请问如何实现


	-----mysql工作原理及预处理技术

PHP发送数据到mysql的工作原理  
	1, 建立连接
	2，发送指令
	3, mysql进行编译进行接收
	4，断掉连接
所以，当PHP操作数据库时，每发送一次数据都会建立一次连接，进行一次编译。这样很浪费资源.而预处理技术就会大大减少这样的资源浪费。

预处理就是提出预编译，把sql第一次发送的语句做好编译，后面只需要发送数据，而且不会断掉连接。这样只用一个连接，只作一次编译就把成百上千条语句完成了。不然成百上千次的连接，编译会浪费很多的资源。





	-----mysqli预处理技术prepare  添加实例

<?php
		
			$sql = "insert into stmt(id,name,age) values(?,?,?)";
//关键字($sql = "insert into stmt(id,name,age) values(?,?,?)";  --  预处理设置)
			$stmt = $mysqli->prepare($sql);
//关键字($stmt = $mysqli->prepare($sql);   --  预处理语句)
			$id= 6;
			$name = 'aaa';
			$age = 111;
			$stmt->bind_param('isi',$id,$name,$age);
//关键字($stmt->bind_param('isi',$id,$name,$age);   -- 绑定参数)
			$b = $stmt->execute();
//关键字($b = $stmt->execute();   -- 执行预处理功能)
			
			$id=7;
			$name='bbb';
			$age = 222;
			$stmt->bind_param('isi',$id,$name,$age);
			$stmt->execute();
			
			$id=8;
			$name="ccc";
			$age =333;
			$stmt->bind_param('isi',$id,$name,$age);
			$stmt->execute();
			
			$id=9;
			$name='ddd';
			$age = 444;
			$stmt->bind_param('isi',$id,$name,$age);
			$stmt->execute();
			
			$id=10;
			$name='eee';
			$age = 555;
			$stmt->bind_param('isi',$id,$name,$age);
			$stmt->execute();
			if($b){
				echo "ok";
			}else{
				echo "faild".$stmt->error;
			}
			$mysqli->close();
			
?>






	-----mysqli预处理技术-prepare  ---查询实例

<?php
//关键字($mysqli_stmt->bind_param('i',$id)	设置预处理语句)
//关键字($mysqli_stmt->bind_result($a,$b,$c)    绑定结果集)
//关键字($mysqli_stmt->execute()		执行语句)
//关键字($mysqli_stmt->fetch()			逐个获取结果集的行结果)
//关键字($mysqli_stmt->free_result()		释放预处理资源)
//关键字($mysqli_stmt->close();			关闭预处理操作)
//关键字($mysqli->close();			关闭连接)

	$sql="select * from stmt where id>?";
	$mysqli_stmt=$mysqli->prepare($sql);
	$id=5;
	$mysqli_stmt->bind_param('i',$id);	//关键字
	$mysqli_stmt->bind_result($a,$b,$c);	//关键字
	$mysqli_stmt->execute();		//关键字
	while($mysqli_stmt->fetch()){		//关键字
		echo "<br>--$a--$b--$c";
	}
	echo "<br>--------";
	$id=10;
	$mysqli_stmt->bind_param('i',$id);
	$mysqli_stmt->execute();		
	while($mysqli_stmt->fetch()){		
		echo "<br>--$a--$b--$c";
	}
	$mysqli_stmt->free_result();		//关键字
	$mysqli_stmt->close();			//关键字
	$mysqli->close();			//关键字


?>








-----------------------------------------------------------






	-----预编译可以自动防止sql（结构化查询语句）注入攻击

//关键字 password='aa' or 1='1';

-----sql注入漏洞，使用万能密码攻击：
以下是利用数据库万能密码进入数据库：
select * from user1 where name='gao1' and password='aa' or 1='1';

//看看有没查询到用户
if(查询到){
	header(“其它页面”);
}else{
	header(“其它页面”);
}


	-----防攻击的解决方案

1, 使用预处理编译
2，改变验证数据库用户逻辑
$sql = "select password from user1 where name='xx'";
 //先看看有没有查询的记录，如果有，说明用户存在。

if(从数据库查询的密码==用户输入的密码){
	//用户名和密码合法
	header("其它页面");
}else{
	header('其它页面');
}








	实例-----用表格的方式显示数据表的信息和内容
	

//关键字($res->num_rows		获得数据表的行数)
//关键字($res->field_count	获得数据表的列数)
//关键字($field = $res->fetch_field()	获取表的信息)
//关键字($field->name		获取表信息--表头的名字)

<?php
function showTable($table_name){
	$mysqli=new mysqli('localhost','root','abcd','words')or die('failed');
	$mysqli->query('set names utf8');
	$sql = "select * from $table_name";
	//$sql = "desc user1";
	$res = $mysqli->query($sql);
	//如何获取返回总行数和列数
	echo "共有 $res->num_rows 行 $res->field_count 列";	//关键字

	echo "<table border=1><tr>";
	while($field=$res->fetch_field()){		//关键字
		echo "<th>{$field->name}</th>";		//关键字

	}
	echo "</tr>";
	while($row=$res->fetch_row()){
		echo "<tr>";
			foreach($row as $val){
				echo "<td>$val</td>";
			}
		echo "</tr>";
	}
	echo "</table>";
}
	showTable('user1');

?>






---------------------------------------------------------------------
		

		=====超全局变量=====



php手册--语言参考--预定义变量---超全局变量

超全局变量： 是在全部作用域中始终可用的内置变量。
PHP中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用，在函数或方法台无需执行 global $variable; 来访问它们。



         -----全局变量:

<?php
	$a=23;	//这就是全局变量，因为该变量在整个作用域（这个PHP文件中）,都可用.
	function test(){
		//如果希望使用到全局$a.
		global $a;
		$a=45;
	}
	test();
	echo $a;
?>





	-----超全局变量(9种)：


php提供了九种超全局变量：
1，$_GET
2, $_POST
3, $_REQUEST
4, $_ENV
5, $_SERVER
6, $_FILE
7, $_COOKIE
8, $_SESSION
9, $_GLOBALS



超全局变量除了有全局变量的特点外，可无须申明，直接使用。
提供全局变量数组的原因是为了让程序员更方便快捷的写出PHP程序。


<?php
	echo "<pre>";
		echo print_r($_SERVER);    //这就是全局变量
	echo "</pre>";
	$_SERVER['hsp'] = '韩顺平';	//全局变量还可以自定义添加
	
?>






	-----$_GET 实际使用

关键字：<a href='a.php?city=北京好&name=xiaoming'>传送数据</a> 		超连接中直接以传值到另一页面


客户机（浏览器）通过超链接传送信息给服务器
案例1 

test.php页面
<?php
	echo "<a href='a.php?city=北京好&name=xiaoming'>传送数据</a>";   //关键字
?>

a.php页面
<?php
	echo "<pre>";
	echo	print_r($_GET);
	echo "</pre>";
	//如果希望指定取出某个数据，则可以通过下标名	
	echo $_GET['name'];
?>





	-----解决GET在传送中文时出现错误的方法GET法1：

//关键字： urlencode()	urldecode()	对中文编码，解码。适用于GET地址传值。
给奇数中文加一个全角空格，然后到服务器接收时，用 trim() 去掉两头的空行 


解决方法2:
使用 urlencode 和 urldecode 函数

例：
test.php页面
<?php
	//这句话是对中文url编码
	$str = urlencode("北京好");
	echo "<a href='a.php?city=".$str."&name=xiaoming'>传送数据</a>";

?>

a.php页面
<?php
	echo "<pre>";
	echo print_r($_GET);
	echo "</pre>";
	echo $_GET['CITY'];
//如果希望指定取出某个数据，则可通过下标名。如果PHP版本较低，可能看到乱码，则用urldecode()
?>




	-----如何判断是否接收到数据（值）

//关键字: empty()	检测是否为空值
//关键字: isset()	检测是否为空值

有些老版本可能不认isset(),所以尽量使用empty()方法，

方法一： empty()
	if(empty($_GET['city'])){		//关键字
		echo "没有收到";
	}else{
		echo "收到数据 city";
		echo $_GET['city'];
	}


方法二：isset()
	if(isset($_GET['city'])){		//关键字
		echo "收到数据city";
		echo $_GET['city'];
	}else{
		echo "没有收到数据";
	}






	----- 在apache的conf.ini中不要启用register_globals
关键字：register_globals       注册全局变量。

b.php页面：

<?php
	echo $name.'--'.$age;
?>

http://xxxx/b.php?name=kk&age=99
如果开启register_globals 会有SQL注入风险


所以绝对不要启用register_globals 需要 register_globals = off






	-----超全局量--POST和GET以及它们的区别：
	-----超全局变量--$_REQUEST

1. 安全性 POST 大于 GET
2. 数据传输大小 POST 大于 GET ,PHP本身对两种方式的传输并没有限制，而是不同的浏览器的限制不同。
3. GET更方便保存到收藏夹 
4, GET传输是以地址栏的明文方式传输，POST则不是。




	-----超全局变量--$_REQUEST

//关键字：$_SERVER['REQUEST_METHOD']	检测request接收数据时是以什么方式（post/get/cookie）

$_REQUEST 中可以接收包括 $_GET, $_POST, $_COOKIE 数组的信息.

快速入门：

<?php
	echo "<pre>";
	echo print_r($_REQUEST);
	echo "</pre>";
	//如何取出某个值
	//$_REQUEST 即可以接收get 请求数据，也可以接收post请求数据和cookie请求数据。所以这个变量比较不可以信，不建议使用。只适用在不知道接收数据是以什么方式的时候用。
	echo $_REQUEST['AA'];
	//如果不确定 get/post
	if($_SERVER['REQUEST_METHOD']=='POST'){			//关键字
		//则用post方式接收
	}else if($_SERVER['REQUEST_METHOD']=='GET'){
		//则用GET接收
	}
?>



----------------------------------------------------------------------------------------



		2014.8.18号开始全部由此记录









	-----超全局变量--$_SERVER

$SERVER 中主要包含了http请求行和消息头的信息，同时还有服务器自己的一些信息，
	比如DOCUMENT_ROOT	SCRIPT_FILENAME.
举例说明：
1，请获取请求该页面的客户机ip地址
$_SERVER[REMOTE_ADDR]

2,请显示服务器端apache 的版本号和php版本号
$_SERVER[]SERVER_SOFTWARE]






	-----超全局变量--$_ENV
该全局变量数组可以获取环境变量，在php5.3中默认禁用，但是你可以在php.ini中启用

环境变量： 当我们希望获取服务器端的环境信息时，可以使用$_ENV
在PHP5.35中，默认情况下不能使用$_ENV你会得到空值，这是出于对安全的考虑，如果希望使用$ENV可以通过修改php.ini的variables含义]，但是在开发环境，不建议这样配置。
 






	-----超全局变量--$GLOBALS
一个包含了全部变量的全局组合数组，变量的名字就是数组的键, 同时一个自定义的全局变量，也会自动的被$_GLOBALS管理，具体看案例，

<?php
	echo "aaa";
	echo "<pre>";
	echo print_r($GLOBALS);
	echo "</pre>";
?>

当你定义一个全局变量，该变量也会被$GLOBALS管理
<?php
	$a = 900;
	echo "<pre>";
	print_r($GLOBALS);
	echo "</pre>";
?>








	=====IDE集成开发工具 zend studio =====

zend studio 是以工程的方式来管理php/js/css,,,,等文件的
使用流程：
1，创建一个项目。
2，设置该项目的路径
	取消 use default 默认路径的选项，然后自行设置。
3，创建一个文件


 	-----zend studio设置编码格式：
工具栏 --> windows --> preferences --> general --> content Type --> text  设置成utf-8


	
	-----zend studio快捷键设置
自定义设置快捷键：工具栏 --> windows --> preferences --> general --> Keys -->
	点击上面unbind解除，自定义后点击右侧apply 保存设置。


1, 快捷助手：（->content Assist ）
	alt + /
	

2, 删除当前行
	ctrl + d 

3, 复制当前行
	ctrl + alt + 下光标

3, 区块注释
	shfit + ctrl +\   取消 shift + ctrl + /

4, 行注释
	ctrl| + /  再按一次则取消 
	

5, 调试PHP代码的快捷键
	F5 跳入
	F6 跳过（按顺序执行）
	F7 跳出（跳出函数）

6, 更改字体颜色：
windows --> preferences--> php --> editor --> Syntax Coloring;



	-----断点：
所谓断点，就是指当我们的程序执行到这里的时候，就会停止执行，等待程序员下一步指令。

	调试：我们为了发现代码的错误，可以逐行执行代码，同时看到，变量的变化，这个过程称之为调试，调试的目的，就是为了发现隐藏的错误。

	-----建立断点：
在运行语句前面的坚排区内，双击相应的语句。

	-----删除断点：
对相应的语句再次双击。

	-----删除全部断点：
在PHP Debug模式下的Breakpoints 区中可以删除指定或全部断点。









	-----编写雇员管理系统

主要目的：
	1，培养编写项目的感觉
	2，认识我们的MVC模式
	3，规划项目
	4，融入各个知识点（PHP基础，HTML，数据库，开发模式，cookie,seession等）




	-----原型开发：


需求分析 - 设计阶段 - 编码阶段 - 测试阶段 - 发布阶段 - 维护阶段

需求阶段：需要设计人员/项目经理 对客户（领导）->需求文档
设计阶段：技术人员（架构师，组长，程序员）-> 设计数据库
开发阶段：组长，程序员
测试阶段：测试人员
发布阶段：实施人员（实施工程师）
维护阶段：往往是从开发人员中调.

美工（PS画图）-》网页前端人员（HTML） 完成原型 -》客户签字 -》程序开发。





		-----雇员关系系统开发文档
一：需求分析：
	该项目完成如下功能：
	1，管理员可以登录到管理界面
	2，可以对雇员进行增加
	3，可以对雇员进行修改
	4，可以查看雇员信息（分页显示）
	5，可以删除雇员信息	
	附带：可以实现用户在一定时间不用反扑登录，可以统计网站访问的次数。
二：画出uml时序图
三：设计界面
四：设计数据库






	-----设计代码：
1，要求大家先完成，不到数据库验证，就可以登陆成功，如果不成功，给出提示。
2，要求到数据库去验证，该用户是否存在。
3，在管理页面显示登陆成功的人名字。
	思路，通过跳转把用户名递给 另一页面
4, 在用户列表页面 显示所有的用户信息
5，考虑分页显示我们的用户信息。







	

		-----网站的开发经过的三个阶段

model1 -> 分层(mv) ->mvc模式



model1:基本概念是：
	把界面和业务放在一个页面完成

分层模式：基本概念是：
	把界面和业务分开编写，好处是结构清晰，利于分工开发。

mvc模式：基本概念：
	强制把数据的输入，数据的处理，数据的显示分开。



	分层的核心思想： 就是把界面和业务分离，具体做法是：每张实体表会对应两个文件，一个admin.class.php,一个adminService.class.php







	-----使用分层模式来完成雇员信息分页的功能
1,在什么文件中去封装我们的分页代码（哪个表就操作相对应的对象类文件）
2,通过分析我们知道为了完成分页我们的文件需要两个重要的数据，一个是count 一个是数据$res







	-----MVC开发模式：
	模型（m-modle）-视图（V-view）-控制器（C-controller） MVC是Xerox PARC施乐帕克研究中心在八十年代为编程语言Smalltalk-80发明的一种软件设计模式，至今已被广泛使用。
	MVC是一个设计模式（核心思想），它强制性的使应用程序的输入，处理和输出分开.
	使用MVC应用程序被分成三个核心部件，模型，视图，控制器，它们各自处理自己的任务。
	M 主要由类为做，用于处理具体的业务逻辑
	V 由PHP来做，主要用于做界面（即显示数据）
	C 有PHP来做，用于去响应用户的各种请求（比如，增删改）



	-----MVC处理过程：
1，首先控制器接收用户的请求，并决定应该调用哪个模型（service）来进行处理
2, 然后调用模型来处理用户的请求并返回数据。
3，最后控制器用相应的视图显示模型返回的数据，并通过浏览器呈现给用户。















	=====cookie 和cession=====
什么是会话：
	打开浏览器，访问某个网站的很多页面（通过点击超链接），当你关闭浏览器后，一个会话结束。
思考一个问题？
	在一个会话过程中，用户会产生一些数据，比如购物车，每个用户查看购物车的时候，看到自己的选择怎么实现？

	
再思考一个问题？
	为什么youku可以保存你上次看过的电影？

解决之道
	会话技术 cookie,session =>http协议




	-----coolie的初步介绍

cookie是保存在客户端的，cookie都可以做什么呢：
1, 保存上次登陆时间等信息。
2，保存用户名，密码，在一定时间不用重新登陆。
3，记录用户访问网站的喜好（比如有无背景音乐，网面的背景色是什么）。
4，网站的个性化，比如定制网站的服务。等内容。

当cookie 被设置后，便可以在其它页面通过 $_COOKIE 或 SHTTP_COOKIE_VARS 数组取得其值，需要注意的是，autoglobals的 $_COOKIE 形式适用于 php4.1.0或更高版本,而$http_COOKIE_VARS则从PHP3起就可以使用，Cookie 的值也会被保存到 $_REQUEST数组中。


	-----setcookie()参数 ；
name  	cookie的名字
value  	cookie的值
expire 	cookie过期的时间  	例：time()+60*60*24*30将cookie30天后失效。如未设定，cookie 将在会话	后失效。一般是浏览器关闭。
path	cookie 在服务器端的有效路径     例：如果该参数设定为“/”的话,cookie就在整个domain内有效，	如果设为"/foo",cookie 就只在domain下的/foo/目录及其子目录内有效，如/foo/bar/.默认为设定	cookie的当前目录。
domain	指明cookie是否仅通过安全的HTTPS连接传送，当设成true时，cookie仅在安全的连接中被设置，默认为	false  0或者。


	-----cookie的基本使用
php manual  其它服务-Network-Network 函数 - setcookie

1, Cookie在客户机（浏览器） 就是一个字符串，其形式如下：
	name2 shuping localhost/cookie/1024412349874823743823749284293492409*

2: 如何创建一个Cookie(在服务端创建的)
bool setcookie (string name [,string value [,int expire [,string path [,string domain [,bool secure]]]]])

3,如何读取cookie（从客户端读到服务器）
	$_COOKIE['cookie的名字'];

4, 如何删除一个cookie值；
	要删除cookie需要确保它的失效期是在过去，才能触发浏览器的删除机制。




	-----创建cookie信息：

//把用户名和密码保存到客户端的cookie
//这个函数用于保存cookie
//第一个参数表示cookie 的key  ，第二个参数表示对应的val值，第三个参数表示 保存时间
//客户端保存时间以秒计算.


<?php
	setCookie('name','shunping',time()+3600); 	//time()是当前时间的意思
	setCookie('password','123456',time()+3600);	//第二条键值对
	setCookie('address','北京',time()+3600);	//第三条键值对
	echo "保存成功！";
?>


保存的cookie页面：

name			//保存的key名
shunping		//保存的key值
localhost/cookie/	//cookie所在的主机
1024			//以下都是时间代码。
1784433024
30177331
149791392
30177323
*



对代码说明
1, 当浏览器访问cookie.php页面的时候，我们的服务器就会以 set-cookie: name=shunping,expire=@ed,1_Sep-2011 07:53:24 GMT 回送http响应，当浏览器获取到该信息后，就会保存该cookie的新到本机的 C:/xxx.admin/cookies文件。

2, 如果我们如果没有设置时间参数(第三个参数)
cookie 不会保存到客户端，当浏览器的会话结束，我们的cookie就失效。

3，cookie 能保存什么样的信息，就是字符串。
4, cookie 的有效保存时间如果过期则无法取到cookie结果/
5, cookie 可以保存多个健值对

	


	-----cookie 信息的创建，获取，更新，删除，

	//创建cookie信息
<?php
	setCookie('name','shunping',time()+3600); 	//time()是当前时间的意思
	setCookie('password','123456',time()+3600);	//第二条键值对
	setCookie('address','北京',time()+3600);	//第三条键值对
	echo "保存成功！";
?>


	-----获取 cookie 信息
<?php
	echo "<pre>";
	print_r($_COOKIE);
	echo "</pre>";
	
	//获取指定的key对应的值；
	$name=$_COOKIE['name'];
	echo "name=".$name;

?>
<?php
	-----更新 cookie信息

	更新某个cookie key<==>val实际上就是重新设置
	setCooke();
?>



<?php
	//-----删除 cookie 信息
	setCookie('name','',time()-1);  //单条删除

	foreach($_COOKIE as $k=>$v){
		setCookie("$k",'',time()-1);	//删除全部
	}
	echo "删除成功！！！！";
?>





	-----显示上次登陆时间（不严谨）

<?php
	if(empty($_COOKIE[lastVisit])){
		echo "首次登陆";
		setCookie('lastVisit',date("Y-m-d H:i:s"),time()+9999);
	}else{
		echo "您上次登陆的时间是:".$_COOKIE[lastVisit];
		setCookie('lastVisit',date("Y-m-d H:i:s"),time()+9999);
	}
?>









	-----解决时差问题的两种方案

方案一：
	在PHP文件中设置：
	date_default_timezone_set("Asia/Chongqing");


方案二：
	在php.ini 文件中找到下列代码：
[Date]
; Defines the default timezone used by the date functions
;date.timezone =

	添加如下内容：
	date.timezone = Aisa/Chongqing




	-----php出现Cannot modify header information问题的解决方法
	-----cookie 或header出现information错误的解决方法

查找网上解决此问题的方法多是一样的，不过今天又遇到了这样的问题。试过之后发现可行： 
在C盘的WINDOWS中找到php.ini 这个配置文件，然后查找一项：output_buffering将其值由原来的off改为on，重新启动Apache就ok了。 
















		=====Session====
---php Manual ---函数参考---Session扩展---Session---Session函数



1, Session是服务器端技术
2, 原理： 每个浏览器都会对应一个Session 当浏览器浏览众多的资源时，都会对同一个Session进行读写。
3, Session 保存路径默认是C:/windows/temp 文件夹，但在php.ini中可以改变其它保存路径
	改变路径：打开php.ini找到Session区：的 session.save_path = "" 来更改。	

4， Session的基本用法（crud）增删改查
	保存数据的格式；
	name|s:8:"shunping";
name就是key ; s:表示数据类型（string） ; 8:表示数据的大小 ; shunping是数据的value 

5, Session 的操作都要先初始化 Session_start();   之后才能生效。
6, 一个会话对应一个session文件（就是每打开一次浏览器才会对应一个SESSION，而有一个浏览器的多页面共用一个SESSION）
7，SESSION的数据默认存在时间为1440s(即24分钟)，但可在php.ini 的[session]节中可以进行调整设置.
	找到： session.gc_maxlifetime = 1440   		可根据需要将1440改为其它值。
  	注意：SESSION的保存时间是发呆时间，原理是当SESSION文件24分钟内没有被访问就会自动删除。如果在23分时被访问过一次，那么这个保存时间就会被重新计算。	





		-----cookie 和 session 在php.ini中的设置：

1，session.name
	该配置用于设置session的名字 就是PHPSESSID  这个值可以通过session_name()来获取
在php.ini文件中找到 session.name = PHPSESSID    这里可以把PHPSESSID 指定为自己希望的名字。


2，session.use_trans_sid=0
	给每个URL启用 session名=sessionId,安全有影响，不推荐开启。



3,session.save_path="C:/mysession"
	设置session的保存路径


4, session.gc_maxlifetime=1440 		默认最大生命周期（发呆时间，不是到时间就删）
5, session.gc_probability = 1
6, session.gc_divisor = 1000 
	4，5,6,是垃圾删除机制，它们组合在一起使用。垃圾的回收机率是由5,6来决定的。当divisor / probability 的结果越大，说明处理的概率越高。如 1000/1000就是百分百处理，每当有人运行session_start()时都会启动垃圾回收机制。
如果是1 / 1000说明机率是千分之一，意思就是说每1000位用户运行session_start()时才会运行一次回收机制。当一个网站规模越大时，这个机率就要设的越小。不然经常启动回收机制，服务器会受不了！ 

7，session.Use_cookies = 1 	是否使用cookie

8, session.cookie_lifetime=0 	cookie保存时间，默认0，关闭浏览器就失效。
也可以这样设置 如：
setcookie('名字','val',time()+3600);   这里的time()+3600 就是设置了保存时间为3600秒
setcookie('名字',');	这里就是默认0保存时间，关闭浏览器就cookie就会失效。



		-----session 数据可以存放的位置
1,文件
2，数据库
3,内存 (memcache)
4, 网络文件 nfs  network file system


		-----php.ini 配置选项
php manual ---附录 ---php.ini配置选项




	-----session设置实例:

<?php
	//初始化Session
	//session start();
	session_start();
	
	//	-----保存session数据
	$_SESSION['name'] = "shunping";

	//session文件可以保存double,integer,bool,array,objec
	$_SESSION['age'] = 100; 	//integer
	$_SESSION['isBoy']=true;	//bool

	$arr = array('北京','小明','hello');
	$_SESSION['arr'] = $arr; 	//数组

	//保存对象文件
	class Dog{
		private $name;
		private $age;
		private $intro;
		function __construct($name,$age,$intro){
			$this->name=$name;
			$this->age = $age;
			$this->intro = $intro;
		}
		function getName(){
			return $this->name;
		}
		function getAge(){
			return $this->age;
		}
		function getIntro(){
			return $this->intro;
		}
	}
	
	$dog1 = new Dog('小花',18,'这是一个可爱的狗狗');
	$_SESSION['dog1']= $dog1;
	
?>

结果为：
name|s:8:"shunping";age|i:100;isBoy|b:1;arr|a:3:{i:0;s:4:"北京";i:1;s:4:"小明";i:2;s:5:"hello";}dog1|O:3:"Dog":3:{s:9:" Dog name";s:4:"小花";s:8:" Dog age";i:18;s:10:" Dog intro";s:18:"这是一个可爱的狗狗";}

解释： 
	s 代表字符串 string
	i 代表整数 integer
	b 代表布尔型  1 = true ; 0 = false;
	arr 代表数组
	0 代表对象
name|s:8:"shunping"	key 为 name 的值为：字符串:8字节:"shunping"
age|i:100		key 为 age  的值为：整数型: 100
isBoy|b:1		key 为 isBoy的值为: 布尔型: 1 (true)
arr|a:3:		key 为 arr  的值为: 数组：有3 组数据
	{i:0;s:4:"北京";i:1;s:4:"小明";i:2;s:5:"hello";}分别为：
		i:0;s:4:'北京'		含意是 下标i(整数型)为0的内容是 S(string字符串):4字节:值为"北京"
		i:1;s:4:"小明"		整数型的下标1,是4字节的字符串，值为'小明'.
		i:2;s:5:'hello'		整数型的下标2,是5字节的字符串，值为‘hello’。
dog1|0:3:"Dog":3: 	key 为 dog1 的值为: 对象: 3字节: 值为'Dog' : 对象包含3个属性
	{s:9:" Dog name";s:4:"小花";s:8:" Dog age";i:18;s:10:" Dog intro";s:18:"这是一个可爱的狗狗";}分别为：
		s:9:"Dog name"; 	字符串: 9字节:"Dog name"
		s:4:"小花";		字符串: 4字节:"小花"
		s:8:"Dog age";		字符串: 8字节:"Dog age"
		i:18;			整数型: 18
		s:10:"Dog intro";	字符串: 10字节:"Dog intro"
		s:18:"这是一个可爱的狗狗";	字符串:18字节:"这是一个可爱的狗狗"	





		-----获取 Session 数据

	取出对象时需要实现申明一下类的定义，（就是用require或include引用一个类文件）
<?php
	session_start();

	//把所有的session获取
	echo "<pre>";
	print_t($_SESSION);
	echo "<pre>";

	//通过key 来指定获取某个值
	echo $_SESSION['name'];
	$arr=$_SESSION['arr'];
	

	//取数组的数据
	foreach($arr as $k=>$v){
		echo $v."---";
	}

	//取出对象
	$xiaogou=$_SESSION['dog'];
	echo "<br>小狗的名字：".$xiaogou->getName();
	


	


	-----更新 Session 数据

	就是重新设置一下session
<?php
	//把原来的 name="shunping" 的值"shunping" 改为 "顺平"
	$_SEESION['name']="顺平";
	echo "更新成功";

?>








	-----删除 session 数据

<?php
	//删除单个SESSION
	session_start();
  	unset($_SESSION['name']);
	echo "删除name成功";

	//删除所有的session
	//这样会把当前这个浏览器对应的session文件一并删除。
	session_destroy();
?>


	

	-----通过 session 保存购物车简单案例

首页面：
<body>
	<h1>购买书籍</h1>
	<a href="buy.php?bid=sn1&bname=西游记">西游记添加到购物车</a><br><br>
	<a href="buy.php?bid=sn2&bname=红楼梦">红楼梦添加到购物车</a><br><br>
	<a href="buy.php?bid=sn3&bname=三国演义">三国演义添加到购物车</a><br><br>
	<a href="buy.php?bid=sn4&bname=水浒传">水浒传添加到购物车</a><br><br>
	<a href="mybook.php">查看我的购物车</a>
</body>

保存处理页面：
<?php	
	$bid=$_GET['bid'];
	$bname= $_GET['bname'];
	session_start();
	$_SESSION["$bid"]= $bname;
	echo "<font color='red' font-size='20'>成功将  $bname 加入购物车！";
	echo "<br><br><a href='mybook.php'>查看购物车</a>";
	echo "<br><br><a href='aa.php'>返回购物大厅</a>";
?>

购物车页面：
<?php
	session_start();
	$del=$_GET['del'];
	$delone=$_GET['delone'];
	if($delone){
		unset($_SESSION[$delone]);
	}
	if($del){
		session_destroy();
	}
	echo "您选购的书籍有：<br>";
	
	foreach($_SESSION as $key=>$val){
		echo $val."---<a href='mybook.php?delone=$key'>从购物车中删除</a><br>";
	}
	echo "<br><a href='mybook.php?del=de'>清空购物车</a><br>";
	echo "<br><a href='aa.php'>返回购物大厅</a>";
?>












	-----获取session 的id号

<?php
	$sid = session_id;
	echo "session的id号=".$sid;
?>




	-----Session和Cookie的主要区别及自动启动session：

Cooki 是把用户的数据写给用户的浏览器。
Session技术是把用户的数据写到用户独占的$_SESSION中，存在服务器的某个路径的文件中。

在使用$_SESSION 前要保证session被初始化，具体方法如下：
1，先调用session_start();
2, 配置php.ini session.auto_start = 1 (不推荐，会影响效率)






	

	-----用户禁用cookie后解决session文件共享的三种方法：


	当用户禁用cookie后，服务器每次session_start()都会创建一个全新的session文件，后果就是无法让多个页面的php去共享同一份session文件。 	
	如何解决这个问题？要从cookie session和http协议入手解决。

	如果客户端禁用cookie怎样实现session技术共享多个页面？


	方法一：URL重写，给每个连接添加一个指定的PHPSESSID;

在每个超链接上添加一个PHPSESSID= sessionId ,同时在每个页面加入if语句，判断是否以经有session文件，如果有就沿用，如果没有再创建新的session文件 .如：
	if(isset($_GET['PHPSESSID'])){
		//设置session_id
		session_id($_GET['PHPSESSID']);
	}
	session_start();



	方法二：使用常量SID ;

在 href=,header(),action=   时可以直接拼接SID 常量即可. 如：
echo "<a href='xxxx.php?bookid=sn001&bookname=西游记&".SID."'>西游记</a><br>";	


方法三：在php.ini中启用透明session功能。
可以启用 session.use_trans_sid 指定是否启用透明 SID 支持，即可以这样设置。
	session.use_trans_sid=1. 然后重启apache即可。
此方法相当于在 href=,action=,header(), 之后默认加上了 SID 。但不支持js的跳转。需要手动添加SID






		=====session的验证码技术

	为什么时候我们需要验证码？
1，防止登录时，恶意攻击。
2，防止灌水。

		

		-----验证码实例代码
	在第120课




	
		-----cookie 和session的区别

1: 存放的位置不同
	cookie保存在客户端，session保存在服务器端的  文件系统/数据库/memcache
2, 安全性
	比较而言 cookie 的安全性比session要弱 因为session保存在服务器
3, 网络传输量
	cookie 通过网络在客户端与服务器端传输，而session保存在服务器端，不需要传输。

4，生命令周期
	cookie的生命周期是累计的，从创建时就开始计时，到达指定时间后cookie生命周期结束，cookie就失效了。
	session的生命周期是间隔的，从创建时，开始计时，如在设定时间内没有访问session，则session超过庙宇时间后就会失效。如果在设定时间内再次访问了session,那么它的生命周期将重新开始计算。




		-----设置用户自定义session会话存储函数

有两种方式：
session.save_handler = files  //使用系统默认的
session.save_handler = user  //使用自己设置的

自设文件参考第121课内容






=====文件编程=====
	-----文件操作相关函数
	-----操作文件的六种方式
	-----第一种获取文件信息的方法
	-----第二种获取文件信息的方法-直接获取指定信息
	-----第一种读取文件内容的方法 fread()
	-----第二种读取文件内容的方法
	-----第三种读取文件方法。分批读取
	-----将有序内容的ini文件直接转化成数组





		=====文件编程=====
php manual--文件系统相关扩展---filesystem---filesystem函数


文件编程的必要性：
	1,在网站开发中，我们要使用到文件的上传和下载，就是经典的文件编程使用

文件的基本概念：
	文件就是保存数据（二进制数据，文本数据）,在程序员的角度看，文件就是数据来源。

文件流：
	在对文件进行操作的过程中，我们是以流的概念来操作的。当对内存进行输入数据时，叫做输入流。当在内存中向往外或向文件中输出数据时，叫做输出流。






	-----操作文件的六种方式
'r'	只读方式打开，将文件指针指向文件头。

'r+' 	读写方式打开，将文件指针指向文件头。

'w' 	写入方式打开，将文件指针指向文件头并将文件大小截为零，如果文件不存在，则尝试创建。

'w+'	读写方式打开，将文件指针指向文件头并将文件大小截为零，如果文件不存在，则尝试创建。

'a'	写入方式打开，将文件指针指向文件末尾，如果文件不存在则尝试创建。

'a+'	读写方式打开，将文件指针指向文件末尾，如果文件不存在则尝试创建。






	-----文件操作相关函数

parse_ini_file()	解析一个ini配置文件
str_replace()		子字符串替换
fread()			读取文件（可安全用于二进制文件）
fopen()			打开文件或者 URL
fclose()		关闭文件
feof()			测试文件指针是否到了文件结束的位置
file_exists()		检测文件是否存在
file_get_contents()	 将整个文件读入一个字符串
filectime()		 取得文件的 inode 修改时间
fileatime()		取得文件的上次访问时间 
filemtime()		取得文件的上次修改时间
filesize()		取得文件的大小
fstat()			通过已打开的文件指针取得文件相关信息

以上函数请参考 -----文件操作相关函数实例 


<?php	
	//-----第一种获取文件信息的方法
	//-----文件操作相关函数实例

	/*
	$file_path='a.txt'; //设置一个文件的路径
	if(file_exists($file_path)){	//检验文件是否存在
		echo "文件存在！<br>";
		$fp = fopen($file_path,'a+');	//打开这个文件					
		$arr=fstat($fp);		//把文件大小等相关信息存放到一个数组里   //fstat()
		echo "<pre>";
		print_r($arr);		//显示所有文件相关信息
		echo "</pre>";
		date_default_timezone_set("Asia/Chongqing");
		echo "<br>文件上次被访问的时间是: ".date("Y-m-d H:i:s",$arr['atime']);
		echo "<br>文件内容上次修改时间是：".date("Y-m-d H:i:s",$arr['mtime']);
		echo "<br>文件上次被移动的时间是：".date("Y-m-d H:i:s",$arr['ctime']);
	}
		
		
		
	//-----第二种获取文件信息的方法-直接获取指定信息
	
	$txt = "a.txt";
	echo "<br>文件的大小是：".filesize($txt)."字节！";			   //filesize();
	date_default_timezone_set("Asia/Chongqing");
	echo "<br>文件上次被访问的时间是：".date("Y-m-d H:i:s",fileatime($txt));   //fileatime()	
	echo "<br>文件上次被修改的时间是：".date("Y-m-d H:i:s",filemtime($txt));   //filemtime()
	echo "<br>文件上次被移动的时间是：".date("Y-m-d H:i:s",filectime($txt));   //filectime()
	
	
	
	//-----第一种读取文件内容的方法 fread()
	
	$txt="a.txt";
	if(file_exists($txt)){								
		$fp=fopen($txt,'a+');		//打开一个文件，需要两个参数 文件名和读取方式
		$fa = fread($fp,filesize($txt)); //把文件内容读取到一个变量内。
		echo $fa;				//显示内容
	}else{
		echo "文件不存在！";
	}
	fclose($fp);				//关闭文件				
	

	
	//-----第二种读取文件内容的方法
	//-----第三种读取文件方法。分批读取
	//-----将有序内容的ini文件直接转化成数组
	$txt = "a.txt";			//设置文件的路径
	$con=file_get_contents($txt);	//把文件内容读取到一个变量中		//file_get_contents()
	//echo $con;				//显示内容，但这里会忽略空格和换行
	$con=str_replace("\r\n","<br>",$con);										   //str_replace()将文件中默认的换行符"\r\n"转换成浏览器识别的<br>
	echo  $con;
		//这个函数不需要关闭文件
	

	//-----第三种读取文件方法。分批读取
	
		//等全部读完后再显示。
	$txt="a.txt";
	if(file_exists($txt)){						//file_exists()
		$fp=fopen($txt,'a+');
		$buffer=1024; //设置每次读取字节大小
		$str ="";		//设置一个用于存放被读取内容的变量
		while(!feof($fp)){	//只要文件没结束就不断循环读取		//feof()
			$str.=fread($fp,$buffer);
		}
		$str=str_replace("\r\n","<br>",$str);
		echo $str;
		fclose($fp);						//fclose()
	}
			//读一段，显示一段
	$txt = "a.txt";
	if(file_exists($txt)){
		$fp=fopen($txt,'a+');					//fopen()
		$str='';
		$buffer=1024;	
		while(!feof($fp)){
			$str=fread($fp,$buffer);			//fread()
			$str=str_replace("\r\n","<br>",$str);		//str_replace()
			echo $str;
		}
	}else{
		echo "文件不存在！";
	}
	

	
	//-----将有序内容的ini文件直接转化成数组
	$txt = "c1.ini";
	$arr=parse_ini_file($txt);			//parse_ini_file()
	print_r($arr);
	*/
	/*
		//t.ini文件内容
		host=localhost
		user=root
		psw=abcd
		db = test
	*/
	
?>











<?php
/*
	//-----第一种写入方式 fwrite()

	$txt = 'b.txt';
	if(is_file($txt)){
		$fp=fopen($txt,'a+');
		fwrite($fp,"helloword\r\n");
		echo "写入成功！";
		fclose($fp);
	}



	
	//-----第二种写入方式 file_put_contents()

	$txt="b.txt";
	$com ="";
	for($i=1;$i<30;$i++){
		$com.= "aaaaabbbbb\r\n";
	}
	file_put_contents($txt,$com);
	echo "ok";
	
	
	//=====文件的拷贝

	//-----不带中文路径的文件复制

	if(copy('c:/aa.jpg','d:/aa3.jpg')){
		echo "ok";
	}else{
		echo 'failed';
	}
	
	
	//-----带中文路径的文件复制

	$img=iconv("utf-8","gbk","c:/一二三/aa.jpg");
	if(copy($img,"d:/img1.jpg")){
		echo "ok";
	}else{
		echo "failed";
	}
	
	
	//-----创建一个文件夹 mkdir()
	$dir1 = "c:/aaa";
	if(is_dir($dir1)){
		echo "文件存在";
	}else{
		mkdir($dir1);
		echo "创建成功";
	}
	
	
	//-----同时创建多层级文件 mkdir($dir,0777,true)
	$dirs = "C:/b/c/d/e/f";
	if(is_dir($dirs)){
		echo "文件夹存在！";
	}else{
		if(mkdir($dirs,0777,true)){
			echo "创建成功！";
		}
	}
	
	
	
	//-----删除文件夹 rmdir()
	//删除的文件夹必须为空，不然报错！
	$dir="c:/b";
	if(is_dir($dir)){
		if(rmdir($dir)){
			echo "删除成功";
		}else{
			echo "删除失败";
		}
	}else{
		echo "文件夹不存在！";
	}
	
	
	
	//-----创建一个文件并写入内容 
	$path="c:/b/c.txt";
	if(is_file($path)){
		echo "文件存在";
	}else{
		$fp=fopen($path,'w+');
		if(fwrite($fp,'北京是一个大城市')){
			echo "创建并写入成功";
			fclose($fp);
		}else{
			echo "失败";
		}
	}
	
	
	
	//-----删除一个文件  unlink()
	$con="c:/b/c.txt";
	if(is_file($con)){
		if(unlink($con)){
			echo "删除成功";
		}else{
			echo "删除失败";
		}
	}else{
		echo "文件不存在！";
	}
	*/
	
?>





	


		-----文件上传
文件上传类型的模式
<form action="" enctype="multipart/form-data" method="post">
	<input type="file" name="myfile"/>
	<input type="submit" value="上传" />
</form>








	=====文件的上传
上传文件要考虑的细节问题
	1, 如何控制用户上传的文件大小
	2，如何控制用户上传的文件类型
	3，如何防止用户图片覆盖的问题	
	4，如何防止同一个用户上传的文件名相同问题



<?php
	// -----文件上传大小的限制
	if($_FILES['file']['size']>2*1024*1024){
		echo "文件过大！";
		exit();
	}

	//-----文件上传类型的限制
	$type=$_FILES['file']['type']; //文件的类型
	if($type!="image/jpg" && $type!="image/jpeg"	){
		echo "文件类型不对！";
		exit();
	}


	//-----防止用户图片覆盖问题及上传文件同名问题
	$tmpFile=$_FILES['file']['tmp_name'];	//上传缓存文件
	$name=$_FILES['file']['name'];		//上传的文件名
	$toFile=$_SERVER['DOCUMENT_ROOT']."/up/img/".time().rand(1,100).substr($name,strrpos($name,".")); //存放文件的路径 $_SERVER 是显示根目录函数， time()显示当前时间，rand()随机抽取1-100中的数字。substr()选择字符串中的子串，strrpos()确定指定的字符的位置。 也可以在路径中加上用户名的变量来区分每个用户的文件上传。
	echo $name."<br>".strrpos($name,".")."<br>";
	if(is_uploaded_file($tmpFile)){			//检测文件是否为POST传输的文件。
		if(move_uploaded_file($tmpFile,$toFile)){
			echo "上传成功！";
		}
	}
?>




















		=====PHP 报表开发=====


	-----php绘图坐标系统
php绘图坐标系统 和JAVA坐标系统一样。横向为X轴，纵向为Y轴。 X轴向右走数值变大。向左走数值变小。
Y轴向下走变大，向上走变小。

php manual--函数参考----图像生成和处理----GD---- and Image



	
	-----php绘图技术
1，PHP绘图的基本原理和步骤
	创建画布
	绘制各种需要的图形，（圆，直线，矩形，孤线，扇形等）
	输出图像到网页，也可以另存
	销毁该图片（释放内存）


	-----常见的图片格式和应用范围
1，GIF 图片压缩率高，但是只能显示256色，可能造成颜色丢失，可显示动画。
2，JPG/JPEG 图片的压缩率高（有损压缩），可以用较小的文件来显示，网页上用的比较多。
3，PNG 该格式综合了GIF和JPG的优势，缺点是不能显示动画。它对颜色高保真！

如何选择哪种格式的图片：
当对图片颜色要求不高时，首选GIF
当对图片颜色要求相对较高，但不是十分严格时，可选JPG
当对图片颜色要求非常高，比如说艺术品或古董一类的要求细节的图片时就要选择PNG格式。




	-----启用图像库
在apache 的conf.ini中找到 extnesion=php_gd2.dll 并启用。切记要重新启动apache服务器。才会有效。




	-----PHP绘图实例

<?php
	//创建画布，默认的背景是黑色
	$im=imagecreatetruecolor(400,300);
	
	//创建一个颜色
	$red=imagecolorallocate($im,255,0,0);
	//圆
	imageellipse($im,20,20,20,20,$red);
	
	//直线
	imageline($im,0,0,400,300,$red);
	
	//空心矩形
	imagerectangle($im,300,4,350,40,$red);
	
	//实心矩形
	imagefilledrectangle($im,250,60,310,110,$red);
	
	//弧线
	imagearc($im,100,100,60,60,90,180,$red);
	
	//扇形	1，IMG_ARC_PIE 2,IMG_ARC_CHORD 3,IMG_ARC_NOFILL 4,IMG_ARC_EDGED
	imagefilledarc($im,150,150,60,60,180,270,$red,IMG_ARC_PIE);
//解释(画布，起始X坐标，起始Y坐标，终点x坐标，终点y坐标，起始角度，终点角度，颜色，形式。)
	
	//拷贝图片到画布
	//1.加载图片
	$srcImage=imagecreatefromgif("cx.gif");
	//2,拷贝源图片到目标画布
	imagecopy($im,$srcImage,50,50,10,10,80,31);
//解释（画布，图片在画布的起始X点，图片在画布的起始y点,截取图片的起始X点，截取图片的起始y点，截取图片的X终点，截取图片的Y终点）
	//3，可使用函数获取图片信息 getimagesize()
	$info=getimagesize('cx.gif');
	imagecopy($im,$srcImage,100,100,0,0,$info[0],$info[1]);
	
	//画字符串
	imagestring($im,5,20,20,"hello吕文",$red);
//(画布，字体大字，位置X，位置Y，字符串，颜色) imagestring()函数中文会乱码。
	
	//画带中文的字符
	$str="hello,中国地区地区";
	imagettftext($im,30,30,10,290,$red,"simhei.ttf",$str);
//(画布，字体大小，旋转角度，位置X，位置Y，颜色，字体选择，字符串) 字体选择去windows/fonts 目录下找。 这个函数可能会不识别utf-8码,要选择utf-8无BOM格式。
	
	//输出图象到网页，也可另存
	header("content-type: image/png");
	imagepng($im);
	
	//销毁该图片（释放内存）
	imagedestroy($im);
?>









<?php
	-----PHP绘图圆柱形三块分布图

	$bg = imagecreatetruecolor(400,300);
	//将背景色填充为指定颜色
	$white = imagecolorallocate($bg,235,235,235); 
	imagefill($bg,0,0,$white);
	
	$red=imagecolorallocate($bg,255,0,0);
	$gre=imagecolorallocate($bg,0,255,0);
	$blu=imagecolorallocate($bg,0,0,255);
	$red1=imagecolorallocate($bg,200,0,0);
	$gre1=imagecolorallocate($bg,0,200,0);
	$blu1=imagecolorallocate($bg,0,0,200);
	//imagefilledarc($bg,100,100,100,50,0,35,$red1,IMG_ARC_PIE);
	for($i=180;$i>=100;$i--){	//调节高度可以改变$i=180的值。
		imagefilledarc($bg,100,$i,100,50,0,35,$red1,IMG_ARC_PIE);
		imagefilledarc($bg,100,$i,100,50,35,70,$gre1,IMG_ARC_PIE);
		imagefilledarc($bg,100,$i,100,50,70,360,$blu1,IMG_ARC_PIE);
	}
	imagefilledarc($bg,100,100,100,50,0,35,$red,IMG_ARC_PIE);
	imagefilledarc($bg,100,100,100,50,35,70,$gre,IMG_ARC_PIE);
	imagefilledarc($bg,100,100,100,50,70,360,$blu,IMG_ARC_PIE);
	
	header('content-type: image/png');
	imagepng($bg);

?>







	=====图表开发库 jpgraph

1，先下载。下载官网：http://jpgraph.net
2, 解压，
3，把example目录的其它文件剪切到example文件夹内，注意新建文件夹的名字一定是jpgraph





	-----graph解决乱码函数

$graph->title->setFont(FF_ARIAL,FS_BOLD,14); 这样的标题会出现乱码。
解决方法：找到graph/ipgraph_ttf.inc.php 并打开，找到如下内容并复制其一：
// Chinese font
define("FF_SIMSUN",30);
define("FF_CHINESE",31);
define("FF_BIG5",32);
$graph->title->setFont(FF_SIMSUN,FS_BOLD,14);  //如此即可



	-----奥巴马与布什竟选择接数据库案例
请参看第131,132课。 内容有点看不懂！重点学习！









<?php
	-----以带干扰的图片方式做验证码
	
	
	//图片页面
	
	$str="";
	for($i=1;$i<5;$i++){
		$str.=dechex(rand(1,15));
	}
	session_start();
	$_SESSION['code']=$str;
	$im = imagecreatetruecolor(110,30);
	$red = imagecolorallocate($im,255,255,255);
	//加入干扰线
	for($i=1;$i<20;$i++){
		imageline($im,rand(0,110),rand(0,110),rand(0,30),rand(0,30),imagecolorallocate($im,rand(0,255),rand(0,255),rand(0,255)));
	}
	imagestring($im,rand(1,7),rand(0,80),rand(0,20),$str,$red);
	header("content-type: image/png");
	imagepng($im);
?>



<?php
	//验证处理页面
	// -----script this.src 点击图片变换图片内容
	//把 ?php 移动到img src下面 
<form action='' method='post'>
请输入验证码：<input type='text' name='text' />
	<input type='submit' value="提交" />
</form>
<img src="bb.php" onclick="this.src='bb.php?aa='+Math.random()" />

	session_start();
	$code=$_SESSION['code'];
	$verify=$_POST['text'];
	if(!empty($verify)){
		if($code==$verify){
			echo "<br><font color='red'>输入正确</font>";
		}else{
			echo "<br>输入错误，请重新输入！";
		}
	}
?> 





		=====PHP网上支付=====

-----网上支付目前有两种支付方式：
	1，直接和银行对接
		优点是安全性高
		缺点是工作量大，而且需要资格审核
	2，和中间公司对接
		优点是开发维护方便
		缺点是存在安全隐患


	

-----目前国内比较好的中间公司

	首信易支付：www.heijing.com.cn
每年需要交纳一定的接口使用费，并且从交易金额中扣除1%的手续费，像当当网，红孩子，京东商城使用了首信易支付。
	
	
	易宝支付：www.yeepay.com
接入免费，只从交易金额中扣除1%的手续费，像盛大，E龙网，巴巴运动网使用了易宝支付。






-----易宝支付协议介绍：
	1，支付请求是HTTPS协议请求，商户以GET或POST方式发送到易宝支付。
	2，易宝支付平台统一使用GBK/GB2312编码方式。
	3，参数名称和参数说明中规定的固定值必须与列表中完全一致）（大小写敏感）；








<?php
	-----易宝网上支付系统案例

	//---首页 
	/*
<html>
<head>
	<title>我的支付系统</title>
	<meta http-equiv="content-type" content="text/html; charset=gb2312"/>
</head>
<body>
<form action="b.php" method="post">
<table>
	<tr>
		<td colspan="4">
		订单号：<input type='text' name='p2_Order'/>
		支付金额:<input type='text' name='p3_Amt'/>
		</td>
	</tr>
	<tr>
		<td colspan='4'>请选择支付银行</td>
	</tr>
	<tr>
		<td><input type='radio' name='pd_FrpId' value='CMBCHINA-NET' />招商银行</td>
		<td><input type='radio' name='pd_FrpId' value='ICBC-NET' />工商银行</td>
		<td><input type='radio' name='pd_FrpId' value='ABC-NET' />农业银行</td>
		<td><input type='radio' name='pd_FrpId' value='CCB-NET' />建设银行</td>
	</tr>
	<tr>
		<td colspan='4'><input type='submit' value='确认支付'/></td>
	</tr>
</table>
</form>
</body>
</html>




	//-----支付处理页面
	
<html>
<head>
	<title>我的支付系统</title>
	<meta http-equiv="content-type" content="text/html; charset=gb2312"/>
</head>
<?php
	require_once 'test.php';
	//获取用户提交的信息
	$p0_Cmd="Buy";
	$p1_MerId="10012226645";
	$p2_Order=$_POST['p2_Order'];
	$p3_Amt=$_POST['p3_Amt'];
	$p4_Cur="CNY";
	$p5_Pid="";
	$p6_Pcat="";
	$p7_Pdesc="";
	$p8_Url="http://localhost/c.php";
	$p9_SAF='0';
	$pa_MP="";
	$pd_FrpId=$_POST['pd_FrpId'];
	$pr_NeedResponse="1";
	
	$data="";
	$data=$data.$p0_Cmd;
	$data=$data.$p1_MerId;
	$data=$data.$p2_Order;
	$data=$data.$p3_Amt;
	$data=$data.$p4_Cur;
	$data=$data.$p5_Pid;
	$data=$data.$p6_Pcat;
	$data=$data.$p7_Pdesc;
	$data=$data.$p8_Url;
	$data=$data.$p9_SAF;
	$data=$data.$pa_MP;
	$data=$data.$pd_FrpId;
	$data=$data.$pr_NeedResponse;
	$merchantKey= "w79txMr0ql14p709ADuQ7a9Hk3Dc6G2225021w79ws3G9oPSy20U92QimbLy";

	$t = new test();
	$hmac=$t->HmacMd5($data,$merchantKey);
?>
	你的订单号是<?php echo $p2_Order;?> 支付的金额是<?php echo $p3_Amt ;?>
<form action="https://www.yeepay.com/app-merchant-proxy/node" method="post">
	<input type='hidden' name="p0_Cmd" value="<?php echo $p0_Cmd ;?>"/>
	<input type='hidden' name="p1_MerId" value="<?php echo $p1_MerId ;?>"/>
	<input type='hidden' name="p2_Order" value="<?php echo $p2_Order ;?>"/>
	<input type='hidden' name="p3_Amt" value="<?php echo $p3_Amt ;?>"/>
	<input type='hidden' name="p4_Cur" value="<?php echo $p4_Cur ;?>"/>
	<input type='hidden' name="p5_Pid" value="<?php echo $p5_Pid ;?>"/>
	<input type='hidden' name="p6_Pcat" value="<?php echo $p6_Pcat ;?>"/>
	<input type='hidden' name="p7_Pdesc" value="<?php echo $p7_Pdesc ;?>"/>
	<input type='hidden' name="p8_Url" value="<?php echo $p8_Url ;?>"/>
	<input type='hidden' name="p9_SAF" value="<?php echo $p9_SAF ;?>"/>
	<input type='hidden' name="pa_MP" value="<?php echo $pa_MP ;?>"/>
	<input type='hidden' name="pd_FrpId" value="<?php echo $pd_FrpId ;?>"/>
	<input type='hidden' name="pr_NeedResponse" value="<?php echo $pr_NeedResponse ;?>"/>
	<input type='hidden' name="hmac" value="<?php echo $hmac ;?>"/>
	<input type="submit" value='确认支付' />
</form>
</html>




	//----易宝回调页面
	
<html>
<head>
	<title>我的支付系统</title>
	<meta http-equiv="content-type" content="text/html; charset=gb2312"/>
</head>
<h1>支付成功！！！</h1>
</html>




	//----网上支付处理函数
<?php
class test{
	function HmacMd5($data,$key){
		$key=iconv("GB2312","UTF-8",$key);
		$data=iconv("GB2312","UTF-8",$data);
		$b=64;
		if(strlen($key)>$b){
			$key=pack("H*",md5($key));
		}
		$key=str_pad($key,$b,chr(0x00));
		$ipad=str_pad('',$b,chr(0x36));
		$opad=str_pad('',$b,chr(0x5c));
		$k_ipad=$key ^ $ipad;
		$k_opad=$key ^ $opad;
		return md5($k_opad . pack("H*",md5($k_ipad . $data)));
	}
}
*/
?>






















                 ======javascript=====
javascript :用来在页面中编写特效的，和html/css一样都是浏览器解析
javaScript语言
	一：JS如何运行（JavaScript,jsscript,vbScript,applet,,,,）
	二：输出
		alert(什么类型都可以);
		document.write("字符串");
	三：如何在HTML文档中使用JS
		1,使用<script></script>将JS语法嵌入到HTML中，可以使用多个，之间都是关联的。
		2，href="javascript:代码";
		3，事件中
		4，写到外部文件中(.js后缀名的文件) <script src='文件路径'></script>


js语法：
	命名规范：
		1，一定要有意义。
		2，不能以数字开头，不能是系统的关键字。
	大小写：JavaScript区分大小写
		就是名和函数，第一个单词，小写以后每个单词，首字母大写.如： 
		aaa bbb ccc aaaBbbCcc ; getElementById();
		
		对象：每个单词首字母都要大写如：
		Date();  new Object();
	
	分号;
		功能执行语句，加分号 如：var a=10;
		结构定义语句，不加分号 如: for()  while() if() 等

	注释;
		//  单行
		/* */ 多行


	四，变量
		var a = 10 ; 声明一个变量
		    a = 20;  修改一个变量值 。
		注意：变量声明后是浏览器关闭后才释放的。在没关闭前可以随时使用。
		
		变量的声明：	var 变量名=值
		
		注意；javaScript是弱类型语言（和php 相同）


		var a = 10; 加var是声明
		    a=10; 不加var是赋值。



	五，数据类型
		参看：-----五;数据类型案例
		typeof(变量);
		
		1，number(int,float,double) 注意，计算时还是按整形和浮点型分开使用。
		2，string(string char) 
		3，boolean
		4，object(object array null) 注意，分别处理
		5，underfined 没有声明变量

		整数
		var a = 10;
		var a=045; 八进制
		var a=0xff; 十六进制

		小数在判断时不能用== 只能用<,>或>=,<=  因为浮点数是近似数，如8代表7.9999999

		字符串
		在javascript中‘ ’和 " "效果相同。不像PHP中“”可以解析，


		连接：
		javascript中字符串和变量连接时用 + 



	六：运算和表达式
		算术运算符号: + - * / % ++ --
		
		赋值运算符号：= += -= *= /= %=

		条件运算符号：> < == != >= <= === !==

		逻辑运算符号：&& || !
	
		位运算符号：>> >>>(无符号运算) << | & ~
	
		其它运算符号： ? :



	七：流程控制
		顺序结构
	
		条件结构--分支结构--选择结构
			1.单路分支
				if(bool){

				}
			2,双路分支
				if(bool){

				}else{

				}
			3,多路分支
			    1,if分支 用于范围
				if(bool){

				}else if(bool){

				}....
				}else{}
				

        		     2,switch分支 用于单个值匹配
				switch(变量){
					case 值1:
						表达式
						break;
					case ,,,,
						
						default
				}
			


			4,嵌套分去
								
				if(bool){
					if(){
						switch(){

						}
					}
				}else{
					for(){
						while(){
	
						}
					}
				}
	
			
	-----javascript有alert,document.write两种写入方式
。
<body>
	<script>
		alert('aaaaaaaaa');
		document.write('这是通过javascript写入的内容');
	</script>
</body>




	-----script可以在任何地方嵌入，但不可在<>内和style中

<script>
	alert('aaaaaa'+'111');
</script>
<html>
<script>
	alert('bbbbbbbbb'+'111');
</script>
<head>
<script>
	alert('ccccccccc'+'111');
</script>
</head>
<body>
<script>
	alert('dddddddd'+'111');
</script>
</body>
</html>
<script>
	alert('eeeeeeeee'+'111');
</script>






	-----href,form,onclick 触发式脚本

<html>
<body>
	<a href="javascript:alert('aaaaaaaaaaaaaa')">demo</a>
	<form action="javascript:alert('fffffffffffff')" >
		<input type='submit' value="表单提交"/>
	</form>
	<div onclick="alert('ooooooooo')">hello</div>
	<script>
		alert(new Date());
		document.write(new Date());
	</script>
	
</body>
</html>





	-----js外连文件也可以互通的，也可以相互调用
<html>
<body>
	<script src='e1.js'></script> //先在一个JS文件中声明了hello的变量
	<script src='e2.js'></script> //在e2的js文件中调用了这个变量。
</body>
</html>
	<script>
		alert(hello);
		document.write(hello);
	</script>




	e1.js内容
var hello="你好";

	e2.js内容
alert(hello);











	-----五;数据类型案例

<script>
	//number类型包括：整形，double,float
	var a = 10;
	alert(typeof(a));

	var a = 1.1;
	alert(typeof(a));


	var a = 10.55;
	alert(typeof(a));


	//string字符串类型
	var a = "abc";
	alert(typeof(a));


	//boolean布尔型
	var a = true;
	alert(typeof(a));

	//object 对象类型，包括object ,array,null	
	var a = ['11','22'];
	alert(typeof(a));

	var a = null;
	alert(typeof(a));



	//javascript 连接符 +
  	var a =10;
	alert("aaa"+a+'bbb');
</script>



	



	-----关于 + ---关于 %

在script中 + 有两种含意。一个是代表加法运算，另一个是连接字符串。



% 一种是被整除，一种求一段范围，如要求10 以下的数。不管多大的数对10 取余那么其结果都小于10

%在负数时，负数在后面是其结果为正数，负数在前面时其结果为负数。如：
4%-3     结果为 1.   -4%3  结果为1.






	-----关于布尔值与其它值的关系！

在script中被布尔值认为是假的有：0 ，“”（空字串），null
但“0” “ 空格” 会被认为是真。






	-----关于 || 的一个特例
<?php
	$a = 3;
	$b = 3;
	if($a=5 || $b=5){
		$a++;
		$b++;
	}
	echo $a;
	echo $b;
?>

结果为: 1 ,  4     这个例子相当于一个三目运算  前面相当于一个布尔表达式所以结果是1，4
如 mysql_connect()or die()   这就是一个典型的例子，前面是布尔型值，后面是一个表达式！成功了就不运行后面的表示式，不成功则运行后面的表达式！




	-----关于三目运算的形式
<script>
	var b =0;
	var a = b ? "www" : "yyy";
	alert(a);
</script>
如上。如果是一些简单的判断可以用三目运算来判断，如果是一些比较复杂的，则可用IF语句。





	-----关于script的for循环与break 跳出循标签！
<script>
	st:
	for(var i=1;i<9;i++){
		for(var j=1;j<i;j++){
			document.write(j+"*"+i+"="+(j*i)+"&nbsp;&nbsp;");
			if(j==5){
				break st;
//这里的 st 类似于goto 但不同的是，它跳转后会跳过当前for循环语句
			}
		}
		document.write("<br>");
	}
</script>



	-----script显示表格，隔行换色，鼠标指行变色

<script>
	var i=0;
	document.write('<table border="1" width="800" align="center">');
	while(i<1000){
		if(i%20==0){
			bg="#ccc";
		}else{
			bg="#eee";
		}
		if(i%10==0){
			document.write('<tr onmouseover="show(this)" onmouseout="noshow(this)" bgcolor='+bg+'>');
		}
		document.write("<td>"+i+"</td>");
		i++;
		if(i%10==0){
			document.write("</tr>");
		}
	}
	document.write('</tabel>');
	function show(obj){
		bj=obj.bgColor;
		obj.bgColor="red";
	}
	function noshow(obj){
		obj.bgColor=bj;
	}
</script>

	








	-----javaScript中的函数
函数：是一段完成“指定功能”的已经“命名”的代码段

函数只有“调用”才能使用到，调用：就是通过 函数名+（）来调用 如text()   
在javascript中函数的调用可以在声明之前，也可以在声明之后。


test(); //值 

function test(a,b){
	功能段（个条，或多条）
	return 值;
}

test();
1，函数名
2，参数，根据需要使用参数。
3，函数体（功能）
4，返回值（可选）



函数名不加（）时，这个函数名就代表整个这个函数的内容。相当于一个字符串

回调函数，声明
情况
1，函数的作用，--决定我去不去使用
2，函数的参数，--决定我怎么用
3，返回值      --决定我调用后如何处理






	-----函数回调简单案例
<script>
	function show(start,end,check){
		for(var i=start;i<end;i++){
			if(check(i)){
				document.write(i+"<br>");
			}
		}	
	}
show(1,200,function(i){
	if(i%5==0){
		return true;
	}else{
		return false;
	}
	});
show (-100,100,function(i){
	if(i<0){
		return true;
	}else{
		return false;
	}
	});

</script>














	-----script 函数默认参数的设置
<script>
	function test(a,b,c){
		a=a?a:1;
		b=b?b:2;
		c=c?c:3;
		alert(a+"----"+b+"----"+c);
	}
	test();
</script>



	-----arguments 显示函数参数的值

<script>
	function test(){
		alert(arguments.length); //显示实参的个数
		alert(arguments[2]);	//显示指定位置的参数值
	}
	test(1,2,3,4,5,6,7,8);
</script>













	-----利用arguments 计算参数值的和 

<script>
	function test(){
		var num=0;
		for(var i=0;i<arguments.length;i++){
			num += arguments[i];
		}
		return num;
	}
	var num=test(1,2,3,4,5,6,7,8);
	alert(num);
</script>






	=====javaScript 系统函数=====
escape , eval , ifFinite , isNaN , parseFloat , parseInt , unescape





	-----用escape方法将字符串内容转成另一种编码。 

<script>
	var str="escape 方法返回一个包含了charstrign内容的字符串值（Unicode格式）。所有空格，标点，重音符号以及其他非ASCLL字符都用%xx编码代替，其中xx等于表示该字符的十六进制数。例如，空格返回的是。";
	
	alert(str);
	document.write(escape(str));
</script>












	-----用unescape方法将编码后的内容再转回到字符串。
	
<script>
	var str="escape%20%u65B9%u6CD5%u8FD4%u56DE%u4E00%u4E2A%u5305%u542B%u4E86charstrign%u5185%u5BB9%u7684%u5B57%u7B26%u4E32%u503C%uFF08Unicode%u683C%u5F0F%uFF09%u3002%u6240%u6709%u7A7A%u683C%uFF0C%u6807%u70B9%uFF0C%u91CD%u97F3%u7B26%u53F7%u4EE5%u53CA%u5176%u4ED6%u975EASCLL%u5B57%u7B26%u90FD%u7528%25xx%u7F16%u7801%u4EE3%u66FF%uFF0C%u5176%u4E2Dxx%u7B49%u4E8E%u8868%u793A%u8BE5%u5B57%u7B26%u7684%u5341%u516D%u8FDB%u5236%u6570%u3002%u4F8B%u5982%uFF0C%u7A7A%u683C%u8FD4%u56DE%u7684%u662F%u3002";

	alert(str);
	document.write(unescape(str));

</script>








	-----parseLint 将浮点数转成整数（舍去小数部分）
	-----isNaN 检验变量是否为一个数字
	
<script>
	var f ="a12.945";
	//var f = "12.923";
	if(!isNaN(f)){
		var i =parseInt(f);
		alert(i);
	}else{
		var i = 0;
		alert(i);
	}
	
</script>






	



	-----eval把代码当成字符串来解析。
	
<script>
	a ='29.342';
	var str='var f="'+a+'";if(!isNaN(f)){var i =parseInt(f);}else{var i = 0;}';
	eval(str);
	alert(i);
	
</script>








	-----parseInt 把字符串转成整数

	parseInt('abc')		 //结果 NaN
	parseInt("12abc") 	//结果 12








   	-----parseFloat 把字符串转成浮点数
	parseFloat("abc")	//结果 NaN
	parseFloat("1.2abc");	//结果 1.2





	-----isFinite 指明提供的数字是否是有限的
	inFinite(number)为任意的数值
如果number不是NaN，负无穷或正无穷，那么isFinite方法将返回true,如果是这三种情况,返回false
	
 <script type="text/javascript">

document.write(isFinite(123)+ "<br />")
document.write(isFinite(-1.23)+ "<br />")
document.write(isFinite(5-2)+ "<br />")
document.write(isFinite(0)+ "<br />")
document.write(isFinite("Hello")+ "<br />")
document.write(isFinite("2005/12/12")+ "<br />")


</script>












	=====JavaScript对象

1，基于对象的操作方式（面向对象封装，继承，多态）
2，将相关的操作使用一个对象完成，看作是一个整体。

javascript 	php
对象		类
对象实例	对象



系统对象的分类：
	字符串对象
	数学对象
	数组对象
	时间对象



对象中的内容？
	一：属性（变量）
	二：方法（函数）


一：声明对象

二：使用对象

三：使用系统对象

	步骤：
		1，找到对象
		2，实例化对象
		3，操作对象 

对象的实例；属性  （取值，赋值）
对象实例【“属性名”】
对象实例.方法()




	-----script创建对象的方法一；

<script>

	function test(){
	}			//创建一个对象

				//从下是创建对象的属性和方法。
	var t=new test();
	t.width=300;
	t.height=500;
	t.autotime=3;
	t.num=4;
	t.show=function(){
		alert("play.....");
	}
	t.noshow=function(){
		alert("ok,,,,,");
	}
	

alert(t.width);			//调用对象的属性
t.show();			//调用对象的方法

</script>







	-----创建对象的方法二

<script>
function Play(){
	var p=new Object();
	//属性
	p.width=100;
	p.height=200;
	p.num=3;
	p.autotime=24;

	p.fun=function(){
		alert("######");
	}	
	p.category=function(){
		alert('aaaaaaa');
	}
	return p;
}
var p = Play();
alert(p.height);
p.fun();
p.category();
</script>






	-----script创建对象的方法三；
<script>
	function test(width,height,num,back){
		this.width=width;
		this.height=height;
		this.num=num;
	
		this.show=function(){
			alert('aaaaaa');
		}
	}
var t = new test(100,300,5);
alert(t.width);
alert(t.height);
alert(t.num);
t.show();
t.back();
</script>






	-----for(变量 in 对象)遍历对象中的元素

<script>
	function test(width,height,num){
		this.width=width;
		this.height=height;
		this.num=num;
		
		this.show=function(){
			alert("#########");
		}
	}
var t = new test(100,300,5);
var pro = "";
for(pro in t){
	document.write("p."+pro+"="+t[pro]+"<br>");
}
</script>







	-----调用document系统自定义对象

<script>


document.bgColor="red";
</script>









	-----with() 简化对象的操作
	-----javascript 时间 Date()

<script>
/*
	with(对象){
		所有方法如果不加对象那默认都是with()括号中对象的方法和属性。如下；
	}
	
	doucment.write("aaaa");
	doucment.write("bbbb");
	doucment.write("cccc");
	doucment.write("dddd");

	
	with(document){
		write('aaaa');
		write('bbbb');
		write('cccc');
		write('eeee');
	}
*/


</script>
<script>
	var str="今天是：";
	var d = new Date();
	str+=d.getYear()+"年";
	str+=(d.getMonth()+1)+"月";
	str+=d.getDate()+"日";
	str+=d.getHours()+":";
	str+=d.getMinutes()+":";
	str+=d.getSeconds()+" 星期";
 	switch(d.getDay()){
		case 0:
			str+="日";
			break;	
		case 1:
			str+="一";
			break;	
		case 2:
			str+="二";
			break;	
		case 3:
			str+="三";
			break;	
		case 4:
			str+="四";
			break;	
		case 5:
			str+="五";
			break;	
		case 6:
			str+="六";
			break;	
	}

	document.write(str+"<br>");
</script>
<script>

	var str="今天是：";
	var d = new Date();
with(d){
	str+=getYear()+"年";
	str+=(getMonth()+1)+"月";
	str+=getDate()+"日";
	str+=getHours()+":";
	str+=getMinutes()+":";
	str+=getSeconds()+" 星期";
 	switch(getDay()){
		case 0:
			str+="日";
			break;	
		case 1:
			str+="一";
			break;	
		case 2:
			str+="二";
			break;	
		case 3:
			str+="三";
			break;	
		case 4:
			str+="四";
			break;	
		case 5:
			str+="五";
			break;	
		case 6:
			str+="六";
			break;	
	}
}
	document.write(str+"<br>");
</script>










	-----script 显示日期及设置

<script>
	var dt=new Date();
	var str="今天是：";
	str+=dt.getYear()+"年";
	str+=(dt.getMonth()+1)+"月";
	str+=dt.getDate()+"日";
	str+=dt.getHours()+":";
	str+=dt.getMinutes()+":";
	str+=dt.getSeconds()+" 星期";
	
	switch(dt.getDay()){
		case 0:
			str+="日";
			break;
		case 1:
			str+="一";
			break;
		case 2:
			str+="二";
			break;
		case 3:
			str+="三";
			break;
		case 4:
			str+="四";
			break;
		case 5:
			str+="五";
			break;
		case 6:
			str+="六";
			break;
	}

document.write(str);
</script>

getYear(): 返回年数
　getMonth():返回当月号数
　getDate(): 返回当日号数
　getDay():返回星期几
　getHours():返回小时数
　getMintes(:返回分钟数
　getSeconds():返回秒数
　getTime() : 返回毫秒数
设置日期和时间：
　setYear();设置年
　setDate():设置当月号数
　setMonth():设置当月份数
　setHours():设置小时数
　setMintes():设置分钟数
　setSeconds():设置秒数
　setTime ():设置毫秒数
例子：
var d = new Date("2008/11/30");
d.setMonth(d.getMonth() + 1 + 1);//加一个月，同理，可以加一天：getDate()+1，加一年：getYear()+1



















	=====script内置系统函数

	-----简单程序方法的创建demo=new Function('x','y','return x/y');

<script>
	function demo(x,y){
		return x+y;
	}
	document.write(demo(3,4));
</script>
<script>
	var demo=function(x,y){
		return x*y;
	}
	document.write(demo(3,4));
</script>
<script>
	var demo = new Function('x','y','return x-y');
	document.write(demo(5,2));
</script>
<script>
	demo=new Function('x','y','return x/y');
	document.write(demo(10,5));
</script>









	-----script数学函数随机数，上下取整，四舍五入


<script>
var num=Math.random();  //伪随机数
num=num*100;
document.write(num+"<br>");
document.write(Math.ceil(num)+"<br>");// 向上取整
document.write(Math.floor(num)+"<br>"); //向下取整
document.write(Math.round(num)+"<br>");//	四舍五入
</script>













	-----函数replace替换字符 /^\S*$/   代表非空格

<script>
	var str="username";
	if(str.match(/^\S*$/)){  //  \S(大S) 代表非空格
		alert("true");
	}else{
		alert("false");
	}
</script>

<script>
	var str="lkj2s5gnr6jgb7dm8cbvk5lsdh23fl;6ang6e,jer";
	var nstr=str.replace(/\d/,"#"); //把第一个数字换成#
	document.write(str+"<br>");
	document.write(nstr+"<br>");
</script>

<script>
	var str1="lks2dj3flk5jf6lkh8gjk5hs3kj5ds76f3hks";
	var nstr1=str1.replace(/\d/g,"*");  //把所有数字替换成*
	document.write(str1+"<br>");
	document.write(nstr1+"<br>");
</script>













	=====script的array函数

	-----第四种创建对象的方法 json


<script>
	/*
	var p=new Object();
	p.name="aaaaaaaaa";
	p.age=10;
	p.sex="nan";
	alert(p.name+"--"+p.age+"--"+p.sex);
	*/
	//第四种创建对象的方法  json   (javascriptObjectNew)

	var p ={name:"wang",age:20,sex:"nv"}
	alert(p.name+"--"+p.age+"--"+p.sex);
	var w ={aaa:"aaa",bbb:"bbb",ccc:"cccc"};
	alert(w['aaa']+w['bbb']+w['ccc']);
	
</script>




	-----声明数组的方式一
<script>
	var names=['aa','bb','cc'];
	alert(names[1]);
	var tems=['a',10,true];
	alert(tems[2]);

	var arrs=[
		[111,222],
		['aaa','bbb'],
		['333','444']
	];
	alert(arrs[2][0]);

</script>




	-----向数组传参，并调用其长度和内容

<script>
	function MyArray(){
		this.length=arguments.length;
		for(var i=0;i<arguments.lenght;i++){
			this[i]=arguments[i];
		}
		
		this.sort=function(){alert('aaaaaaaa')}
		//this.pop=function(){}
		//this.push=function(){}
	}
	
	var arr=new MyArray('aa','bb','cc','dd','ee');
	//数组的长度
	alert(arr.length);
	arr[1]="xxxxxx";
	alert(arr[1]);
</script>








	-----数组的声明方法二
<script>
	var arr=new Array('a','n','c','d','e');
	//数组的长度
	alert(arr.length);

	alert(arr[1]);
	arr[2]='kkkk';
	alert(arr[2]);

</script>





	-----数组长度的声明方式

<script>
	//方式一：
	function MyArray(num){
		this.length=num;
		for(var i=0;i<this.length;i++){
			this[i]="";
		}
	}
	var arr=new MyArray(10);//设定一个数组内容的长度
	
	//方式二；
	var arrs=new Array(10);
</script>









	-----数组的排序

<script>
	//1，数值大小的排序
	var arr=[1,3,6,9,2,5,8,7];
	arr.sort(function(a,b){
		if(a > b){
			return -1;
		}if(a==b){
			return 0;
		}else{
			return 1;
		}
	});
	document.write(arr+"<br>");
	//2，数组内容长度排序
	var arr2=['a','aaa','aaaaaaaa','aaaa','aa','bbbbb','bbbbbb'];
	arr2.sort(function(a,b){
		if(a.length>b.length){
			return -1;
		}if(a.length==b.length){
			return 0;
		}else{
			return 1;
		}
	});	
	document.write(arr2);
</script>









	-----数组的出入栈，出入队
	
<script>
	var arr=[1,2,3,4,5];
	document.write(arr+"<br>");
	arr.push(777,888);	//数组入栈	（先进后出）
	document.write(arr+"<br>");
	arr.pop();		//数组出栈
	document.write(arr+"<br>");
	arr.unshift("hello");	//数组队列-入列（先进先出）
	document.write(arr+"<br>");
	arr.shift();		//数组队列-出列
	document.write(arr);
</script>









	-----更换文档背景颜色

<script>
	var colors=['red','blue','green','yellow','silver'];
	document.bgColor=colors[Math.ceil(Math.random()*colors.length)];
</script>







	-----网页版贪吃蛇（部分）
<script>
	var rows=20; //行数
	var cols=20; //列数

	var w=25; //宽
	var h=25; //高
	
	//声明一个数组
	var map=new Array();
	for(var i=0;i<rows;i++){
		//数组map中分别声明数组
		map[i]=new Array();
		for(var j=0;j<cols;j++){
			map[i][j]=0;	//二维数组中的每个元素为0
		}
	}
	map[Math.floor(Math.random()*rows)][Math.floor(Math.random()*cols)]=1;
	map[Math.floor(Math.random()*rows)][Math.floor(Math.random()*cols)]=2;
	for(var i=0;i<rows;i++){
		for(var j=0;j<cols;j++){
			if(map[i][j]==1){
				var bg="red";
			}else if(map[i][j]==2){
				var bg="blue";
			}else{
				var bg="yellow";
			}
			document.write('<div style="position:absolute;top:'+(100+h*i)+'px;left:'+(100+w*j)+'px;width:'+w+'px;height:'+h+'px;overflow:hidden;background:'+bg+';border:1px solid white;"></div>');
		}
	}
</script>













		===== DOM =====


	作用：
		DOM（Document Object Model）
		1.document 文档 是指 html 或xml文件（标记类语言的文档）
		如；
		<body>
			<div>
				<a>www</a>
			</div>
		</body>
		
		2.Object 对象（HTML元素，转成的对象（JS对象））
		注意：如果使用JS操作HTML文档，就需要先将HTML文档结构转成JS对象，然后做如下操作。
		a：操作属性
		b：操作内容
			innerText	不解析标签，把标签也当作文本
				此功能适用IE ，其它不适用的可用 textContent
			innerHTML	解析标签，可使内容中的标签生效。取值时会带标签

			outerText
			outerHTML //取出整个对象的元素内容

				操作表单时;要用value 	如：
	<textarea id='username'>mmmmmmmmmmmmmmm</textarea><br>
	<script>
		var username=document.getElementById('username');
		alert(username.value);
	</script>



		c：操作样式
			1,单独操作某个样式；
		aobj.style.backgroundColor="red";
		aobj.style.fontSize="3cm";
			2,用类批量操作样式
		在style中建立一个类如：
<style>
	.test{
		width:500px;
		height:300px;
		border:5px solid blue;


	}
	.demo{
		font-size:4cm;
		color:red;
		background:yellow;
	}
</style>
		然后调用
		aobj.className="test demo"; 或

		aobj.className="test";
		aobj.className+="demo";
		aobj.className="";  清除类




		以上三点的操作之前需要先把文档转成对象

		转成对象的两种形式：

			1，标记名（多个），id（唯一），name（多个） 多个是复数需加s

			document中的三个方法
			var objs=document.getElementsByTagName("div");//以标记名做为对象
			var objs=document.getElementById("one");//以id做为对象	
			var objs=document.getElementsByName('two'); //以名字做为对象
	

			2,通过数组
			document.title=
			document.body=[object]
			window.frames=[object]

			document.all=[object]	//代表所有的标记，想统计元素内容用这个
			document.embeds=[object]	//关于动画的
			document.scripts=[object]	//统计脚本
			document.applets=[object]
			document.images=[object]
			document.forms=[object]
			document.anchors=[object] //所有的毛点，标签里有name的
			document.styleSheets=[object]
			document.links=[object]




	-----innerText 与 innerHTML


<html>
	<body>
		<a id='alink' href='http://www.brophp.com' target='_blank' title='this is tes'>test</a>
		<script>
			var aobj= document.getElementById('alink');
			aobj.href="http://www.baidu.com";
			aobj.target="_self";
			aobj.title="demo demo demo";
			aobj.hello="mmmmmmm";  // 虽然标签属性不支持，但也可以在对象中加入其它元素内容。
			alert(aobj.hello);

			//aobj.innerText="<b>brother</b>"; //改变内容的方式一：innerText 这种方式会把加入内容全部当成文本，标签也会当做文本。

			//alert(aobj.innerText);
			aobj.innerHTML="<h1>brophp</h1>";
			
		</script>
	</body>
</html>











	-----innerText与textContent的兼容选择

<html>
	<body>	
		<a id='alink' href='http://www.brophp.com' target='_blank' title='this is tes'>test</a>
		<script>
			var aobj= document.getElementById('alink');
			
			aobj.hello="mmmmmmm";  // 虽然标签属性不支持，但也可以在对象中加入其它元素内容。
			alert(aobj.hello);

			ffie(aobj,'wwwwwwwww');
			alert(ffie(aobj));
			function ffie(obj,value){
				if(document.all){
					alert('aaaaaaaaa');
					if(typeof(value)=='undefined'){
						return obj.innerText;
					}else{
						obj.innerText=value;
					}
				}else{
					alert('bbbbbbbb');
					if(typeof(value)='undefined'){
						return obj.textContent;
					}else{
						obj.textContent=value;
					}
				}
			}

		</script>
	</body>
</html>






		-----innerText与textContent的兼容选择二
body>
	<div></div>
</body>
<script>
	var di = document.getElementsByTagName('div')[0];
	function inner(obj,value){
		if(document.all){
				obj.innerText=value;
		}else{	
				obj.textContent=value;
		}
	}
	inner(di,"llllllllllllll");
</script>











	-----<textarea>在对象取值时要用value

<body>
	<textarea id='username'>mmmmmmmmmmmmmmm</textarea><br>
	<script>
		var username=document.getElementById('username');
		alert(username.value);
	</script>
</body>








	-----在DOM对象中设置style样式的几种方法
	-----offset 获取不未知元素信息（如区域宽高度）

<style>
	.test{
		width:500px;
		height:300px;
		border:5px solid blue;
	}
	.demo{
		font-size:4cm;
		color:red;
		background:yellow;
	}
</style>

<a id="alink" href="www.baidu.com" target="_blank" title="the miss bautifull"><b>test</b></a>

<script>
	var aobj=document.getElementById("alink");
	
	//改变style属性 注意不要有“-” 每二单词首字母要大写。
	//aobj.style.backgroundColor="red"; 
	//aobj.style.fontSize="3cm"; 
	
	//取得内容的宽度和高度：offset,,,   
	alert(aobj.offsetWidth);
	alert(aobj.offsetHeight);

	//用类改变style属性的几种方法
	//aobj.className="test demo";    //可以把两个类用空格连起来
	aobj.className="test";
	aobj.className+=" demo";       //也可以用+= 连接字符串的形式

	//清除类属性
	aobj.className="";		
	

</script>






	----用pro in 方法显示对象中所有的元素

<a id='alink' href="#">aaaaa</a>
<script>
	var aobj = document.getElementById('alink');
	var pro="";
	for(pro in aobj){
		document.write("a."+pro+"==="+aobj[pro]+"<br>");
	}
</script>













	-----复选框的全选与取消的实现一
<body>
<script>
	document.write('<ul>');
	for(var i=0;i<20;i++){
			document.write('<li>');
			document.write('<input type="checkbox" name="ids[]" value="'+i+'"/>aaaaaaaaaa');
			document.write('</li>');
	}
	document.write('</ul>');
</script>
<a href="javascript:sall()">全选</a>
<a href="javascript:fall()">反选</a>
<a href="javascript:nall()">全不选</a>
<script>
	var cnames=document.getElementsByName("ids[]");
	function sall(){
		for(var i=0;i<cnames.length;i++){
			cnames[i].checked='true';
		}
	}

	function fall(){
		for(var i=0;i<cnames.length;i++){
			if(cnames[i].checked){
				cnames[i].checked="";
			}else{
				cnames[i].checked='true';
			}
		}
	}
	function nall(){
		for(var i=0;i<cnames.length;i++){
			cnames[i].checked="";
		}
	}
</script>
</body>








	-----复选框的全选与取消的实现二

<body>
<script>
	document.write('<ul>');
	for(var i=0;i<20;i++){
			document.write('<li>');
			document.write('<input type="checkbox" name="ids[]" value="'+i+'"/>aaaaaaaaaa');
			document.write('</li>');
	}
	document.write('</ul>');
</script>
<label for="ss"><input id="ss" type='checkbox' onclick='sall(this)' />全选</label>
<input type='checkbox' onclick='fall(this)' />反选
<script>
	var cnames=document.getElementsByName("ids[]");
	function sall(obj){
		for(var i=0;i<cnames.length;i++){
			cnames[i].checked=obj.checked;
		}
	}
</script>
</body>











	-----通过名字取出表单项的值
<body>
	<input type="tect" name="username" value="zhangsan"/>
	<script>
		//var user=document.getElementsByName('username')[0];
		//alert(user.value);
		var user = document.getElementsByName('username');
		alert(user[0].value);
	</script>
</body>









	-----script实现在同一区域中显示不同的内容
<html>
<head>
<style>
	#card{
		width:300px;
		height:200px;
	}
	#tit{
		width:100%;
		height:25px;
		line-height:25px;
	}
	#tit h3{
		margin:0px;
		padding:0px;
		width:80px;
		background:#ccc;
		float:left;
		line-height:25px;
		text-align:center;
		border:2px solid white;
		font-size:12px;
		color:white;
	}
	#content{
		width:100%;
		height:175px;
		background:#888;
		color:white;
	}
	#content div{
		display:none;
	}
	#content .one{
		display:block;
	}
	#tit .titin{
		broder:2px solid #888;
		background:#888;
	}
</style>
</head>
<body>
	<div id="card">
		<div id="tit">
			<h3 onmouseover="show(0)" class='titin'>第一项</h3>
			<h3 onmouseover="show(1)" >第二项</h3>
			<h3 onmouseover="show(2)" >第三项</h3>
		</div>
		<div id="content">
			<div class='one'>
				<ul>
					<li>aaaaaaaaaa</li>
					<li>aaaaaaaaaa</li>
					<li>aaaaaaaaaa</li>
					<li>aaaaaaaaaa</li>
					<li>aaaaaaaaaa</li>
				</ul>
			</div>
			<div>
				<ul>
					<li>bbbbbbbbbbbb</li>
					<li>bbbbbbbbbbbb</li>
					<li>bbbbbbbbbbbb</li>
					<li>bbbbbbbbbbbb</li>
					<li>bbbbbbbbbbbb</li>
					<li>bbbbbbbbbbbb</li>
				</ul>
			</div>
			<div>
				<ul>
					<li>ccccccccccccc</li>
					<li>ccccccccccccc</li>
					<li>ccccccccccccc</li>
					<li>ccccccccccccc</li>
					<li>ccccccccccccc</li>
					<li>ccccccccccccc</li>
				</ul>
			</div>
		</div>
	</div>
<script>
	var h3os=document.getElementsByTagName('h3');
	var cdivs=document.getElementById('content').getElementsByTagName("div");
	
	function show(num){
		for(var i=0;i<h3os.length;i++){
			if(i==num){
				h3os[num].className="titin";
				cdivs[num].style.display="block";
			}else{
				h3os[i].className="";
				cdivs[i].style.display="none";
			}
		}
	}
</script>
</body>
</html>














	-----通过数组转成对象的七种方式

<body>
	<form name="frm1">
		<input type="text" name="username" value="zhangsan"><br>
	</form>
	<form name="frm2">
		<input type="text" name="username" value="lisi"><br>
	</form>
	<form name="frm3">
		<input type="text" name="username" value="admin"><br>
	</form>

	<script>
		alert(document.forms[1].username.value);
		alert(document.forms['frm2'].username.value);
		alert(document.forms.item(1).username.value);
		alert(document.forms.item('frm2').username.value);
		alert(document.forms.frm2.username.value);
		alert(document.frm2.username.value);
		alert(document['frm2'].username.value);
	</script>
</body>









	-----父节点，同胞节点，子节点的运用实例

<html>
<body>
	<div></div>
	<h3></h3>
	<!--lllllllll-->
	<pre>	
		<a></a><div id="di">
			<a hre="#">aaaaa</a>
			<span>ssss</span>
			<i>iiiii</i>
		</div><font></font>
		
	</pre>
	<div></div>
	
<body>
</html>
<script>
	var di=document.getElementById('di');
	//alert(di.parentNode.parentNode.nodeType); //取di父节点的父节点的类型
	//alert(di.parentNode.parentNode.nodeName); //取di父节点的父节点的名字
	//var body=di.parentNode.parentNode; //把di父节点的父节点赋给一个变量
	//alert(body.nodeType); //显示body这个节点的类型
	//alert(body.nodeName); //显示body这个节点的名
	//alert(body.childNodes[3].nodeName); //显示body下的第4个子节点的名字,需要打开上面的 var body
	//alert(di.childNodes[5].nodeType); //取di的子节点<i>的类型
	//alert(di.childNodes[5].nodeName); //取di的子节点<i>的名字
	//alert(di.childNodes[5].childNodes[0].nodeValue); //取节点中内容值要再用一次childNodes[0]	***
	//alert(di.childNodes[1].childNodes[0].nodeValue); //取di的span节点中的内容			***
	//alert(di.nodeType);	//显示di节点类型
	//alert(di.nodeName);	//显示di节点名
	//alert(di.firstChild.nodeType);//显示di下的第一个子节点类型					***
	//alert(di.firstChild.nodeName);//显示di下的第一个子节点名
	//alert(di.childNodes[1].nodeType);//显示di下的第二个子节点的类型。
	//alert(di.childNodes[1].nodeName);//显示di下的第二个子节点的名字
	//alert(di.childNodes[2].nodeType); //显示di的第三个子节点类型(空格或回车也算做节点)		***
	//alert(di.childNodes[2].nodeName); //显示di的第三个子节点名
	//alert(di.lastChild.previousSibling.nodeType); //显示最后一个子节点的类型			***
	//alert(di.lastChild.previousSibling.nodeName); //显示最后一个子节点的名字			
	//alert(di.nextSibling.nodeType);	//显示下一个兄弟节点的类型				***
	//alert(di.nextSibling.nodeName);	//显示下一个兄弟节点的名字
	//alert(di.previousSibling.nodeType);	//显示上一个兄弟节点的类型				***
	//alert(di.previousSibling.nodeName);	//显示上一个兄弟节点的名字
	//alert(di.parentNode.nodeType);	//显示父节点的类型					***
	//alert(di.parentNode.nodeName);	//显示父节点的名字	

	//显示di的父节点的上一个兄弟节点的上一个兄弟节点的类型						***			
	//alert(di.parentNode.previousSibling.previousSibling.nodeType);
	//alert(di.parentNode.previousSibling.previousSibling.nodeName);	
	//alert(di.parentNode.parentNode.nodeType);
	//alert(di.parentNode.parentNode.nodeName);

	//显示di的父节点的父节点的第二个子节点的类型和名字。						***
	//alert(di.parentNode.parentNode.childNodes[1].nodeType);
	//alert(di.parentNode.parentNode.childNodes[1].nodeName);
	
</script>










		-----创建节点并添加元素和内容

<body>
	<div>
	</div>
	aaaaaaaaaaaaaaaa<br>
	aaaaaaaaaaaaaaaa<br>
	aaaaaaaaaaaaaaaa<br>
	aaaaaaaaaaaaaaaa<br>
	aaaaaaaaaaaaaaaa<br>
	<div id="one" style="width:300px;height:200px;background:yellow">
		<b>lksjdflk</b><br>
		
		<p id="two">dddd</p>
	</div>
	<script>
		function test(){
			var tu=document.createElement("img");
			tu.src="cx.gif";
			tu.title="this is a pictrue";
			tu.border="5px";
			tu.borderColor="blue";

			var aobj=document.createElement("a");
			aobj.href="http://www.baidu.com";
			aobj.target="_blank";
			aobj.title="this is demo";
			//aobj.innerText="brophp";	//给aobj对象添加内容
			//document.body.appendChild(aobj); //把创建的节点与内容添加到文档里（尾部）
			var one=document.getElementById("one");
			//one.appendChild(aobj);	//把创建的aobj元素添加到one元素中
			//one.appendChild(tu);	//把创建的tu 元素添加到one元素中
			
			//var two=document.getElementById('two');

			aobj.appendChild(tu);	//在aobj对象下再创建一个tu的元素rrrttt
			one.insertBefore(aobj,two);//在aobj到tow之间添加tu

		}
	</script>
	<a href="javascript:test()">test</a>
	bbbbbbbbbbbbbbbb<br>
	bbbbbbbbbbbbbbbb<br>
	bbbbbbbbbbbbbbbb<br>
	bbbbbbbbbbbbbbbb<br>
	bbbbbbbbbbbbbbbb<br>
	bbbbbbbbbbbbbbbb<br>
</body>
















		-----给文档流输入节点内容

<body>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>

	<script>
		function test(){
			var aobj=document.createElement('a');
			aobj.href="http://www.baidu.com";
			aobj.target="_blank";
			aobj.title="this is demo";
			aobj.innerText="brophp";
			document.body.appendChild(aobj);
		}
	</script>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	<a href="javascript:test()">demo</a>
</body












	-----文档流输入指定到子节点的输入<br>

<body>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>
	aaaaaaaaaaa<br>
	<div id="one" style="width:300px;height:100px;background:yellow">

		<i id="two">iiiiiiii</i>
	
	</div>
	<script>
		function test(){
			var two=document.getElementById("two");
			var aobj=document.createElement('a');
			aobj.href="http://www.baidu.com";
			
			aobj.target="_blank";
			aobj.title="this is demo";
			//aobj.innerText="brophp";
			//document.body.appendChild(aobj);
	
			var tu=document.createElement("img");
			tu.src="cx.gif";
			aobj.insertBefore(tu);

			var one=document.getElementById("one");
			//one.appendChild(aobj);
			one.insertBefore(aobj,two);

		}
	</script>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	bbbbbbbbbbbb<br>
	<a href="javascript:test()">demo</a>

</body>
















		=====script事件处理

	onmoseover="show(this)" //这里的 this直接就是把当前的语句转成对象
	
	一，事件源：任何一个HTML元素（节点）body,div,button,p,a,h1,,,,,
	二，事件：你的操作
		鼠标：
			click 单击
			dblclick 双击
			contextmenu (在body) 文本菜单 右键单击事件
			mouseover 放上
			mouseout  离开
			mousedown 按下
			mouseup  抬起
			mousemove 移动
		
		键盘:
			keypress 键盘事件
			keyup	抬起
			keydown	按下

		文档：
			load  文件体加载完成后执行事件
			unload 关闭
			beforeunload 关闭之前

		表单：
			focus 焦点
			blur  失去

	三：事件处理程序

有三种方法加事件：

	第一种：
		格式：<tag on事件 = “事件处理程序或函数”/>


	第二种：
		<script>
			对象.on事件 =事件处理程序 
		</script>


	第三种：
		<script for="事件源ID" event="事件">事件处理程序</script>
		注：当事件源发生预定的事件时才触发事件处理程序










	
	-----点击事件的第一种方法

<script>
	function show(){
		var one=document.getElementById('one');
		alert(one.innerText);
	}
</script>
<body>
	<div id="one">
		wwwwwwwwwwwwww
	</div>
	<input type="button" onclick="show()" value="buttons"/>

</body>







	-----点击事件的第二种方法

<body>
	<div id="one">aaaaaaaaaaaa</div>

<script>
	var one = document.getElementById("one");
	one.onclick=function(){
		one.style.background="red";
	}
</script>
</body>






	-----点击事件的第三种方法


<div id='one'>wwwwwwwwwwwww</div>

<script for='one' event="onclick">
	var one=document.getElementById('one');
	one.style.background="red";
</script>









	------一个事件源添加多个事件


<div id="one" onmouseover="show(this,'red')" onmouseout="show(this,'blue')" ondblclick="show(this,'green')" onclick="show(this,'yellow')">wwwwwwwww</div>

<script>
	function show(obj,col){
		obj.style.backgroundColor=col;
	}
</script>






	-----事件函数中带有return 的注意要点
	-----oncontextmenu禁止右键

<body oncontextmenu="return test()">
	
</body>
<script>
	function test(){
		alert('010-12oi3u4289');
		return false;
	}
</script>
注意： 当调用一个函数且些函数用了return返回了一个值的时候。那么在调用时就要 return test()
返回方法值。不然方法返回的值不会被执行！








	-----页面禁止右键，并弹出提示

<body oncontextmenu="alert('010-12344566');return false">

</body>








	-----onload当页面加载完成后触发事件

<body onload="test()">
	
</body>
<script>
	function test(){
		alert('aaaaaaaaa');
	}
</script>

	--onload()是在加载后最后执行，注意顺序

<script>
	alert('111111111111');
</script>
<body onload="alert('22222222222')">
	<script>
		alert('333333333333');
	</script>
</body>
<script>
	alert('4444444444');
</script>

	--onload在加载后触发的实例


<script>
	function test(){
		var one = document.getElementById('one'); //当此脚本放在前面时，因顺序问题下面的事件不会成立，但做成方法并被 onload后，就不会因顺序问题而不触发了！
		alert(one.innerText);
	}
</script>

<body onload="test()">
	<div id="one">
		#############
	</div>
</body>










	-----unload页面关闭时触发事件

<script src="c1.js"></script>

<body onunload="alert('goodbye')">
	<div id="one">
		##########
	</div>
</body>

	c1.js页面

onload=function(){
	var one=document.getElementById('one');
	alert(one.innerText);
}










	-----unload 在页面关闭前触发
	
<body onunload="alert('goodbye')">
	#####
</body>








	-----beforeunload关闭页面时提示-确定或取消


<body onunload="alert('goodbye')" onbeforeunload="event.returnValue='你小心点儿！'">
	$$$$$$$
</body>








	-----事件对象，随对象改变显示其内容


<div onclick="show(this)">aaaaaaaaa</div>
<h3 onclick="show(this)">hhhhhhhhhhhhh</h3>
<p onclick="show(this)">pppppppppp</p>

<script>
	function show(obj){
		alert(obj.innerText);
	}
</script>









	-----事件对象，改变所点击对象的内容

<div onclick="show()">aaaaaaaaa</div>
<h3 onclick="show()">hhhhhhhhhhhhh</h3>
<p onclick="show()">pppppppppp</p>

<script>
	function show(){
		event.srcElement.innerText="abc";
	}
</script>







	-----通过事件对象让输入的内容全部为大写

<input type="text" onkeyup="if(this.value!=this.value.toUpperCase()) this.value=this.value.toUpperCase()" />








	-----获取键盘事件按键的值（字母和数字键）

<body onkeypress="show()">
	<script>
		function show(){
			alert(event.keyCode);
		}
	</script>
</body>








	----通过键盘事件关闭浏览器

<body onkeypress="show()">
	<script>
		function show(){
			if(event.keyCode=="27"){
				window.close();
			}
		}
	</script>
</body>









	-----获取键盘事件按键的值（包括功能键）

<body onkeydown="show()">
	<script>
		function show(){
			alert(event.keyCode);
		}
	</script>
</body>








	-----setInterval 定时执行功能实现动画效果(数字累加变换)

<div id="one" style="color:red;font-size:10cm;text-align:center">0</div>
<script>
	var one=document.getElementById('one');
	var i = 1;
	setInterval(function(){
		one.innerText=i;
		i++;
	},100);
</script>






	-----setInterval 定时执行功能实现计数（带开始停止功能）

<body>
	<div id="one" style="color:red;font-size:10cm;text-align:center">0</div>

	<script>
		var one=document.getElementById("one");
		var num=1;
		var st='';
		var ct=0;
		function aa(){
			ct+=1;
			st=setInterval(function(){
				one.innerText=num;
				num++;
			},100);
			return st;
		}
		function start(){
			if(ct==0){
				aa();
			}
		}
	
		function stop(){
			ct=0;
			clearInterval(st);
		}
	</script>
	<input type="button" onclick="start()" value="start" />
	<input type="button" onclick="stop()" value='stop'/>

</body>









	-----网页动画人物移动

<body onkeydown="opt()">
	<img border='0' style="position:absolute;left:0px;top:0px;" id='ren' src='image/left_1.jpg'>

<script>
	//获取图片名
	function basename(url){
		var loc=url.lastIndexOf("/")+1;
		return url.substr(loc);
	}

	//创建人图片对象 
	var ren=document.getElementById("ren");
	var fx="r";
	var speed=0;
	function changetu(){
		if(basename(ren.src).charAt(2)==1){
			ren.src="image/"+fx+"_2.jpg";
		}else{
			ren.src="image/"+fx+"_1.jpg";
		}
	}

	var x=0;
	var y=0;
	var xs=0;
	var ys=0;
	function run(){
		x+=xs;
		y+=ys;
		ren.style.left=x;
		ren.style.top=y;
		
	}
	
	setInterval(function(){
		changetu();
		run();
	},100);
	
	function opt(){
		var code=event.keyCode;
		switch(code){
			case 37:
				fx='l';
				ys=0;
				xs=-5;
				break;
			case 38:
				fx='u';
				ys=-5;
				xs=0;
				break;
			case 39:
				fx='r';
				ys=0;
				xs=5;
				break;
			case 40:
				fx='d'
				ys=5;
				xs=0;
				break;
		}
		
	}
	opt();
	var two = document.getElementById('two');
	
</script>
</body>








		-----事件event 		window.event

1，srcElemnt	代表事件源对象 
2，keyCode	事件发生时的键盘码，keypress,keydown keyup
3，clientX,clientY	网页执行区内的鼠标坐标。
4，screenX,screenY	屏幕范围的鼠标坐标。
5，returnValue 		返回事件值。
6，cancelBubble		只发生本身当次事件，取消当次事件以后引发的事件。








	-----clientX,Y 获取鼠标在网页可执行区范围内的坐标！
	-----screenX,Y 获取鼠标在屏幕范围的坐标
	-----window.status=str; 把坐标显示在状态栏中
	-----window.document.title=str; 把坐标显示在title上

<body onmousemove="test()">
	<div id="one"></div>

	<script>
		var one = document.getElementById("one");
		function test(){
			var cx=event.clientX;	//鼠标在网页执行区范围内的坐标
			var cy=event.clientY;
			var sx=event.screenX;	//鼠标注在屏幕范围的坐标
			var sy=event.screenY;
			var str="clientX="+cx+",clientY="+cy+"screenX"+sx+"screenY"+sy;
			one.innerText=str;
			window.status=str; //把坐标显示在状态栏中
			window.document.title=str; //把坐标显示在title上
		}
	</script>
</body>






	-----兼容IE和火狐的坐标显示

<body>
	<div id="one">//火狐默认把事件对象以参数形式传进函数。而IE用event</div>

	<script>
		var one=document.getElementById('one');
		document.onmousemove=function(e){
			var ev=e || window.event;
			
			
			var cx=ev.clientX;
			var cy=ev.clientY;
			var sx=ev.screenX;
			var sy=ev.screenY;

			var str="clientX="+cx+",clientY="+cy+"screenX="+sx+"screenY="+sy;
			one.innerHTML=str;
			window.status=str;
			window.document.title=str;
		}
	</script>
</body>







	-----网页中图片随鼠标移动


<body>
	<img id="tu" src="image/car1.jpg" style="position:absolute;top:10;left:10"/>
	
	<script>
		var tu=document.getElementById('tu');
		document.onmousemove=function(e){
			var ev=e || window.event;
			var x=ev.clientX;
			var y=ev.clientY;
		
			tu.style.top=y+20;
			tu.style.left=x+20;
		}

	</script>

</body>








	-----鼠标按下拖动区域或移动

<body>
	<div id="one" style="position:absolute;left:100px;top:100px;width:200px;height:30px;background:red">aaa</div>

	<script>
		var one = document.getElementById('one');	
		var down=false;
		var dx=0;
		var dy=0;
		var sx=0;
		var sy=0;
		document.onmousemove=function(e){
			var ev=e || window.event;

			if(down){
				one.style.top=ev.clientY-(dy-sy);
				one.style.left=ev.clientX-(dx-sx);
			}
		}
		one.onmousedown=function(e){
			var ev=e || window.event;
			dx=ev.clientX;
			dy=ev.clientY;
			sx=parseInt(one.style.left);
			sy=parseInt(one.style.top);
			if(!down){
				down=true;
			}
		}
		document.onmouseup=function(){
			if(down){
				down=false;
			}
		}
	</script>
</body>














	-----用按键创建一个可移动的区域

<style>
	.one1{
		position:absolute;
		background:red;
	}
</style>

<body>
	<input type="button" onclick="crea()" value="add">
	<script>

		var one =null;	
		var down=false;
		var dx=0;
		var dy=0;
		var sx=0;
		var sy=0;

	function crea(){
		if(one!=null)
			return;
		alert('你创建了一个可移动的区块!');
		one=document.createElement('div');
		one.style.top="100";
		one.style.left="100";
		one.style.width="200px";
		one.style.height="30px";
		one.className="one1";
		document.body.appendChild(one);

		one.onmousedown=function(e){
			var ev=e || window.event;
			dx=ev.clientX;
			dy=ev.clientY;
			sx=parseInt(one.style.left);
			sy=parseInt(one.style.top);
			if(!down){
				down=true;
			}
		}
		document.onmouseup=function(){
			if(down){
				down=false;
			}
		}

	}
		document.onmousemove=function(e){
			var ev=e || window.event;

			if(down){
				one.style.top=ev.clientY-(dy-sy);
				one.style.left=ev.clientX-(dx-sx);
			}
		}

	</script>
</body>










	-----window.event.returnValue=false返回事件函数中的值

<body oncontextmenu="show()">
	<script>
		function show(){
			alert('9999999999');
			window.event.returnValue=false;
		}
	</script>

</body>










	-----cancelBubble取消以后事件来解决层级事件的重复发生！

//这里因为图片是在body体上的，所以当点击图片时同时发生了图片事件和body体事件。这是两层事件的发生。层级需解决！
<body onclick='one()'>
	<img src="image/car1.jpg" onclick='two()'>

	<script>
		function one(){
			alert("body click #########");
		}
		function two(){
			alert("img click %%%%%%%%%");
			window.event.cancelBubble=true; //只产生本身一次事件，不再触发更深层的其它事件！
		}
	</script>

</body>

















	------BOM 浏览器对象

一：浏览器本身自己就有一些对象 ，不用创建就可以使用

window: 当前浏览器客体的

	属性：

		status
		opener
		closed

	方法：
		alert();
		confirm();
		setInterval();
		claerInterval();

		setTimeout();
		clearTimeout();
		open();


	子方法：
		document
		frames
		location
		screen
		,,,,



	[window.]成员 
		document.write();
						















	-----confirm确定或取消事件的发生行为

<a href="del.php" onclick="return confirm('你确定要删除吗？')">删除</a>













	
	-----漂浮广告区块的实现
	-----document.body.clientWidth | Height 获取窗口执行区的宽度和高度
	-----one.offsetHeight | Width  	获对象取区块的高度和宽度


<body>
<div id='one' style="background:red;position:absolute;left:0;top:0;width:100px;height:100px"></div>

<script>
	var x=0;
	var y=0;
	var ys=10;
	var xs=10;

	var one=document.getElementById('one');

	function move(){
		x+=xs;
		y+=ys;
		
		if(x>=document.body.clientWidth-one.offsetWidth-20 || x<=0){  
			//document.body.clientWidth 窗口执行区的宽度
			xs=-1*xs;
		}
		if(y>=document.body.clientHeight-one.offsetHeight-20 || y<=0){
			//one.offsetHeight 获取区块的高度
			ys=-1*ys;
		}
		
		one.style.left=x;
		one.style.top=y;
	}

	var dt=setInterval("move()",100);

	one.onmouseover=function(){
		clearInterval(dt);
	}

	one.onmouseout=function(){
		//setInterval("move()",100);  如果这里不指定区块，就相当于每次触发新的事件，移动速度就越来越快。
		dt=setInterval("move()",100);
	}

</script>

</body>











	-----setTimeout 单次定时器

<body>
	<script>
		var one=setTimeout(function(){
			document.bgColor='red';
		},3000);
	
		var two=setTimeout(function(){
			document.bgColor="blue";
		},6000);

		var three=setTimeout(function(){
			document.bgColor="green";		
		},9000);

		function stop(){
			clearTimeout(two);
		}
	</script>
	<input type="button" onclick="stop()" value="add"> //触发这个事件后，就会清除相应的定时器

</body>














	-----父窗体弹出子窗体并控制其内容

<body>
	<script>
		var subwin=window.open("aa.html","_blank","top=300,left=300,width=200,height=200");
		function show(obj){
			subwin.document.bgColor=obj.value;
		}

	</script>
	<input type="button" onclick="show(this)" value="red"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	<input type="button" onclick="show(this)" value="yello"><br>
	<input type="button" onclick="show(this)" value="blue"><br>
	<input type="button" onclick="show(this)" value="#ff00ff"><br>
</body>


需要创建一个aa.html页面；














	-----子窗体控制父窗体元素
	-----subwin.close()关闭父窗口同时关闭子窗口


<body onunload="closeit()">  
	<script>
		var subwin=window.open('bb.html',"_blank","top=300,left=300,width=200,height=200");

		function show(obj){
			subwin.document.bgColor=obj.value;
		}
	
		function demo(){
			window.document.title="wwwwwwwwwwwwwwwww";
		}

		function closeit(){
			if(!subwin.closed){
				subwin.close();
			}
		}
	</script>
	
	<input type="button" onclick="show(this)" value="red"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	<input type="button" onclick="show(this)" value="blue"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	
</body>


		bb.html页面
<body>
	<script>
		opener.demo();
		function show(obj){
			opener.document.bgColor=obj.value;
		}
	</script>
	<input type="button" onclick="show(this)" value="red"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	<input type="button" onclick="show(this)" value="yellow"><br>
	<input type="button" onclick="show(this)" value="blue"><br>
</body>
















	-----跑马灯，状态栏信息来回跑效果
	-------算法：自增再再自减，产生来回动的效果

<body onunload="closeit()">  
	<script>
		var subwin=window.open('cc.html',"_blank","top=300,left=300,width=200,height=200");

		function show(obj){
			subwin.document.bgColor=obj.value;
		}
	
		function demo(){
			window.document.title="wwwwwwwwwwwwwwwww";
		}

		function closeit(){
			if(!subwin.closed){
				subwin.close();
			}
		}

		var num=0;
		var dir=1;
		setInterval(function(){  //跑马灯，状态栏信息来回跑效果
			if(num >40 || num <0){
				dir = -1*dir;
			}
			num+=dir;
			var space="";
			for(var i=0;i<num;i++){
				space+=" ";   //注意这里别忘了加空格
			}
			window.status=space+"www.brophp.com";
		},100);
	</script>
	
	<input type="button" onclick="show(this)" value="red"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	<input type="button" onclick="show(this)" value="blue"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	
</body>



	cc.html页面

	-----window.resizeBy(5,5); //每100毫秒窗口的宽和高都增长5pxp
	-----window.close(); 	//窗口5秒后自动关闭

<body>
	<script>
		opener.demo();
		function show(obj){
			opener.document.bgColor=obj.value;
		}
		setInterval(function(){
			window.resizeBy(5,5);	//每100毫秒窗口的宽和高都增长5pxp
		},100);
		setTimeout(function(){
			window.close(); 	//窗口5秒后自动关闭
		},5000);

	</script>
	<input type="button" onclick="show(this)" value="red"><br>
	<input type="button" onclick="show(this)" value="green"><br>
	<input type="button" onclick="show(this)" value="yellow"><br>
	<input type="button" onclick="close()" value="close"><br>
	
</body>








		

	-----页面分帧


<frameset rows="100,*">
	<frame />
	<frameset cols="200,*">
		<frame name="dd" src="dd.html"/>
		<frame name='main'/>
	</frameset>
</frameset>


	dd.html页面
	
	-----用script 设置分帧显示背景色
	-----window.parent.parent.frames[0].document.bgColor 父窗口的父窗口的背景色
	-----window.top 最顶层的父窗口


<input type="button" onclick="window.document.bgColor='yellow'" value="改自己的"><br>
<input type="button" onclick="window.parent.parent.frames[0].document.bgColor='green'" value="改上面的"><br>
	//window.parent.parent.frames[0].document.bgColor 父窗口的父窗口的背景色
<input type="button" onclick="window.top.frames['main'].document.bgColor='blue'" value="改右面的"><br>
	//window.top.最顶层的父窗口
















	-----html跳转方式 meta http-equiv	

<html>
	<head>
		<meta http-equiv="refresh" content="3;url=http://www.baidu.com" />
	</head>
	<script>
		document.write(new Date()+"<br>");
		document.write(new Date()+"<br>");
		document.write(new Date()+"<br>");
		document.write(new Date()+"<br>");
	</script>

</html>


	bounds.html页面 省略











	-----script的几种跳转方式 
	-----location="bounds.html"; 重点记住使用的跳转方法！
	-----location.reload(); script刷新方式，适用做实时时间显示。
<html>
<script>
	setTimeout(function(){
		//window.navigate('bounds.html');  
		//window.location.href="bounds.html"
		//location="bounds.html"; // 重点推荐使用此种跳转方法
		//location.replace('bounds.html');//此方法是替换，不同于其它跳转，所以不会有后退
		location.reload(); 	//刷新 

	},1000);
	document.write(new Date()+"<br>");
	document.write(new Date()+"<br>");
	document.write(new Date()+"<br>");
</script>
</html>












	-----history.back()返回上一步
	-----history.go(-1或-2)返回上二步

<a href='two.html'>two</a>



<a href="three.html">three</a>
<a href="javascript:history.back()">返回上一页</a>



<a href="javascript:history.go(-1)">返回上一步</a>
<a href="javascript:history.go(-2)">返回上二步</a>














	-----screen获取屏幕的高度等信息	

	

<script>
	with(document){
		write("您的屏幕显示设定值如下：<br>");
		write("屏幕的实际高度为"+screen.availHeight+"<br>");
		write("屏幕的实际宽度为"+screen.availWidth+"<br>");
		write("屏幕的色盘深度为"+screen.colorDepth+"<br>");
		write("屏幕区域的高度为"+screen.height+"<br>");
		write("屏幕区域的宽度为"+screen.width);
	}
</script>











	-----window.clipboardData.setData 剪贴板	

<div id="one">
	11111111<br>
	2222222<br>
	333333333<br>
	44444444<br>
</div><br><br><br>
<input type="button" value="aaaaaa" onclick="cnm()"/>
<script>
	var one=document.getElementById('one');
	function cnm(){
		var content=one.innerText;
		window.clipboardData.setData("text",content);
		alert('您以成功复制了内容！！！');
	}
	
</script>

















	=====表单对象=====
	
	document.getElementById();
	document.forms.username
	document.frm1.username

	本身表单有的属性，都可以是对象的属性

	action
	method
	enctype
	title
	
	submit() 自动提交方法

	onfocus();  当获取焦点时触发事件
	onblur();  当失去焦点时触发事件
	onchange(); 当内容改变时触发事件


	
	-----submit()表单自动提交与表单对象


<body>
	<form name="frm" action="login.html" method='post'>
		username:<input type="text" name="username" value=""><br>
		password:<input type="password" name="password" value=""><br>
		<input type="submit" name="submit2" value="Login"><br>  //这里注意当有自动提交时千万不要与重名。

		<h1 onclick="test()">login h1</h1>
	</form> 
</body>
<script>
	function test(){
		var frmobj=document.frm;
		frmobj.action="login.html";
		frmobj.target="_blank";
		frmobj.method="get";
		frmobj.username.value="admin";
		frmobj.submit();
	}
	setTimeout('test()',3000);
</script>




	创建一个login.html文件











	
	-----onsubmit在form标签中验证表单
	-----focus()获取焦点的应用


<body>
	<form name="frm" action="login.php" onsubmit="return check()" method="post">
		username: <input type="text" name="username" value=""><br>
		password: <input type="password" name="password" value="" ><br>
		<input type="submit" name="submint2" value="Login"><br>
	</form>	
</body>
<script>
	function check(){
		if(document.frm.username.value==""){
			alert("用户名不能为空");
			document.frm.username.focus();
			return false;
		}
		if(document.frm.password.value==""){
			alert("用户密码不能为空");
			document.frm.password.focus();
			return false;
		}
		return true;
	}
</script>















	
	-----onsubmit在form标签中验证表单
	-----focus()获取焦点的应用
	-----/^\S+$/ 非空连贯 的应用


<body>
	<form name="frm" action="login.php" onsubmit="return check()" method="post">
		username: <input type="text" name="username" value=""><br>
		password: <input type="password" name="password" value="" ><br>
		<input type="submit" name="submint2" value="Login"><br>
	</form>	
</body>
<script>
	function check(){
		if(!document.frm.username.value.match(/^\S+$/)){  // /^\S+$/ 非空连贯
			alert("用户名不能为空或包含空格");
			document.frm.username.focus();
			return false;
		}
		if(document.frm.password.value==""){
			alert("用户密码不能为空");
			document.frm.password.focus();
			return false;
		}
		return true;
	}
</script>






















	-----用一个变量统计错误信息一并显示
	-----onbulu 失去焦点触发事件的应用(要结合onsubmit)

<body>
	<form name="frm" action="login.php" onsubmit="return check()" method="post">
		username: <input type="text" name="username" value=""><br>
		password: <input type="password" name="password" value="" ><br>
		<input type="submit" name="submint2" value="Login"><br>
	</form>	
</body>
<script>
	function check(){
		var info="";
		var stats=true;
		if(!document.frm.username.value.match(/^\S+$/)){  // /^\S+$/ 非空连贯
			info+="用户名不能包含空格!\n";
			stats = false;
		}
		if(document.frm.password.value==""){
			info+="用户密码不能包含空格";
			stats = false;
		}
		if(!stats)
			alert(info);
		return stats;
	}
</script>

















	-----onbulu 失去焦点触发事件的应用(要结合onsubmit)

<body>
	<form name="frm" action="login.php" onsubmit="return check()" method="post">
		username: <input type="text" name="username" onblur="one()" value=""><br>
		password: <input type="password" name="password" onblur="two()" value="" ><br>
		<input type="submit" name="submint2" value="Login"><br>
	</form>	
</body>
<script>
	function one(){
		if(!document.frm.username.value.match(/^\S+$/)){ 
			alert("用户名不能包含空格！");
		}
	}
	function two(){
		if(document.frm.password.value==""){
			alert("用户密码不能包含空格");
		}
	}

	function check(){
		var info="";
		var stats=true;
		if(!document.frm.username.value.match(/^\S+$/)){  // /^\S+$/ 非空连贯
			info+="用户名不能包含空格!\n";
			stats = false;
		}
		if(document.frm.password.value==""){
			info+="用户密码不能包含空格";
			stats = false;
		}
		if(!stats)
			alert(info);
		return stats;
	}

</script>
















	-----利用表单提交注册信息实例
	//-----获取下一个指定名的同胞节点的方法  gspan(cobj)
	//-----通过表单名获取对象  var username=document.getElementsByName("username")[0];
	//-----当对象获得焦点时触发事件  username.onfocus=function()
	//-----获得焦点触发事件  obj.onfocus=function()
	//-----页面加载完成后调用  onload=regis  或onload=function()
	//-----设置一个方法返回值的变量，来控制onsubmit是否触发
	//-----判断事件的触发行为是submit还是onblur

<head>
	<style>
		.stats1{
			color:#ddd;
			font-size:12;
		}
		.stats2{
			color:#000;
		}
		.stats3{
			color:red;
		}
		.stats4{
			color:green;
		}
	</style>
	<script src="check.js"></script>
</head>
<body>
	<form action="bb.html" method="post" onsubmit="return regis('click')">
		username:<input type="text" name="username" value="">
			<span class="stats1">请输入用户名</span><br>
		password:<input type="password" name="password" value="">
			<span class="stats1">请输入密码</span><br>
		repass:<input type="password" name="repass" value="">
			<span class="stats1">请确认密码</span><br>
		email:<input type="text" name="email" value="">
			<span class="stats1">请输入邮箱</span><br>
		other:<input type="other" name="other" value="">
			<span class="stats1">请输入其它</span><br>
		submit:<input type="submit" name="sub" value="提交">
	</form>
</dody>




		check.js页面



	//-----获取下一个指定名的同胞节点的方法  gspan(cobj)
	//-----通过表单名获取对象  var username=document.getElementsByName("username")[0];
	//-----当对象获得焦点时触发事件  username.onfocus=function()
	//-----获得焦点触发事件  obj.onfocus=function()
	//-----页面加载完成后调用  onload=regis  或onload=function()
	//-----设置一个方法返回值的变量，来控制onsubmit是否触发
	//-----判断事件的触发行为是submit还是onblur


//传入一个对象，当这个对象的下一个同胞节点名 !=SPAN 那么就把下一外节点赋给当前对象。如果下一个同胞节点名
	//等于SPAN 那么就把这个同胞节点返回给这个方法以。这个方法就是获取下一个名为SPAN的同胞节点。
function gspan(cobj){
	while(true){
		if(cobj.nextSibling.nodeName!="SPAN")
			cobj=cobj.nextSibling;
		else{
			return cobj.nextSibling;
		}
	}
}

//test函数传入一个对象，一个文本信息，一个函数方法
function test(obj,info,fun,click){
	var sp=gspan(obj); //把调用的函数值赋给一个变量sp
	obj.onfocus=function(){		//当被传入的对象获得焦点时触发的事件：
		sp.innerHTML=info;	//obj获得焦点后在sp对象内插入内容 为info
		sp.className="stats2";  //obj获得焦点后给sp对象添加一个类名为stat2的样式
	}
	obj.onblur=function(){		//传入的obj对象失去焦点时触发的事件；
		if(fun(this.value)){	//传入的回调方法再次传入当前对象的值，也就是obj.value  this就代表obj
			sp.innerHTML='输入正确'; //当条件成立时对sp插入内容为"输入正确"
			sp.className='stats4';	//当条件成立时对SP对象添加一个名为stats4的样式
		}else{
			sp.innerHTML=info;	//当条件不成立时sp插入info信息
			sp.className="stats3";	//当条件不成立时对sp添加一个名为stats3的样式
		}
	}
	if(click=="click"){ //在前页面给onsubmit 随便传一个值。当点击submit提交时这个值就会传进来，如果不是			//submit提交则无此值，以此来判断事件是由submit触发的还是由onblur触发的。
		obj.onblur();
	}
}

onload=regis		//页面加载完成后调用

function regis(click){	
	var stat=true;		//设置一个方法返回值的变量，来控制onsubmit是否触发
			//当下面方法中此变量全部为真，onsubmit触发，如果其中有一个为假，则onsubmit就不触发
	var username=document.getElementsByName("username")[0];
	var password=document.getElementsByName("password")[0];
	var repass=document.getElementsByName("repass")[0];
	var email=document.getElementsByName("email")[0];
	var other=document.getElementsByName("other")[0];
	//以表单中的各个名字创建对象
	
	//alert(click.value);
	test(username,"用户名为3-20个字母",function(val){
		if(val.match(/^\S+$/) && val.length >=3 && val.length <=20){
			return true;
		}else{
			stat = false;
			return false;
		}
	},click);
	test(password,"密码0-9，a-z",function(val){
		if(val.match(/^\S+$/) && val.length>=3 && val.length<=20){
			return true;
		}else{
			stat = false;
			return false;
		}
	},click);
	test(repass,"请确认两次密码一致",function(val){
		if(val==password.value && val.match(/^\S+$/)){
			return true;
		}else{
			stat = false;
			return false;
		}
	},click);
	test(email,"请正确输入邮箱格式",function(val){
		if(val.match(/^\w+\@\w+\.\w+/)){
			return true;
		}else{
			stat = false;
			return false;
		}
	},click);
	
	return stat;

}














	-----通过select选项变换图片<br>
	-----onchange() 改变触发事件<br>
	-----selectedIndex 可设置或返回下拉列表中被选选项的索引号<br>
	-----options[] 返回select 元素中所有 option 的一个数组。<br><br><br><br>

<select id='sel' onchange="test(this)">		//onchange() 改变触发事件
	<option value="img/1.jpg">a</option>
	<option value="img/2.jpg">b</option>
	<option value="img/3.jpg">c</option>
	<option value="img/4.jpg">d</option>
</select>
<img src="img/1.jpg" id="tu" height="50" />

<script>
	var tu = document.getElementById('tu');
	function test(obj){
		var index = obj.selectedIndex;	//selectedIndex 可设置或返回下拉列表中被选选项的索引号
		tu.src=obj.options[index].value; //option 返回select 元素中所有 option 的一个数组。
	}

</script>











	-----省份城市多重选择自动变换实例
	-----selected 属性为select 多选时的首选项

<script src="city.js"></script>
<script>
	scity('pro','cit','广东','河源');
</script>







var citys=new Array(
	new Array('南京','徐州','连云港','淮安','盐城','扬州','南通','镇江'),
	new Array('北京'),
	new Array('天津'),
	new Array('上海'),
	new Array('重关'),
	new Array('广州','深圳','珠海','汕头','韶关','河源','梅州'),
	new Array('杭州','宁波','温州','嘉兴','绍兴','金华','舟山'),
	new Array('福州','厦门','莆田','三明','泉州','漳州'),
	new Array('长沙','株州','湘潭','衡阳','邵阳','常德'),
	new Array('武汉','黄石','十堰','宜昌','荆州','孝感')
);


function scity(pname,cname,xf,cs){  //xf是传入的默认省份 
	var province=['江苏','北京','天津','上海','重庆','广东','浙江','福建','湖南','湖北'];
	
	document.write('<select onchange="selectc(this)" id="pro" name="'+pname+'">');
	document.write('<option>--选择省份--</option>');
	var a = 0;
	for(var i=0;i<province.length;i++){  //循环遍历所有省份
		if(typeof(xf)!="undefined"){	//如果传入的省份以定义
			if(province[i]==xf){	//如果遍历到的省份与传入的省份相同
				var sel="selected";  //则给sel变量赋值为“selected”；
				a=i;		//把省份的索引值赋给一个变量a
			}else{
				var sel="";	//否则为空
			}
		}else{
			var sel="";		//如果xf没有定义，则sel为空
		}
		document.write('<option '+sel+' value="'+province[i]+'">'+province[i]+'</option>');
					//sel:如果xf以定义，则这里就会出现selected 被设置成默认第一个显示
	}
	document.write('</select>');

	document.write('<select id="city" name="'+cname+'">');
	document.write('<option>--选择城市--</option>');
	document.write('</select>');

	if(a >0)
		selectc(document.getElementById('pro'),a,cs);


}

function selectc(pobj,a,cs){		//把省份对象传到了函数里。
	if(typeof(a)!="undefined"){	//省份的索引值如果有效
		var index=a;		//则把省份的索引值传给当前索引index
	}else{
	var index=pobj.selectedIndex-1;	//获取select当前省份数组的索引值    //如果省份索引没指定就用默认的。
	}
	var cobj=document.getElementById('city'); //获取城市对象
	cobj.innerHTML="";	//把城市选项栏置空
	if(index >=0){
		for(var i=0;i<citys[index].length;i++){
			if(typeof(cs)!="undefined"){
				if(citys[index][i]==cs){
					var sel='selected';
				}else{
					var sel="";
				}
			}
			var option=document.createElement('option'); //创建option对象
			var text = citys[index][i];	//把城市二维数组的每个城市名赋值给变量text
			option.value=text;		//把text的城市名传给option的value值。
			option.selected=sel;
			option.innerHTML=text;		//把text城市名添加到option的内容里
			cobj.appendChild(option);	//把创建的option追加到cobj对象的子节点。
		}
	}else{
			var option=document.createElement('option'); 
			option.innerHTML='--选择城市--';
			cobj.appendChild(option);
	}
}












	-----offsetWidth  获取对象的宽度
	-----offsetHeight 获取对象的高度

<body>
	<div>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
	</div>
	<img src="image/car1.jpg" id="img"/>
	<script>
		var d = document.getElementsByTagName('div')[0];
		alert(d.offsetWidth);
		alert(d.offsetHeight);

		var img = document.getElementById('img');
		document.write("<br>图片的宽度是："+img.offsetWidth);
		document.write("<br>图片的高度是: "+img.offsetHeight);
	</script>
</body>









	-----offsetTop 当前对象框体与父框体的顶部距离 
	-----one.offsetTop+one.parentNode.offsetTop 可累加
<style>
	body{
		margin:0px;
		margin:0px;
	}
</style>
<body>
<div style="position:absolute;top:80px;left:100px">
	<div style="position:absolute;top:100px;left:100px">
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		<div id="one">aaaaaaaa</div>
	</div>
</div>
	<script>
		var one=document.getElementById('one');
		alert(one.offsetTop+one.parentNode.offsetTop);
		
	</script>
</body>










	-----计算当前对象到HTML的TOP距离的函数

<style>
	body{
		margin:0px;
		margin:0px;
	}
</style>
<body>
<div style="position:absolute;top:80px;left:100px">
	<div style="position:absolute;top:100px;left:100px">
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
		aaaaaaaaaaaaaaaaa<br>
	<div id="one">aaaaaaaa</div>
	</div>
</div>
	<script>
		var one=document.getElementById('one');
		alert(getOffsetTop(one));

		function getOffsetTop(obj){
			var loc=0;
			while(obj){
				if(obj.nodeName=='HTML'){
					break;
				}
				loc+= obj.offsetTop;
				obj=obj.parentNode;
			}
			return loc;
		}
		
	</script>
</body>











	----- scrollTop,scrollLeft 滚动距离
	-----用scroll属性定位网页中的图片让其不随页面滚动而变化

<style>
	#tu{
		position:absolute;
		top:100px;
		left:100px;
	}
</style>

<body onscroll="test()">
	<textarea cols="1000" rows="1000" ></textarea>
	<img src="image/car1.jpg" id='tu' />
	<script>
		var tu=document.getElementById('tu');
		function test(){
			tu.style.top=100+document.body.scrollTop;
			tu.style.left=100+document.body.scrollLeft;
		}
	</script>
</body>


















	-----position:fixed 使图片固定在页面中 

注：fixed固定是针对于HTML框体而言的，而上一实例中的document.body.scrollTop是针对body而言的，它们针对的对象不同。
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html>
	<head>
		<style>
			#tu{
				position:fixed;
				top:100px;
				left:100px;
			}
		</style>
	</head>
	<body>
		<textarea cols="1000" rows="1000" ></textarea>
		<img src="image/car1.jpg" id="tu"/>
	</body>
</html>













	-----利用scroll 做字幕在区域中的无缝滚动
	-----overflow:hidden;    隐藏超出区域的内容

<html>
	<head>
		<style>
			#test{
				width:200px;
				height:200px;
				border:1px solid red;
				overflow:hidden;      //隐藏超出区域的内容
			}
		</style>
	</head>
	<body>
		<div id="test">
			<div id="test1">
				11111111111111111111<br>
				aaaaaaaaaaaaaaaaaaaa<br>
				aaaaaaaaeeeaaaaaaaaaaaa<br>
				aaaaaaaccaaaaaaaaaaaaa<br>
				aaaaaaaaffaaaaaaaaaaaa<br>
				aaaaaaaaaaaaaaaaaaaa<br>
				aaaaaaaaaggggaaaaaaaaaaa<br>
				aaaaaaaaaaaaaaaaaaaa<br>
				aaaaaaaaaer3rrtgraaaaaaaaaaa<br>
				aaaaaaaaaaaaaaaaaaaa<br>
				aaaaaaaaaaaaaaaaaaaa<br>
				aaaaaaaaaaaaaaaaaaaa<br>

			</div>	
			<div id="test2"></div>
		</div>
		<script>
			var test=document.getElementById('test');
			var test1=document.getElementById('test1');
			var test2=document.getElementById('test2');
			test2.innerHTML = test1.innerHTML;
			function move(){
				if(test1.offsetHeight - test.scrollTop <= 0){
					test.scrollTop-=test1.offsetHeight;
				}
				test.scrollTop++; 
//这里为什么要设置test？是因为scroll认识的一个误区。scroll的滚动值是指父框体与当前框体的距离，当这个距离增加时，那么test框体就是往下走的，这样文本的框体相对来看就是向上走的！
				
				window.document.title=test.scrollTop;
			}

			setInterval("move()",100);
		</script>
	</body>
</html>






